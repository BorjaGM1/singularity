<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SINGULARITY</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@400;500&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;cursor:grab;font-family:'Instrument Sans',sans-serif;}
body:active{cursor:grabbing;}
canvas{display:block;}
#overlay{position:fixed;inset:0;pointer-events:none;z-index:10;
  background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.5) 100%);}
#info{position:fixed;bottom:24px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.3);font-size:11px;letter-spacing:3px;
  text-align:center;pointer-events:none;z-index:20;}
#wavemode{position:fixed;top:28px;right:28px;z-index:20;display:flex;gap:6px;}
#wavemode button{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  color:rgba(255,255,255,0.4);font-family:'Instrument Sans',sans-serif;font-size:10px;
  letter-spacing:2px;padding:6px 12px;cursor:pointer;transition:all 0.4s;text-transform:uppercase;}
#wavemode button:hover{background:rgba(255,255,255,0.12);color:rgba(255,255,255,0.6);}
#wavemode button.active{border-color:rgba(255,255,255,0.5);color:rgba(255,255,255,0.8);}
#wavemode button.active.vis{background:rgba(255,180,80,0.2);border-color:rgba(255,180,80,0.5);}
#wavemode button.active.xray{background:rgba(80,160,255,0.2);border-color:rgba(80,160,255,0.5);}
#wavemode button.active.radio{background:rgba(255,80,80,0.2);border-color:rgba(255,80,80,0.5);}
#spinctl{position:fixed;bottom:60px;right:28px;z-index:20;text-align:right;
  font-family:'Instrument Sans',sans-serif;font-size:9px;letter-spacing:2px;color:rgba(255,255,255,0.3);text-transform:uppercase;}
#spinctl label{display:block;margin-bottom:6px;}
#spinctl input[type=range]{-webkit-appearance:none;width:120px;height:3px;background:rgba(255,255,255,0.15);
  border-radius:2px;outline:none;cursor:pointer;}
#spinctl input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;
  border-radius:50%;background:rgba(255,255,255,0.5);border:1px solid rgba(255,255,255,0.3);cursor:pointer;}
#spinctl .spin-val{font-size:12px;color:rgba(255,255,255,0.5);font-variant-numeric:tabular-nums;margin-top:3px;}
/* Time dilation */
#timedilation{position:fixed;bottom:60px;left:28px;z-index:20;pointer-events:none;
  font-family:'Instrument Sans',sans-serif;font-size:10px;letter-spacing:1px;color:rgba(255,255,255,0.35);}
#timedilation .td-title{font-size:9px;letter-spacing:3px;text-transform:uppercase;margin-bottom:8px;
  color:rgba(255,255,255,0.25);}
#timedilation .td-row{display:flex;align-items:center;gap:8px;margin-bottom:5px;height:16px;}
#timedilation .td-label{width:90px;text-align:right;font-size:9px;}
#timedilation .td-bar{height:3px;background:rgba(255,255,255,0.1);border-radius:2px;width:80px;overflow:hidden;}
#timedilation .td-fill{height:100%;border-radius:2px;transition:width 0.3s;}
#timedilation .td-val{font-size:9px;width:40px;font-variant-numeric:tabular-nums;}
#timedilation .td-cam{color:rgba(255,200,100,0.6);}
#timedilation .td-clock{display:inline-block;width:16px;text-align:center;font-size:14px;line-height:14px;}
/* Info panel */
#infobtn{position:fixed;top:28px;left:28px;z-index:25;background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.15);color:rgba(255,255,255,0.4);font-family:'Instrument Sans',sans-serif;
  font-size:10px;letter-spacing:2px;padding:6px 12px;cursor:pointer;transition:all 0.4s;text-transform:uppercase;}
#infobtn:hover{background:rgba(255,255,255,0.12);color:rgba(255,255,255,0.6);}
#infobtn.active{border-color:rgba(255,255,255,0.5);color:rgba(255,255,255,0.8);background:rgba(255,255,255,0.1);}
#infopanel{position:fixed;top:0;right:-420px;width:400px;height:100%;z-index:30;
  background:rgba(0,0,0,0.92);border-left:1px solid rgba(255,255,255,0.08);
  padding:32px 28px;overflow-y:auto;transition:right 0.4s cubic-bezier(0.4,0,0.2,1);
  font-family:'Instrument Sans',sans-serif;color:rgba(255,255,255,0.6);font-size:13px;line-height:1.7;}
#infopanel.open{right:0;}
#infopanel h2{font-size:11px;letter-spacing:4px;text-transform:uppercase;color:rgba(255,255,255,0.3);
  margin:28px 0 12px;font-weight:500;}
#infopanel h2:first-child{margin-top:0;}
#infopanel p{margin-bottom:12px;color:rgba(255,255,255,0.5);}
#infopanel .highlight{color:rgba(255,200,100,0.8);}
#infopanel .key{display:inline-block;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  border-radius:3px;padding:1px 6px;font-size:11px;color:rgba(255,255,255,0.5);margin:0 2px;}
#infopanel .section{margin-bottom:24px;padding-bottom:24px;border-bottom:1px solid rgba(255,255,255,0.06);}
#infopanel .close{position:sticky;top:0;float:right;background:rgba(0,0,0,0.8);border:none;color:rgba(255,255,255,0.3);
  font-size:20px;cursor:pointer;padding:8px 12px;z-index:31;}
#infopanel .close:hover{color:rgba(255,255,255,0.6);}
#infopanel ul{margin:8px 0 12px 16px;color:rgba(255,255,255,0.45);font-size:12px;}
#infopanel li{margin-bottom:6px;}
#title{position:fixed;top:28px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.45);font-size:13px;letter-spacing:12px;
  text-transform:uppercase;pointer-events:none;z-index:20;font-weight:500;}
</style>
</head>
<body>
<div id="overlay"></div>
<div id="title">SINGULARITY</div>
<button id="infobtn" onclick="toggleInfo()">Info</button>
<div id="wavemode">
  <button class="vis active" onclick="setWaveMode(0)">Visible</button>
  <button class="xray" onclick="setWaveMode(1)">X-Ray</button>
  <button class="radio" onclick="setWaveMode(2)">Radio</button>
</div>

<div id="infopanel">
  <button class="close" onclick="toggleInfo()">✕</button>

  <div class="section">
    <h2>What is this?</h2>
    <p>A real-time simulation of a <span class="highlight">supermassive black hole</span> with an accretion disk, relativistic jets, and gravitational lensing. Everything you see is computed using actual physics — General Relativity, Schwarzschild spacetime geometry, and blackbody radiation.</p>
    <p>Every galaxy is believed to harbor a supermassive black hole at its center, ranging from millions to billions of solar masses. When gas, dust, or even whole stars fall close enough, they form a swirling accretion disk that heats to millions of degrees — making the black hole visible across the universe despite the hole itself emitting no light.</p>
    <p>Built entirely in a single HTML file with Three.js and WebGL shaders. No external assets, no server — everything runs in your browser.</p>
  </div>

  <div class="section">
    <h2>Accretion Disk</h2>
    <p>The glowing ring of material orbiting the black hole. In reality, this is superheated gas (mostly hydrogen and helium) spiraling inward, heated by friction and compression to millions of degrees.</p>
    <ul>
      <li><span class="highlight">90,000 particles</span> placed using fractal noise density for realistic clumping and structure.</li>
      <li><span class="highlight">Keplerian Orbits</span> — inner particles orbit faster than outer ones, following Kepler's third law: v ∝ 1/√r. This differential rotation is what generates the friction that heats the disk.</li>
      <li><span class="highlight">Temperature Gradient</span> — white-hot inner edge (closest to the event horizon) through yellow and orange to dim red at the outer edge. This matches real accretion disk physics where temperature ∝ r<sup>−3/4</sup>.</li>
      <li><span class="highlight">Doppler Beaming</span> — the side of the disk rotating toward you appears brighter and slightly blue-shifted; the receding side appears dimmer and red-shifted. This asymmetry was clearly visible in the Event Horizon Telescope's images of M87* and Sagittarius A*.</li>
      <li><span class="highlight">Gravitational Redshift</span> — photons emitted near the event horizon lose energy climbing out of the gravity well. The formula z = 1/√(1 − r<sub>s</sub>/r) − 1 means particles at the inner disk edge appear noticeably redder than their true temperature. Blue light is affected most strongly.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Event Horizon &amp; Gravitational Lensing</h2>
    <p>The <span class="highlight">event horizon</span> is the boundary beyond which nothing — not even light — can escape. The black sphere you see is actually the <span class="highlight">black hole shadow</span>, which appears larger than the event horizon because light passing nearby gets bent inward.</p>
    <ul>
      <li><span class="highlight">Photon Sphere</span> (r = 1.5 r<sub>s</sub>) — at this radius, light can theoretically orbit the black hole in an unstable circular path. In the simulation, stars near this radius get amplified into a bright <span class="highlight">Einstein ring</span>.</li>
      <li><span class="highlight">Gravitational Lensing</span> — the 25,000 background stars are rendered to a separate texture, then warped by a distortion shader. Each pixel's sampling point is displaced outward from the black hole center with deflection ∝ 1/b² (where b is the impact parameter). Stars behind the black hole appear to wrap around it — this was first observed during the 1919 solar eclipse and confirmed Einstein's General Relativity.</li>
      <li><span class="highlight">Einstein Ring</span> — when a star is directly behind the black hole, its light is bent equally in all directions, forming a perfect ring of amplified light around the shadow. In the simulation, stars near the photon sphere receive a 3× brightness boost.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Relativistic Jets</h2>
    <p>Twin beams of plasma ejected along the black hole's rotation axis at velocities approaching the speed of light. Not all accreting black holes produce jets — the mechanism involves magnetic field lines twisted by the spinning accretion disk (the Blandford–Znajek process) or by the spinning black hole itself.</p>
    <ul>
      <li>Jets can extend <span class="highlight">millions of light-years</span> into intergalactic space, making them the largest single structures in the universe.</li>
      <li>The jets contain plasma heated to billions of degrees, making them bright in <span class="highlight">X-ray</span> wavelengths.</li>
      <li>Charged particles spiraling in the jet's magnetic fields emit <span class="highlight">synchrotron radiation</span>, which is why jets dominate in radio observations — try switching to Radio mode to see this effect.</li>
      <li>In the simulation: 5,000 particles per jet, helically twisted, with blue-white core coloring.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Matter Infall</h2>
    <p>12 clumps of gas continuously spiral inward from the outer disk, accelerating as they fall deeper into the gravity well. They leave bright trails that fade as they cross the event horizon.</p>
    <p>In reality, matter doesn't fall smoothly — turbulence, magnetic reconnection events, and instabilities create clumps and flares. The inner accretion flow is chaotic and variable, which is why real black holes "flicker" in brightness on timescales of minutes to hours.</p>
  </div>

  <div class="section">
    <h2>Tidal Disruption Event (TDE)</h2>
    <p>Press <span class="key">T</span> or <span class="key">Double-click</span> to trigger one.</p>
    <p>A TDE is one of the most violent events in the universe. It occurs when a star wanders too close to a supermassive black hole — typically through gravitational interactions with other stars in the dense galactic core.</p>
    <p><span class="highlight">What happens physically:</span></p>
    <ul>
      <li><span class="highlight">Approach</span> — the star falls toward the black hole on a nearly parabolic orbit, accelerating as it descends into the gravity well.</li>
      <li><span class="highlight">Tidal Radius</span> — at ~2.8 r<sub>s</sub>, the <em>differential</em> gravitational force across the star (stronger on the near side, weaker on the far side) exceeds the star's own self-gravity. The star can no longer hold itself together.</li>
      <li><span class="highlight">Spaghettification</span> — the star is stretched along the radial direction and compressed perpendicular to it. It elongates into a thin stream of hot gas — the famous "spaghettification" coined by Stephen Hawking.</li>
      <li><span class="highlight">Debris Stream</span> — roughly half the stellar mass gains enough energy to escape entirely. The other half forms a long, thin stream that wraps around the black hole, eventually circularizing into a temporary accretion disk.</li>
      <li><span class="highlight">Flare</span> — the infalling debris heats to extreme temperatures, producing a brilliant flare visible across billions of light-years. The flare typically peaks in UV/X-ray and fades over weeks to months.</li>
    </ul>
    <p><span class="highlight">Observational history:</span></p>
    <ul>
      <li>First well-confirmed TDEs were detected in X-ray surveys by ROSAT in the 1990s — sudden brightening in the centers of otherwise quiet galaxies.</li>
      <li>Modern surveys (ZTF, LSST, eROSITA) now detect several TDEs per year.</li>
      <li>TDEs are invaluable for astronomers — they briefly "light up" dormant black holes that would otherwise be completely invisible, revealing their mass and spin.</li>
      <li>The tidal radius depends on black hole mass: for black holes above ~10<sup>8</sup> solar masses, Sun-like stars are swallowed whole because the tidal radius falls inside the event horizon.</li>
    </ul>
    <p><span class="highlight">In the simulation:</span> 2,500 particles start clustered as a compact star, fall on a trajectory with angular momentum, get tidally stretched at the tidal radius (force ∝ r<sup>−3.5</sup>), and form an orbiting debris stream. Color evolves from white-blue (intact star) through yellow-white (disruption) to orange-red (cooling debris). Particles that reach r &lt; 0.5 r<sub>s</sub> are absorbed. Sound design includes a rising pitch during approach and a filtered noise burst at disruption.</p>
  </div>

  <div class="section">
    <h2>Time Dilation (dτ/dt)</h2>
    <p>In General Relativity, time flows slower in stronger gravitational fields. This isn't an illusion — it's a real, measurable effect. The <span class="highlight">dτ/dt</span> value (proper time / coordinate time) shows how fast a local clock ticks compared to a distant observer's clock.</p>
    <p>The formula is: <span class="highlight">dτ/dt = √(1 − r<sub>s</sub>/r)</span></p>
    <ul>
      <li><span class="highlight">Event Horizon</span> (r = r<sub>s</sub>) → 0.000 — time completely stops as seen from outside. A clock falling toward the event horizon would appear to slow down and freeze at the boundary — its last photons redshifted into oblivion. From the clock's own perspective, it crosses normally.</li>
      <li><span class="highlight">ISCO</span> (r = 3r<sub>s</sub>) → 0.577 — the Innermost Stable Circular Orbit. Below this radius, no stable orbit exists — any perturbation causes matter to spiral inward. This is the inner edge of the accretion disk. Time flows at 58% normal speed.</li>
      <li><span class="highlight">Inner Disk</span> (r = 2r<sub>s</sub>) → 0.707 — matter here is on unstable plunging orbits. Extremely hot and fast. Time at 71%.</li>
      <li><span class="highlight">Outer Disk</span> (r = 7.5r<sub>s</sub>) → 0.926 — nearly normal time. Gravitational time dilation is measurable but small at this distance.</li>
      <li><span class="highlight">Camera</span> → varies — this is YOU. Zoom in and watch your clock slow down. At minimum zoom distance (~2.5 r<sub>s</sub>), you'd experience significant time dilation.</li>
      <li><span class="highlight">Distant Observer</span> → 1.000 — infinitely far from the black hole. Normal time. This is the reference frame.</li>
    </ul>
    <p>The <span class="highlight">blinking dots</span> (●/○) next to each row tick at rates proportional to their time dilation factor. The distant observer blinks steadily. The ISCO dot blinks noticeably slower. The event horizon dot is essentially frozen. Zoom in and watch your camera dot slow down.</p>
    <p>This same effect operates on Earth, just far weaker. GPS satellites orbit at ~20,200 km altitude where gravity is weaker — their clocks tick ~38 microseconds faster per day than ground clocks. Without relativistic corrections, GPS would drift by ~10 km per day.</p>
  </div>

  <div class="section">
    <h2>Wavelength Modes</h2>
    <p>Real astronomers observe black holes across the electromagnetic spectrum. Each wavelength reveals different physics:</p>
    <ul>
      <li><span class="highlight">Visible</span> — what your eyes would see (if you could survive). Blackbody thermal radiation from hot gas. The accretion disk glows orange-white to red based on temperature. This is the hardest band to observe because dust in galaxies blocks visible light.</li>
      <li><span class="highlight">X-Ray</span> — how space telescopes like Chandra and XMM-Newton see black holes. Gas at millions of degrees emits X-rays. The blue-white palette reflects the extreme temperatures. Jets glow bright because they contain ultra-hot plasma. Most known stellar-mass black holes were first discovered in X-ray. The corona — a mysterious hot region above the disk — is brightest in X-ray.</li>
      <li><span class="highlight">Radio</span> — how radio telescopes (VLA, ALMA, EHT) observe them. False-color red/yellow (radio has no "real" color). Jets become dominant because they emit <span class="highlight">synchrotron radiation</span> — charged particles spiraling in magnetic fields at relativistic speeds. The Event Horizon Telescope's famous images of M87* and Sgr A* were captured at 1.3mm radio wavelength. Stars virtually disappear because stars are faint radio emitters.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Visual Effects</h2>
    <ul>
      <li><span class="highlight">Anamorphic Streaks</span> — cinematic horizontal light streaks from the brightest regions, simulating an anamorphic lens flare. These are an artistic effect (not physical), created by 4 passes of ultra-wide horizontal blur at quarter resolution.</li>
      <li><span class="highlight">Bloom</span> — bright regions bleed light into neighboring pixels, simulating how real cameras and eyes respond to intense light sources. 3-pass Gaussian blur with threshold extraction.</li>
      <li><span class="highlight">Chromatic Aberration</span> — slight red/blue fringing at the edges of the frame, simulating imperfect optics.</li>
      <li><span class="highlight">Film Grain</span> — subtle noise overlay for cinematic texture.</li>
      <li><span class="highlight">Ambient Sound</span> — deep space drone built from detuned oscillators, proximity-reactive rumble, radiation noise hiss. The pulse (spacebar) triggers a sub-bass impact with metallic shimmer. TDE events have their own rising-pitch approach sound with a tearing noise burst.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Controls</h2>
    <ul>
      <li><span class="key">Drag</span> Orbit the camera around the black hole</li>
      <li><span class="key">Scroll</span> Zoom in/out (affects time dilation!)</li>
      <li><span class="key">Space</span> Gravitational pulse — visual + sound burst</li>
      <li><span class="key">1</span> <span class="key">2</span> <span class="key">3</span> Switch wavelength (Visible / X-Ray / Radio)</li>
      <li><span class="key">T</span> or <span class="key">Double-click</span> Trigger a tidal disruption event</li>
      <li><span class="key">Spin slider</span> (bottom-right) Adjust black hole angular momentum a*</li>
      <li><span class="key">I</span> Toggle this info panel</li>
    </ul>
  </div>

  <div class="section">
    <h2>The Physics — Key Equations</h2>
    <p>This simulation uses the <span class="highlight">Schwarzschild metric</span> — the exact solution to Einstein's field equations for a non-rotating, uncharged black hole, published by Karl Schwarzschild in 1916, just months after Einstein published General Relativity.</p>
    <ul>
      <li><strong>Schwarzschild radius:</strong> r<sub>s</sub> = 2GM/c² — the event horizon radius. For our Sun, this would be ~3 km. For the M87* black hole (6.5 billion solar masses), it's ~19 billion km.</li>
      <li><strong>Orbital velocity:</strong> v = √(GM/r) — Kepler's law. Inner disk particles orbit faster.</li>
      <li><strong>Gravitational redshift:</strong> z = 1/√(1 − r<sub>s</sub>/r) − 1 — photon energy loss climbing out of the well.</li>
      <li><strong>Time dilation:</strong> dτ/dt = √(1 − r<sub>s</sub>/r) — proper time versus coordinate time.</li>
      <li><strong>Photon sphere:</strong> r = 1.5 r<sub>s</sub> — where light can orbit (unstably) around the black hole.</li>
      <li><strong>ISCO:</strong> r = 3 r<sub>s</sub> — innermost stable circular orbit (for Schwarzschild; spinning black holes differ).</li>
      <li><strong>Tidal acceleration:</strong> a<sub>tidal</sub> ∝ r<sup>−3</sup> — differential gravity that tears apart stars.</li>
      <li><strong>Gravitational lensing:</strong> deflection ∝ 1/b² (impact parameter) — Schwarzschild light bending.</li>
    </ul>
  </div>

  <div class="section">
    <h2>What is Black Hole Spin?</h2>
    <p>Black holes have only three measurable properties: <span class="highlight">mass</span>, <span class="highlight">spin</span> (angular momentum), and <span class="highlight">electric charge</span> (negligible in nature). This is the "no-hair theorem" — all other information about the matter that formed the black hole is lost.</p>
    <p>Spin is measured by the dimensionless parameter <span class="highlight">a* = Jc/GM²</span>, where J is angular momentum. It ranges from 0 (non-rotating, "Schwarzschild" black hole) to a theoretical maximum of 1 (an "extremal Kerr" black hole, where the event horizon rotates at the speed of light).</p>
    <p><span class="highlight">Why do black holes spin?</span> For the same reason an ice skater spins faster when pulling in their arms — conservation of angular momentum. When a massive star collapses, or when gas spirals inward from an accretion disk, the angular momentum gets concentrated into a smaller and smaller space. Almost all real black holes spin, and many spin very fast.</p>
    <p><span class="highlight">Real spin measurements:</span></p>
    <ul>
      <li><span class="highlight">M87*</span> (6.5 billion M☉, imaged by the EHT) — a* ≈ 0.9</li>
      <li><span class="highlight">Cygnus X-1</span> (21 M☉, first confirmed BH) — a* > 0.95</li>
      <li><span class="highlight">GRS 1915+105</span> (12 M☉, microquasar) — a* ≈ 0.998</li>
      <li><span class="highlight">Sagittarius A*</span> (4 million M☉, our galaxy's center) — a* ≈ 0.9 (estimated)</li>
    </ul>
    <p>Spin is measured by observing the inner edge of the accretion disk (which depends on ISCO radius), the shape of X-ray reflection spectra (iron line profile), and gravitational wave signals from merging black holes.</p>
  </div>

  <div class="section">
    <h2>Kerr Black Hole — What Changes with Spin</h2>
    <p>Use the <span class="highlight">spin slider</span> (bottom-right) to change a*. The simulation updates everything in real-time.</p>

    <p><span class="highlight">Event Horizon Shrinks</span></p>
    <p>r<sub>+</sub> = M(1 + √(1−a*²)). A non-spinning black hole has its horizon at the full Schwarzschild radius. At a*≈1, the horizon shrinks to half that size. You can see the black sphere physically get smaller as you increase spin. This is because the spinning spacetime "supports" the horizon at a smaller radius — loosely analogous to how a spinning top is more stable.</p>
    <ul>
      <li>a* = 0.0 → r<sub>+</sub> = 1.00 r<sub>s</sub></li>
      <li>a* = 0.5 → r<sub>+</sub> = 0.93 r<sub>s</sub></li>
      <li>a* = 0.7 → r<sub>+</sub> = 0.86 r<sub>s</sub> (default)</li>
      <li>a* = 0.9 → r<sub>+</sub> = 0.72 r<sub>s</sub></li>
      <li>a* = 0.998 → r<sub>+</sub> = 0.53 r<sub>s</sub></li>
    </ul>

    <p><span class="highlight">The Ergosphere</span></p>
    <p>The purple-blue glow between the horizon and r=1.0. Inside this region, spacetime itself rotates so fast that <em>nothing</em> can remain stationary — not matter, not light, not even spacetime itself. Everything is forced to co-rotate with the black hole. It's oblate: at the equator it always extends to r=1.0 regardless of spin, but at the poles it touches the horizon. The rotating streaks visualize the direction of frame-dragging.</p>
    <p>The ergosphere is where the <span class="highlight">Penrose process</span> operates: in principle, you can extract energy from a spinning black hole by sending matter into the ergosphere and splitting it so one piece falls in while the other escapes with MORE energy than the original particle had. This is not science fiction — it's a proven consequence of General Relativity and may power real astrophysical jets.</p>

    <p><span class="highlight">Frame Dragging (Lense-Thirring Effect)</span></p>
    <p>The spinning black hole drags spacetime with it, like a ball spinning in honey. Everything near the black hole gains extra angular velocity — the inner disk spins faster than Kepler's law alone would predict. The formula: ω<sub>fd</sub> = 2Ma*/(r(r²+a²M²)+2a²M³). Inner particles are dragged most.</p>
    <p>This effect is real and measurable: NASA's Gravity Probe B (2004-2011) measured frame-dragging from Earth's rotation — a shift of just 37 milliarcseconds per year. Near a spinning black hole, the effect is billions of times stronger.</p>

    <p><span class="highlight">ISCO Moves Inward</span></p>
    <p>The most visually dramatic effect. The Innermost Stable Circular Orbit (ISCO) — the inner edge of the accretion disk — depends on spin:</p>
    <ul>
      <li>a* = 0.0 → ISCO = 3.00 r<sub>s</sub> (big gap between disk and horizon)</li>
      <li>a* = 0.5 → ISCO = 2.32 r<sub>s</sub></li>
      <li>a* = 0.7 → ISCO = 1.70 r<sub>s</sub> (default)</li>
      <li>a* = 0.9 → ISCO = 1.15 r<sub>s</sub></li>
      <li>a* = 0.998 → ISCO = 0.62 r<sub>s</sub> (disk almost touches horizon)</li>
    </ul>
    <p>This is how astronomers measure spin in real black holes — by observing how close the inner disk edge gets. A closer inner edge means more gravitational energy is radiated before matter falls in. A maximally spinning BH can convert ~42% of infalling mass to energy (vs. ~6% for non-spinning). For comparison, nuclear fusion converts only ~0.7%. Spinning black holes are the most efficient energy sources in the universe.</p>
    <p>Try dragging the slider from 0 to 0.998 — watch the inner disk region empty out at low spin and fill in completely at high spin.</p>

    <p><span class="highlight">Time Dilation Changes</span></p>
    <p>All dτ/dt values in the HUD (bottom-left) recalculate in real-time using the Kerr metric. At higher spin, the ISCO is closer to the horizon, so time there flows much slower. The blinking clock dots update accordingly.</p>
  </div>

  <div class="section" style="border:none;">
    <h2>Simplifications &amp; Known Limits</h2>
    <p>This simulation prioritizes visual accuracy and real-time performance over full GR ray-tracing. Notable simplifications:</p>
    <ul>
      <li>Gravitational lensing uses screen-space distortion rather than full Kerr geodesic ray-tracing — a spinning black hole would produce asymmetric lensing (light co-rotating with the BH bends differently from counter-rotating light). This is not yet implemented.</li>
      <li>The accretion disk is geometrically thin. Real disks can be thick (ADAF/RIAF at low accretion rates) or slim (at super-Eddington rates).</li>
      <li>TDE timescales are compressed — real events unfold over weeks to months, not seconds.</li>
      <li>No magnetohydrodynamics (MHD) — magnetic fields play a crucial role in jet formation (Blandford-Znajek process), disk turbulence (MRI instability), and angular momentum transport.</li>
      <li>The Penrose process and superradiance are not simulated — only the visual ergosphere is shown.</li>
      <li>Retrograde orbits are not modeled — all disk particles orbit prograde.</li>
    </ul>
  </div>
</div>

<div id="info">drag to orbit · scroll to zoom · space to pulse · 1/2/3 wavelength · T for tidal disruption · I for info</div>
<div id="timedilation">
  <div class="td-title">Time Dilation · dτ/dt</div>
  <div class="td-row"><span class="td-label">Event Horizon</span><div class="td-bar"><div class="td-fill" id="td-eh" style="width:0%;background:#f44;"></div></div><span class="td-val">0.000</span><span class="td-clock" id="tc-eh">·</span></div>
  <div class="td-row"><span class="td-label">ISCO (3 rs)</span><div class="td-bar"><div class="td-fill" id="td-isco" style="width:57.7%;background:#fa4;"></div></div><span class="td-val">0.577</span><span class="td-clock" id="tc-isco">·</span></div>
  <div class="td-row"><span class="td-label">Inner Disk</span><div class="td-bar"><div class="td-fill" id="td-inner" style="width:70.7%;background:#fb4;"></div></div><span class="td-val">0.707</span><span class="td-clock" id="tc-inner">·</span></div>
  <div class="td-row"><span class="td-label">Outer Disk</span><div class="td-bar"><div class="td-fill" id="td-outer" style="width:92.6%;background:#be5;"></div></div><span class="td-val">0.926</span><span class="td-clock" id="tc-outer">·</span></div>
  <div class="td-row td-cam"><span class="td-label">▸ Camera</span><div class="td-bar"><div class="td-fill" id="td-cam" style="width:90%;background:#fc8;"></div></div><span class="td-val" id="td-cam-val">0.900</span><span class="td-clock" id="tc-cam">·</span></div>
  <div class="td-row"><span class="td-label">Distant Observer</span><div class="td-bar"><div class="td-fill" id="td-inf" style="width:100%;background:#8d8;"></div></div><span class="td-val">1.000</span><span class="td-clock" id="tc-inf">·</span></div>
</div>
<div id="spinctl">
  <label>Black Hole Spin · a*</label>
  <input type="range" id="spinslider" min="0" max="0.998" step="0.01" value="0.7" oninput="setSpinA(parseFloat(this.value))">
  <div class="spin-val" id="spinval">a* = 0.700</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// SINGULARITY — HYBRID
// Raymarched gravitationally-lensed starfield background
// + Particle accretion disk, jets, void sphere
// + Full bloom pipeline
// ============================================================

// === Procedural sprite textures ===
function genSprite(size,falloff,softness){
  const c=document.createElement('canvas');c.width=c.height=size;
  const ctx=c.getContext('2d'),img=ctx.createImageData(size,size),h=size/2;
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){
    const d=Math.sqrt(((x-h)/h)**2+((y-h)/h)**2);
    const a=Math.min(1,Math.exp(-d*d*falloff)+Math.exp(-d*d*softness)*0.3);
    const i=(y*size+x)*4;img.data[i]=img.data[i+1]=img.data[i+2]=255;img.data[i+3]=a*255|0;
  }
  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c);tex.needsUpdate=true;return tex;
}
const diskTex=genSprite(64,4.0,1.2),jetTex=genSprite(32,3.0,0.8);

// ============================================================
// KERR BLACK HOLE PHYSICS
// Spin parameter a* ∈ [0, 0.998]. a*=0 → Schwarzschild, a*→1 → extremal Kerr
// All lengths in units where Schwarzschild radius RS = 2M = 1.0, so M = 0.5
// ============================================================
const M_BH = 0.5; // mass in our units (RS = 2M = 1.0)
let spinA = 0.7;   // dimensionless spin parameter a* = a/M

function kerrEventHorizon(a) {
  // r+ = M(1 + √(1 - a*²))
  return M_BH * (1.0 + Math.sqrt(Math.max(0, 1.0 - a * a)));
}

function kerrErgosphere(a, cosTheta) {
  // r_ergo(θ) = M + √(M² - a²M²cos²θ) = M(1 + √(1 - a*²cos²θ))
  return M_BH * (1.0 + Math.sqrt(Math.max(0, 1.0 - a * a * cosTheta * cosTheta)));
}

function kerrISCO(a) {
  // Exact ISCO formula for prograde orbit in Kerr spacetime
  // Returns r_isco in our coordinate units
  const a2 = a * a;
  const z1 = 1.0 + Math.pow(1.0 - a2, 1.0/3.0) * (Math.pow(1.0 + a, 1.0/3.0) + Math.pow(Math.max(0, 1.0 - a), 1.0/3.0));
  const z2 = Math.sqrt(3.0 * a2 + z1 * z1);
  const pro = 3.0 + z2 - Math.sqrt(Math.max(0, (3.0 - z1) * (3.0 + z1 + 2.0 * z2)));
  const retro = 3.0 + z2 + Math.sqrt(Math.max(0, (3.0 - z1) * (3.0 + z1 + 2.0 * z2)));
  return { prograde: pro * M_BH, retrograde: retro * M_BH };
}

function kerrFrameDrag(a, r) {
  // Frame-dragging angular velocity ω = 2Ma*/(r(r²+a²M²)+2a²M³)
  // Simplified for equatorial plane
  const aM = a * M_BH;
  const r2 = r * r;
  const a2M2 = aM * aM;
  return (2.0 * M_BH * aM) / (r * (r2 + a2M2) + 2.0 * a2M2 * M_BH);
}

function kerrTimeDilation(a, r) {
  // Approximate Kerr time dilation at equator
  // dτ/dt = √(1 - 2M/r) for Schwarzschild
  // For Kerr: dτ/dt ≈ √(1 - 2M/(r + a²M²/r))  (simplified equatorial)
  const a2M2 = a * a * M_BH * M_BH;
  const rEff = r + a2M2 / r;
  return Math.sqrt(Math.max(0.001, 1.0 - 2.0 * M_BH / rEff));
}

// Current derived values (updated when spin changes)
let rPlus = kerrEventHorizon(spinA);
let isco = kerrISCO(spinA);
let rErgoEquator = 1.0; // Always 2M = 1.0 at equator

// === JS noise for particle placement ===
function hash2(x,y){let h=x*374761393+y*668265263;h=(h^(h>>13))*1274126177;return((h^(h>>16))&0x7fffffff)/0x7fffffff;}
function sNoise(x,y){const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy;
  const sx=fx*fx*(3-2*fx),sy=fy*fy*(3-2*fy);
  return hash2(ix,iy)*(1-sx)*(1-sy)+hash2(ix+1,iy)*sx*(1-sy)+hash2(ix,iy+1)*(1-sx)*sy+hash2(ix+1,iy+1)*sx*sy;}
function fbm(x,y,o){let v=0,a=0.5,f=1;for(let i=0;i<o;i++){v+=sNoise(x*f,y*f)*a;a*=0.5;f*=2;}return v;}

// ============================================================
// RENDERER
// ============================================================
const renderer=new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.autoClear=false;
document.body.appendChild(renderer.domElement);

const pxr=Math.min(window.devicePixelRatio,2);
function makeRT(s){return new THREE.WebGLRenderTarget(window.innerWidth*pxr*s,window.innerHeight*pxr*s,
  {type:THREE.HalfFloatType,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter});}

// Render targets
let rtBG=makeRT(1);          // raymarched background (full res for alignment)
let rtStars=makeRT(1);       // raw star render
let rtStarsLensed=makeRT(1); // gravitationally lensed stars
let rtParticles=makeRT(1);   // particle scene
let rtCombined=makeRT(1);    // combined
let rtBright=makeRT(0.5);
let rtBlurA=makeRT(0.5),rtBlurB=makeRT(0.5);
let rtStreakA=makeRT(0.25),rtStreakB=makeRT(0.25); // lower res for wide streaks

const fsGeo=new THREE.PlaneGeometry(2,2);
const ortho=new THREE.OrthographicCamera(-1,1,1,-1,0,1);

// ============================================================
// PASS 1: RAYMARCHED LENSED STARFIELD
// Only traces stars through curved spacetime — no disk rendering
// ============================================================
const CAM_FOV=55.0;
const FOV_MULT=2.0*Math.tan(CAM_FOV*0.5*Math.PI/180.0); // ≈1.039

const bgMat=new THREE.ShaderMaterial({
  uniforms:{
    uRes:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},
    uCamPos:{value:new THREE.Vector3(0,3,8)},
    uTime:{value:0},
    uFov:{value:FOV_MULT},
    uMode:{value:0},
    uRPlus:{value:rPlus},
    uSpinA:{value:spinA}
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    precision highp float;
    uniform vec2 uRes;
    uniform vec3 uCamPos;
    uniform float uTime,uFov,uMode,uRPlus,uSpinA;
    varying vec2 vUv;

    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}

    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));

      float b=length(cross(uCamPos,rd));
      // Photon sphere scales with spin: ~1.5*RS for Schwarzschild, smaller for Kerr prograde
      float photonR=uRPlus*(1.0+0.5/(1.0+uSpinA));
      float ringGlow=exp(-pow(b-photonR,2.0)*18.0)*0.15;
      float shadowEdge=exp(-pow(b-uRPlus*1.1,2.0)*5.0)*0.06;

      // Ergosphere glow — faint ring between rPlus and 1.0
      float ergoGlow=0.0;
      if(uSpinA>0.01){
        float ergoR=0.5*(uRPlus+1.0); // middle of ergosphere
        float ergoWidth=1.0-uRPlus;
        ergoGlow=exp(-pow(b-ergoR,2.0)/(ergoWidth*ergoWidth*0.3))*0.04*uSpinA;
      }

      // Mode-dependent glow color
      vec3 ringCol,edgeCol,ergoCol;
      if(uMode<0.5){
        ringCol=vec3(1.0,0.9,0.72); edgeCol=vec3(1.0,0.85,0.6); ergoCol=vec3(0.4,0.3,0.9);
      } else if(uMode<1.5){
        ringCol=vec3(0.6,0.8,1.0); edgeCol=vec3(0.4,0.6,1.0); ergoCol=vec3(0.3,0.3,1.0);
      } else {
        ringCol=vec3(1.0,0.5,0.2); edgeCol=vec3(1.0,0.4,0.1); ergoCol=vec3(0.6,0.2,0.5);
      }
      vec3 col=ringCol*ringGlow+edgeCol*shadowEdge+ergoCol*ergoGlow;

      gl_FragColor=vec4(col,1.0);
    }
  `
});
const bgScene=new THREE.Scene();
bgScene.add(new THREE.Mesh(fsGeo.clone(),bgMat));

// ============================================================
// PASS 2: PARTICLE SCENE (from V7)
// ============================================================
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(55,window.innerWidth/window.innerHeight,0.1,1000);

// Event horizon — opaque black void (scalable for Kerr)
const voidSphere = new THREE.Mesh(
  new THREE.SphereGeometry(1.0,96,96),
  new THREE.ShaderMaterial({
    vertexShader:`void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);}`,
    depthWrite:true,depthTest:true,side:THREE.FrontSide
  })
);
voidSphere.scale.setScalar(rPlus);
scene.add(voidSphere);

// Ergosphere — translucent shell showing frame-dragging region
// Oblate: radius = 1.0 at equator, rPlus at poles
const ergoGeo = new THREE.SphereGeometry(1.0, 64, 64);
const ergoMat = new THREE.ShaderMaterial({
  uniforms: { uRPlus: { value: rPlus }, uSpinA: { value: spinA }, uTime: { value: 0 } },
  vertexShader: `
    varying vec3 vPos; varying vec3 vNorm;
    uniform float uRPlus, uSpinA;
    void main() {
      // Scale: equator stays at 1.0, poles shrink to rPlus
      vec3 p = position;
      float cosT = abs(p.y); // |cos(theta)|
      float rErgo = 0.5 * (1.0 + sqrt(max(0.0, 1.0 - uSpinA*uSpinA*cosT*cosT)));
      p *= rErgo;
      vPos = p;
      vNorm = normalMatrix * normal;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
    }`,
  fragmentShader: `
    varying vec3 vPos; varying vec3 vNorm;
    uniform float uSpinA, uTime;
    void main() {
      if(uSpinA < 0.01) discard; // No ergosphere for Schwarzschild
      float rim = 1.0 - abs(dot(normalize(vNorm), normalize(-vPos)));
      float equator = 1.0 - abs(vPos.y) / length(vPos);
      float pulse = 0.85 + 0.15 * sin(uTime * 0.5);
      // Much stronger alpha: clearly visible at moderate spin
      float alpha = rim * equator * uSpinA * 0.35 * pulse;
      alpha += rim * rim * rim * uSpinA * 0.15; // extra rim glow
      if(alpha < 0.003) discard;
      vec3 col = mix(vec3(0.25, 0.15, 0.7), vec3(0.6, 0.4, 1.0), rim);
      // Add spinning streaks to show frame-dragging rotation
      float streakAngle = atan(vPos.z, vPos.x);
      float streak = pow(abs(sin(streakAngle * 4.0 + uTime * uSpinA * 2.0)), 8.0);
      col += vec3(0.2, 0.1, 0.4) * streak * uSpinA;
      gl_FragColor = vec4(col, alpha);
    }`,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.FrontSide
});
const ergoMesh = new THREE.Mesh(ergoGeo, ergoMat);
scene.add(ergoMesh);

// Particle starfield — in separate scene for gravitational lensing
const starTex=genSprite(32,8.0,2.0);
const starScene=new THREE.Scene();
const starsMat=(function(){
  const N=25000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=60+Math.random()*250,th=Math.random()*Math.PI*2,ph=Math.acos(2*Math.random()-1);
    pos[i*3]=r*Math.sin(ph)*Math.cos(th);pos[i*3+1]=r*Math.sin(ph)*Math.sin(th);pos[i*3+2]=r*Math.cos(ph);
    const t=Math.random(),c=t>0.85?[.7,.8,1]:(t>.5?[1,.97,.92]:(t>.2?[1,.88,.7]:[1,.65,.45]));
    col[i*3]=c[0];col[i*3+1]=c[1];col[i*3+2]=c[2];
    siz[i]=0.4+Math.pow(Math.random(),3)*5.0;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:starTex},uMode:{value:0}},
    vertexShader:`attribute float size;varying vec3 vC;varying float vS;uniform float uTime;
      void main(){vC=color;vS=size;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(200.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;varying float vS;uniform float uTime,uMode;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a;
        float tw=0.9+0.1*sin(uTime*0.4+vS*23.0);
        vec3 c=vC*tw*1.5;
        if(uMode>0.5&&uMode<1.5){
          float lum=dot(c,vec3(0.33));
          c=vec3(0.7,0.85,1.0)*lum;
        } else if(uMode>1.5){
          float lum=dot(c,vec3(0.33));
          c=vec3(lum*0.3,lum*0.15,lum*0.05);
        }
        gl_FragColor=vec4(c*a,a*tw);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  starScene.add(new THREE.Points(geo,mat));
  return mat;
})();

// Accretion disk — 90k noise-density particles
const DISK_N=90000;
const disk={radii:new Float32Array(DISK_N),angles:new Float32Array(DISK_N),
  velocities:new Float32Array(DISK_N),baseColors:null,baseSizes:null,posAttr:null,colAttr:null,sizAttr:null,mat:null};

(function(){
  const N=DISK_N;
  const pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  let placed=0;
  while(placed<N){
    const r=1.02+Math.pow(Math.random(),0.45)*6.2;
    const angle=Math.random()*Math.PI*2;
    const nx=Math.cos(angle)*r,nz=Math.sin(angle)*r;
    const density=0.42+fbm(nx*0.3,nz*0.3,3)*0.28+fbm(nx*0.8+100,nz*0.8+100,2)*0.18+fbm(nx*2+200,nz*2+200,2)*0.1;
    if(Math.random()>density) continue;
    const i=placed;
    const tNorm=(r-1.02)/6.2;
    const thickness=0.008+tNorm*0.065;
    pos[i*3]=nx;pos[i*3+1]=(Math.random()-0.5)*thickness;pos[i*3+2]=nz;
    disk.radii[i]=r;disk.angles[i]=angle;
    disk.velocities[i]=1.0/Math.pow(r,1.5);
    const cn=(Math.random()-0.5)*0.03;
    let cr,cg,cb;
    if(tNorm<0.03){cr=1.0+cn;cg=0.95+cn;cb=0.82;}
    else if(tNorm<0.08){const b=(tNorm-0.03)/0.05;cr=1.0+cn;cg=0.95-b*0.05+cn;cb=0.82-b*0.25;}
    else if(tNorm<0.18){const b=(tNorm-0.08)/0.1;cr=1.0+cn;cg=0.9-b*0.08+cn;cb=0.55-b*0.2;}
    else if(tNorm<0.35){const b=(tNorm-0.18)/0.17;cr=1.0+cn;cg=0.8-b*0.15+cn*0.5;cb=0.32-b*0.15;}
    else if(tNorm<0.55){const b=(tNorm-0.35)/0.2;cr=1.0-b*0.05+cn;cg=0.6-b*0.2+cn*0.3;cb=0.15-b*0.07;}
    else if(tNorm<0.78){const b=(tNorm-0.55)/0.23;cr=0.92-b*0.14+cn;cg=0.35-b*0.15+cn*0.2;cb=0.07-b*0.03;}
    else{const b=(tNorm-0.78)/0.22;cr=0.7-b*0.28+cn;cg=0.15-b*0.08;cb=0.03;}
    const bn=0.88+(fbm(nx*0.3,nz*0.3,3)-0.5)*0.16+(fbm(nx*0.8+100,nz*0.8+100,2)-0.5)*0.06;
    cr*=bn;cg*=bn;cb*=bn;
    col[i*3]=Math.max(0,Math.min(1,cr));col[i*3+1]=Math.max(0,Math.min(1,cg));col[i*3+2]=Math.max(0,Math.min(1,cb));
    siz[i]=(0.22+Math.random()*0.8)*(1.0-tNorm*0.2);
    placed++;
  }
  disk.baseColors=new Float32Array(col);
  disk.baseSizes=new Float32Array(siz);
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  disk.mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:diskTex},uMode:{value:0},uISCO:{value:isco.prograde}},
    vertexShader:`
      attribute float size;varying vec3 vC;varying float vR;
      uniform float uTime,uPulse;
      void main(){
        vC=color*(1.0+uPulse*0.35);
        vR=length(position.xz);
        vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(100.0/-mv.z)*(1.0+uPulse*0.2);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`
      varying vec3 vC;varying float vR;uniform sampler2D uTex;uniform float uMode,uISCO;
      void main(){
        float a=texture2D(uTex,gl_PointCoord).a*0.7;
        if(a<0.01)discard;
        float ib=1.0+smoothstep(uISCO*1.5,uISCO,vR)*1.0;
        vec3 c=vC*ib;
        if(uMode>0.5&&uMode<1.5){
          // X-RAY: remap to blue-white-purple
          float lum=dot(c,vec3(0.3,0.5,0.2));
          float hot=smoothstep(0.0,1.5,lum);
          vec3 xc=mix(vec3(0.1,0.0,0.3),vec3(0.3,0.5,1.0),hot);
          xc=mix(xc,vec3(0.9,0.95,1.0),hot*hot);
          c=xc*lum*2.0;
        } else if(uMode>1.5){
          // RADIO: remap to red-yellow synchrotron
          float lum=dot(c,vec3(0.3,0.5,0.2));
          float hot=smoothstep(0.0,1.2,lum);
          vec3 rc=mix(vec3(0.3,0.0,0.0),vec3(1.0,0.3,0.0),hot);
          rc=mix(rc,vec3(1.0,1.0,0.2),hot*hot*0.6);
          c=rc*lum*1.5;
        }
        gl_FragColor=vec4(c,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  disk.posAttr=geo.attributes.position;
  disk.colAttr=geo.attributes.color;
  disk.sizAttr=geo.attributes.size;
  const points=new THREE.Points(geo,disk.mat);
  points.rotation.x=0.08;points.rotation.z=0.05;
  scene.add(points);
})();

// Jets
function createJet(dir){
  const N=5000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const t=Math.pow(Math.random(),0.6);
    const h=t*14*dir,spread=t*t*0.45;
    const a=Math.random()*Math.PI*2,r=Math.random()*spread;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=h;pos[i*3+2]=Math.sin(a)*r;
    const b=1.0-t*0.85;
    col[i*3]=(0.4+t*0.15)*b;col[i*3+1]=(0.55+t*0.05)*b;col[i*3+2]=1.0*b;
    siz[i]=(1.0-t*0.6)*1.2;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:jetTex},uMode:{value:0}},
    vertexShader:`attribute float size;varying vec3 vC;uniform float uTime,uPulse;
      void main(){vC=color*(1.0+uPulse*0.3);
        vec3 p=position;float h=abs(p.y);
        p.x+=sin(uTime*2.5+h*1.2)*0.03*h*0.07;
        p.z+=cos(uTime*2.5+h*1.2)*0.03*h*0.07;
        vec4 mv=modelViewMatrix*vec4(p,1.0);
        gl_PointSize=size*(65.0/-mv.z)*(1.0+uPulse*0.4);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;uniform float uMode;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.35;
        if(a<0.01)discard;
        vec3 c=vC;
        if(uMode>0.5&&uMode<1.5){
          // X-RAY: jets are bright in X-ray — hot blue-white
          float lum=dot(c,vec3(0.3,0.4,0.3));
          c=vec3(0.5,0.7,1.0)*lum*3.0;
          a*=1.5;
        } else if(uMode>1.5){
          // RADIO: jets are VERY bright — synchrotron emission
          float lum=dot(c,vec3(0.3,0.4,0.3));
          c=vec3(1.0,0.6,0.1)*lum*4.0;
          a*=2.5;
        }
        gl_FragColor=vec4(c,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  return{points:new THREE.Points(geo,mat),mat};
}
const jetUp=createJet(1),jetDown=createJet(-1);
scene.add(jetUp.points);scene.add(jetDown.points);

// Dust halo
const dustMat=(function(){
  const N=4000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=5+Math.random()*14,a=Math.random()*Math.PI*2,y=(Math.random()-0.5)*2;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=y;pos[i*3+2]=Math.sin(a)*r;
    col[i*3]=0.3;col[i*3+1]=0.15;col[i*3+2]=0.05;
    siz[i]=0.3+Math.random()*0.7;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:diskTex}},
    vertexShader:`attribute float size;varying vec3 vC;
      void main(){vC=color;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(55.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.1;
        if(a<0.01)discard;gl_FragColor=vec4(vC,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  scene.add(new THREE.Points(geo,mat));return mat;
})();

// ============================================================
// MATTER INFALL — particles spiraling into the void with trails
// Each "clump" is a trail of points that spiral inward, accelerate,
// brighten, and vanish at the event horizon, then respawn
// ============================================================
const INFALL_CLUMPS = 12;
const TRAIL_LEN = 40;
const INFALL_N = INFALL_CLUMPS * TRAIL_LEN;
const infall = { clumps: [], posAttr: null, colAttr: null, sizAttr: null, mat: null };

(function(){
  const pos = new Float32Array(INFALL_N * 3);
  const col = new Float32Array(INFALL_N * 3);
  const siz = new Float32Array(INFALL_N);

  // Initialize clumps
  for (let c = 0; c < INFALL_CLUMPS; c++) {
    infall.clumps.push({
      r: 3.0 + Math.random() * 4.0,        // start radius
      angle: Math.random() * Math.PI * 2,    // current angle
      phase: Math.random() * Math.PI * 2,    // y-wobble phase
      speed: 0.15 + Math.random() * 0.1,     // angular speed multiplier
      drift: 0.003 + Math.random() * 0.004,  // inward drift rate
      brightness: 0.5 + Math.random() * 0.5,
      trail: []  // store past positions
    });
    // Pre-fill trail
    const clump = infall.clumps[c];
    for (let t = 0; t < TRAIL_LEN; t++) {
      clump.trail.push({ x: 0, y: 0, z: 0 });
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));

  const glowTex = genSprite(64, 3.0, 0.8);
  infall.mat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPulse: { value: 0 }, uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC; varying float vA;
      uniform float uPulse;
      void main() {
        vC = color;
        vA = color.r + color.g + color.b;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (90.0 / -mv.z) * (1.0 + uPulse * 0.3);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; varying float vA; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a * 0.8;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(0.6,0.8,1.0) * lum * 2.5;
        } else if(uMode > 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(1.0,0.5,0.1) * lum * 2.0;
        }
        gl_FragColor = vec4(c, a);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });

  infall.posAttr = geo.attributes.position;
  infall.colAttr = geo.attributes.color;
  infall.sizAttr = geo.attributes.size;

  const points = new THREE.Points(geo, infall.mat);
  points.rotation.x = 0.08; points.rotation.z = 0.05;
  scene.add(points);
})();

function updateInfall(time) {
  const pa = infall.posAttr, ca = infall.colAttr, sa = infall.sizAttr;

  for (let c = 0; c < INFALL_CLUMPS; c++) {
    const cl = infall.clumps[c];

    // Keplerian angular velocity + acceleration as it spirals in
    const omega = cl.speed / Math.pow(cl.r, 1.5);
    cl.angle += omega * 0.015;

    // Inward spiral — accelerates as it gets closer
    const driftAccel = 1.0 + Math.pow(3.0 / Math.max(cl.r, 1.1), 2.0) * 2.0;
    cl.r -= cl.drift * driftAccel * 0.015;

    // Small y wobble
    const y = Math.sin(cl.phase + time * 0.5) * 0.015 * cl.r * 0.3;

    // Current head position
    const hx = Math.cos(cl.angle) * cl.r;
    const hz = Math.sin(cl.angle) * cl.r;

    // Push new position to trail front, shift old ones back
    for (let t = TRAIL_LEN - 1; t > 0; t--) {
      cl.trail[t].x = cl.trail[t-1].x;
      cl.trail[t].y = cl.trail[t-1].y;
      cl.trail[t].z = cl.trail[t-1].z;
    }
    cl.trail[0].x = hx;
    cl.trail[0].y = y;
    cl.trail[0].z = hz;

    // Respawn when it reaches the void
    if (cl.r < 1.05) {
      cl.r = 4.0 + Math.random() * 3.5;
      cl.angle = Math.random() * Math.PI * 2;
      cl.drift = 0.003 + Math.random() * 0.004;
      cl.speed = 0.15 + Math.random() * 0.1;
      cl.brightness = 0.5 + Math.random() * 0.5;
      // Reset trail to new position to avoid streaks across screen
      const nx = Math.cos(cl.angle) * cl.r;
      const nz = Math.sin(cl.angle) * cl.r;
      for (let t = 0; t < TRAIL_LEN; t++) {
        cl.trail[t].x = nx; cl.trail[t].y = 0; cl.trail[t].z = nz;
      }
    }

    // Write trail to buffers
    for (let t = 0; t < TRAIL_LEN; t++) {
      const idx = c * TRAIL_LEN + t;
      const trailFade = 1.0 - t / TRAIL_LEN; // 1.0 at head, 0.0 at tail

      pa.array[idx*3]   = cl.trail[t].x;
      pa.array[idx*3+1] = cl.trail[t].y;
      pa.array[idx*3+2] = cl.trail[t].z;

      // Color: gets hotter (whiter) as radius decreases
      const rNorm = Math.max(0, Math.min(1, (cl.r - 1.0) / 6.0));
      const heat = 1.0 - rNorm; // 1.0 = at void, 0.0 = outer edge

      // Trail head: bright hot color. Tail: fades to disk color
      const headR = 1.0;
      const headG = 0.7 + heat * 0.25;
      const headB = 0.3 + heat * 0.6;

      const intensity = trailFade * trailFade * cl.brightness * (0.8 + heat * 1.5);
      ca.array[idx*3]   = headR * intensity;
      ca.array[idx*3+1] = headG * intensity;
      ca.array[idx*3+2] = headB * intensity;

      // Size: head is bigger, tail tapers
      sa.array[idx] = (0.3 + heat * 0.6) * trailFade * cl.brightness;
    }
  }

  pa.needsUpdate = true;
  ca.needsUpdate = true;
  sa.needsUpdate = true;
}

// ============================================================
// TIDAL DISRUPTION EVENT — click to spawn a star that gets shredded
// Star approaches on parabolic orbit, spaghettifies at tidal radius,
// debris streams around the black hole
// ============================================================
const TDE_N = 2500;
const tde = {
  active: false,
  phase: 0, // 0=inactive, 1=approaching, 2=disrupting, 3=streaming, 4=fading
  timer: 0,
  starPos: new THREE.Vector3(15, 2, 0),
  starVel: new THREE.Vector3(-0.5, -0.1, 0.3),
  particles: [],
  posAttr: null, colAttr: null, sizAttr: null, mat: null
};

(function(){
  const pos = new Float32Array(TDE_N * 3);
  const col = new Float32Array(TDE_N * 3);
  const siz = new Float32Array(TDE_N);

  for (let i = 0; i < TDE_N; i++) {
    tde.particles.push({
      x: 0, y: 0, z: 0,
      vx: 0, vy: 0, vz: 0,
      alive: false,
      life: 0,
      maxLife: 0,
      brightness: 0
    });
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));

  const glowTex = genSprite(64, 3.5, 1.0);
  tde.mat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPulse: { value: 0 }, uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC;
      uniform float uPulse;
      void main() {
        vC = color * (1.0 + uPulse * 0.4);
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (120.0 / -mv.z);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = mix(vec3(0.2,0.3,0.8), vec3(0.8,0.9,1.0), min(1.0, lum)) * lum * 2.0;
        } else if(uMode > 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = mix(vec3(0.5,0.1,0.0), vec3(1.0,0.8,0.2), min(1.0, lum)) * lum * 1.5;
        }
        gl_FragColor = vec4(c, a * 0.9);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });

  tde.posAttr = geo.attributes.position;
  tde.colAttr = geo.attributes.color;
  tde.sizAttr = geo.attributes.size;

  const points = new THREE.Points(geo, tde.mat);
  scene.add(points);
})();

function spawnTDE() {
  // Always allow re-triggering — just reset
  tde.active = true;
  tde.phase = 1;
  tde.timer = 0;

  // Random approach direction — always comes from outside
  const angle = Math.random() * Math.PI * 2;
  const elev = (Math.random() - 0.5) * 0.5;
  const dist = 14 + Math.random() * 4;
  tde.starPos.set(
    Math.cos(angle) * dist,
    elev * dist * 0.2,
    Math.sin(angle) * dist
  );

  // Velocity: strong angular momentum so debris ORBITS rather than plunging straight in
  const toCenter = new THREE.Vector3().sub(tde.starPos).normalize();
  const tangent = new THREE.Vector3(-toCenter.z, 0, toCenter.x);
  const speed = 0.055 + Math.random() * 0.015;
  tde.starVel.copy(toCenter).multiplyScalar(speed * 0.5);
  tde.starVel.addScaledVector(tangent, speed * 0.8); // more tangential = more orbit

  // Reset all particles — clump them at star position
  for (let i = 0; i < TDE_N; i++) {
    const p = tde.particles[i];
    // Tight Gaussian cluster for star shape
    const gr = () => (Math.random() + Math.random() + Math.random() - 1.5) * 0.12;
    p.x = tde.starPos.x + gr();
    p.y = tde.starPos.y + gr();
    p.z = tde.starPos.z + gr();
    p.vx = tde.starVel.x;
    p.vy = tde.starVel.y;
    p.vz = tde.starVel.z;
    p.alive = true;
    p.life = 0;
    p.maxLife = 800 + Math.random() * 600;
    p.brightness = 0.6 + Math.random() * 0.4;
  }

  // Play disruption sound
  if (audioCtx && masterGain) {
    const now = audioCtx.currentTime;
    // Rising pitch — approaching star
    const rise = audioCtx.createOscillator();
    rise.type = 'sine';
    rise.frequency.setValueAtTime(60, now);
    rise.frequency.exponentialRampToValueAtTime(300, now + 3);
    rise.frequency.exponentialRampToValueAtTime(40, now + 5);
    const riseGain = audioCtx.createGain();
    riseGain.gain.setValueAtTime(0.0, now);
    riseGain.gain.linearRampToValueAtTime(0.15, now + 1);
    riseGain.gain.linearRampToValueAtTime(0.25, now + 3);
    riseGain.gain.exponentialRampToValueAtTime(0.001, now + 6);
    rise.connect(riseGain);
    riseGain.connect(masterGain);
    rise.start(now);
    rise.stop(now + 6);

    // Tear sound — noise burst at disruption moment
    setTimeout(() => {
      if (!audioCtx) return;
      const now2 = audioCtx.currentTime;
      const tearBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
      const td = tearBuf.getChannelData(0);
      for (let i = 0; i < td.length; i++) td[i] = (Math.random() * 2 - 1);
      const tear = audioCtx.createBufferSource();
      tear.buffer = tearBuf;
      const tearFilter = audioCtx.createBiquadFilter();
      tearFilter.type = 'bandpass';
      tearFilter.frequency.value = 200;
      tearFilter.Q.value = 1;
      const tearGain = audioCtx.createGain();
      tearGain.gain.setValueAtTime(0.2, now2);
      tearGain.gain.exponentialRampToValueAtTime(0.001, now2 + 2);
      tear.connect(tearFilter);
      tearFilter.connect(tearGain);
      tearGain.connect(masterGain);
      tear.start(now2);
    }, 2500);
  }
}

function updateTDE(dt) {
  if (!tde.active) return;
  tde.timer += dt;

  const pa = tde.posAttr, ca = tde.colAttr, sa = tde.sizAttr;
  const RS = 1.0;
  const tidalRadius = 2.8; // where spaghettification begins
  let anyAlive = false;

  for (let i = 0; i < TDE_N; i++) {
    const p = tde.particles[i];
    if (!p.alive) {
      pa.array[i*3] = pa.array[i*3+1] = pa.array[i*3+2] = 0;
      ca.array[i*3] = ca.array[i*3+1] = ca.array[i*3+2] = 0;
      sa.array[i] = 0;
      continue;
    }

    p.life++;
    anyAlive = true;

    // Distance to BH
    const r = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);

    // Gravitational acceleration — tuned so debris orbits visibly before falling in
    const gStrength = 0.25 / (r * r);
    const ax = -p.x / r * gStrength;
    const ay = -p.y / r * gStrength;
    const az = -p.z / r * gStrength;

    // Tidal force: differential gravity stretches the star into a stream
    // Stronger effect for more dramatic spaghettification
    if (r < tidalRadius && r > RS * 0.8) {
      const tidalStrength = 0.0008 * Math.pow(tidalRadius / r, 3.5);
      const rx = p.x / r, ry = p.y / r, rz = p.z / r;
      // Stretch along radial direction
      p.vx += rx * tidalStrength * (1.0 + (Math.random() - 0.5) * 0.6);
      p.vy += ry * tidalStrength * (Math.random() - 0.5) * 0.4;
      p.vz += rz * tidalStrength * (1.0 + (Math.random() - 0.5) * 0.6);
      // Small perpendicular compression — squeeze into thin stream
      const px = p.y * rz - p.z * ry;
      const py = p.z * rx - p.x * rz;
      const pz = p.x * ry - p.y * rx;
      const pl = Math.sqrt(px*px + py*py + pz*pz) + 0.001;
      p.vx -= px / pl * tidalStrength * 0.15;
      p.vy -= py / pl * tidalStrength * 0.15;
      p.vz -= pz / pl * tidalStrength * 0.15;
    }

    // Light drag at very large radii to keep debris from escaping entirely
    if (r > 12) {
      const drag = 0.998;
      p.vx *= drag; p.vy *= drag; p.vz *= drag;
    }

    p.vx += ax;
    p.vy += ay;
    p.vz += az;

    p.x += p.vx;
    p.y += p.vy;
    p.z += p.vz;

    // Absorbed by black hole — only at very center
    if (r < RS * 0.5) {
      p.alive = false;
      continue;
    }

    // Fade over lifetime
    if (p.life > p.maxLife) {
      p.alive = false;
      continue;
    }

    // Color: starts white-blue (hot star), shifts to orange-red as debris
    const lifeFrac = p.life / p.maxLife;
    const fade = 1.0 - lifeFrac * lifeFrac;
    const proximity = Math.max(0, 1.0 - (r - 1.0) / 5.0); // brighter when close

    let cr, cg, cb;
    if (lifeFrac < 0.12) {
      // Intact star: bright white-blue
      cr = 0.95; cg = 0.95; cb = 1.0;
    } else if (lifeFrac < 0.35) {
      // Disruption: hot yellow-white, very bright
      const t = (lifeFrac - 0.12) / 0.23;
      cr = 1.0; cg = 0.95 - t * 0.2; cb = 0.9 - t * 0.45;
    } else {
      // Streaming debris: cools to orange-red
      const t = (lifeFrac - 0.35) / 0.65;
      cr = 1.0 - t * 0.2; cg = 0.75 - t * 0.4; cb = 0.45 - t * 0.35;
    }

    // Boost brightness when close to BH (heating from compression)
    const heatBoost = 1.0 + proximity * 0.8;
    const intensity = p.brightness * fade * heatBoost;
    pa.array[i*3]   = p.x;
    pa.array[i*3+1] = p.y;
    pa.array[i*3+2] = p.z;
    ca.array[i*3]   = cr * intensity;
    ca.array[i*3+1] = cg * intensity;
    ca.array[i*3+2] = cb * intensity;

    // Size: compact when star, larger as debris, extra large near BH
    const sizeBase = lifeFrac < 0.12 ? 0.2 : (0.2 + lifeFrac * 0.35 + proximity * 0.2);
    sa.array[i] = sizeBase * p.brightness * fade;
  }

  pa.needsUpdate = true;
  ca.needsUpdate = true;
  sa.needsUpdate = true;

  // Deactivate when all particles dead
  if (!anyAlive) {
    tde.active = false;
    tde.phase = 0;
  }
}

// ============================================================
// COMPOSITE + BLOOM SHADERS
// ============================================================

// Gravitational lensing distortion for starfield
const lensMat=new THREE.ShaderMaterial({
  uniforms:{
    tStars:{value:null},
    uBHScreen:{value:new THREE.Vector2(0.5,0.5)}, // BH center in screen UV
    uBHRadius:{value:0.1}, // apparent angular radius of shadow in screen units
    uStrength:{value:1.5}
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform sampler2D tStars;
    uniform vec2 uBHScreen;
    uniform float uBHRadius, uStrength;
    varying vec2 vUv;

    void main(){
      vec2 delta = vUv - uBHScreen;
      float dist = length(delta);
      vec2 dir = delta / max(dist, 0.0001);

      // Schwarzschild-inspired deflection: α ∝ 1/b (impact parameter)
      // Stronger bending close to the photon sphere (1.5x shadow radius)
      float photonR = uBHRadius * 1.5;

      // Einstein ring radius in screen space
      float einsteinR = uBHRadius * 1.73; // √3 × shadow for Schwarzschild

      if(dist < uBHRadius * 0.85){
        // Inside shadow — black, no stars visible
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
      }

      // Deflection magnitude — inverse distance law with smooth falloff
      float deflection = uStrength * uBHRadius * uBHRadius / (dist * dist + uBHRadius * 0.1);

      // Near photon sphere: amplification (Einstein ring brightening)
      float photonProx = exp(-pow(dist - photonR, 2.0) / (uBHRadius * uBHRadius * 0.15));
      deflection += photonProx * uBHRadius * 0.3;

      // Deflection pushes the sampling point OUTWARD (light bends inward)
      vec2 lensedUV = vUv + dir * deflection;

      // Clamp to valid UV range
      lensedUV = clamp(lensedUV, 0.0, 1.0);

      vec3 col = texture2D(tStars, lensedUV).rgb;

      // Einstein ring amplification — stars near photon sphere appear brighter
      float amp = 1.0 + photonProx * 3.0;
      col *= amp;

      gl_FragColor = vec4(col, 1.0);
    }
  `
});

// Combine BG + particles
const combineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec4 fg=texture2D(tParticles,vUv);
      // Particles use additive blending on black, so just add them to background
      // But where the void sphere rendered black, suppress the background too
      // Detect void: if particle pass is pure black AND we expect the void there
      float fgBright=dot(fg.rgb,vec3(1.0));
      // Use a mask: areas that rendered to exactly 0 might be void or empty space
      // We differentiate by checking if depth would have been written (void sphere)
      // Simple approach: if fg is very dark, show bg; if fg has content, add it
      vec3 col=bg+fg.rgb;
      gl_FragColor=vec4(col,1.0);
    }`
});

// But we need the void sphere to BLOCK the background stars behind it.
// Problem: with additive particle blending, the void renders as black (adds nothing).
// Solution: render the void sphere separately to a mask, or use a different approach.

// Better approach: render void sphere to write a mask in alpha channel
// Actually, simplest: render the particle scene with the void sphere writing alpha=1 black,
// then composite properly.

// Let me use a two-step approach for the particle scene:
// The void sphere renders with depthWrite=true and outputs black.
// Particles render on top with additive blending.
// If we render particles to a texture, void areas = black, space areas = black, particle areas = bright.
// We can't distinguish void from empty space...

// SOLUTION: Render a void-only pass to get a silhouette mask.
const voidMaskMat=new THREE.ShaderMaterial({
  uniforms:{uCamPos:{value:new THREE.Vector3()},uRes:{value:new THREE.Vector2()},uFov:{value:FOV_MULT},uRPlus:{value:rPlus}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform vec3 uCamPos;uniform vec2 uRes;uniform float uFov,uRPlus;varying vec2 vUv;
    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}
    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));
      // Ray-sphere intersection for void (r=rPlus)
      vec3 oc=uCamPos;
      float b2=dot(oc,rd);
      float c=dot(oc,oc)-uRPlus*uRPlus;
      float disc=b2*b2-c;
      float mask=disc>0.0?1.0:0.0;
      gl_FragColor=vec4(vec3(mask),1.0);
    }`
});

// Final combine: (lensedStars + BG glow) * (1-voidMask) + particles
const finalCombineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null},tMask:{value:null},tStarsLensed:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles,tMask,tStarsLensed;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec3 stars=texture2D(tStarsLensed,vUv).rgb;
      vec3 fg=texture2D(tParticles,vUv).rgb;
      float mask=texture2D(tMask,vUv).r;
      // Behind void: suppress background and stars. Elsewhere: show everything
      vec3 col=(stars+bg)*(1.0-mask)+fg;
      gl_FragColor=vec4(col,1.0);
    }`
});

// Bloom threshold
const threshMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uThreshold:{value:0.28}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform float uThreshold;varying vec2 vUv;
    void main(){vec4 c=texture2D(tDiffuse,vUv);float b=dot(c.rgb,vec3(0.2126,0.7152,0.0722));
      gl_FragColor=b>uThreshold?c*smoothstep(uThreshold,uThreshold+0.4,b):vec4(0.0);}`
});
function mkBlur(h){return new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.5,window.innerHeight*0.5)},
    uDir:{value:h?new THREE.Vector2(1,0):new THREE.Vector2(0,1)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes,uDir;varying vec2 vUv;
    void main(){vec2 tx=uDir/uRes;vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv-tx*4.0)*0.0162;r+=texture2D(tDiffuse,vUv-tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv-tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv-tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv)*0.2270;r+=texture2D(tDiffuse,vUv+tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv+tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv+tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv+tx*4.0)*0.0162;gl_FragColor=r;}`});}
const blurH=mkBlur(true),blurV=mkBlur(false);

// Anamorphic streak — ultra-wide horizontal blur (13-tap, very spread)
const streakBlurMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.25,window.innerHeight*0.25)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes;varying vec2 vUv;
    void main(){
      float tx=1.0/uRes.x*3.0; // 3x spread for very wide streaks
      vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv+vec2(-6.0*tx,0))*0.012;
      r+=texture2D(tDiffuse,vUv+vec2(-5.0*tx,0))*0.025;
      r+=texture2D(tDiffuse,vUv+vec2(-4.0*tx,0))*0.045;
      r+=texture2D(tDiffuse,vUv+vec2(-3.0*tx,0))*0.075;
      r+=texture2D(tDiffuse,vUv+vec2(-2.0*tx,0))*0.105;
      r+=texture2D(tDiffuse,vUv+vec2(-1.0*tx,0))*0.135;
      r+=texture2D(tDiffuse,vUv)*0.155;
      r+=texture2D(tDiffuse,vUv+vec2(1.0*tx,0))*0.135;
      r+=texture2D(tDiffuse,vUv+vec2(2.0*tx,0))*0.105;
      r+=texture2D(tDiffuse,vUv+vec2(3.0*tx,0))*0.075;
      r+=texture2D(tDiffuse,vUv+vec2(4.0*tx,0))*0.045;
      r+=texture2D(tDiffuse,vUv+vec2(5.0*tx,0))*0.025;
      r+=texture2D(tDiffuse,vUv+vec2(6.0*tx,0))*0.012;
      // Slightly warm tint for cinematic look
      r.rgb*=vec3(1.0,0.95,0.85);
      gl_FragColor=r;
    }`
});

// Final output with bloom
const compositeMat=new THREE.ShaderMaterial({
  uniforms:{tScene:{value:null},tBloom:{value:null},tStreak:{value:null},uBloomStr:{value:1.5},uTime:{value:0},uMode:{value:0}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tScene,tBloom,tStreak;uniform float uBloomStr,uTime,uMode;varying vec2 vUv;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec3 sc=texture2D(tScene,vUv).rgb,bl=texture2D(tBloom,vUv).rgb;
      vec3 streak=texture2D(tStreak,vUv).rgb;
      vec3 col=sc+bl*uBloomStr+streak*0.6;
      float d=length(vUv-0.5),ca=d*d*0.004;
      col.r+=texture2D(tBloom,vUv+vec2(ca)).r*uBloomStr*0.18;
      col.b+=texture2D(tBloom,vUv-vec2(ca)).b*uBloomStr*0.18;
      // Mode-dependent overall tint
      if(uMode>0.5&&uMode<1.5){
        // X-RAY: cool blue tint, higher contrast
        col=col*vec3(0.7,0.85,1.2);
        col=pow(col,vec3(1.1)); // slightly more contrast
      } else if(uMode>1.5){
        // RADIO: warm tint, false color feel
        col=col*vec3(1.1,0.9,0.7);
      }
      col*=1.0-d*0.6;
      col+=(hash(vUv*800.0+fract(uTime))-0.5)*0.02;
      gl_FragColor=vec4(col,1.0);}`
});

// Fullscreen quad + scene for post-processing
const postScene=new THREE.Scene();
const postQuad=new THREE.Mesh(fsGeo.clone(),compositeMat);
postScene.add(postQuad);

let rtMask=makeRT(1);

// ============================================================
// CAMERA
// ============================================================
let isDragging=false,prevMouse={x:0,y:0};
let sph={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let tgt={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let pulse=0;

function pD(x,y){if(document.getElementById('infopanel').classList.contains('open'))return;isDragging=true;prevMouse={x,y};}
function pM(x,y){if(!isDragging)return;
  tgt.theta-=(x-prevMouse.x)*0.004;
  tgt.phi=Math.max(0.2,Math.min(Math.PI-0.2,tgt.phi-(y-prevMouse.y)*0.004));
  prevMouse={x,y};}
function pU(){isDragging=false;}
document.addEventListener('mousedown',e=>pD(e.clientX,e.clientY));
document.addEventListener('mousemove',e=>pM(e.clientX,e.clientY));
document.addEventListener('mouseup',pU);
document.addEventListener('touchstart',e=>{e.preventDefault();pD(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchmove',e=>{e.preventDefault();pM(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchend',pU);
document.addEventListener('wheel',e=>{
  if(document.getElementById('infopanel').classList.contains('open')) return;
  if(e.target.id==='spinslider') return;
  tgt.radius=Math.max(2.5,Math.min(25,tgt.radius+e.deltaY*0.008));
},{passive:true});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'){e.preventDefault();pulse=1.0;triggerPulseSound();}
  if(e.key==='1') setWaveMode(0);
  if(e.key==='2') setWaveMode(1);
  if(e.key==='3') setWaveMode(2);
  if(e.key==='i'||e.key==='I') toggleInfo();
  if(e.key==='t'||e.key==='T') spawnTDE();
});

document.addEventListener('dblclick',e=>{
  if(document.getElementById('infopanel').classList.contains('open')) return;
  spawnTDE();
});

function toggleInfo(){
  const panel=document.getElementById('infopanel');
  const btn=document.getElementById('infobtn');
  panel.classList.toggle('open');
  btn.classList.toggle('active');
}

// Click outside info panel to close
document.addEventListener('mousedown',e=>{
  const panel=document.getElementById('infopanel');
  if(!panel.classList.contains('open')) return;
  // If click is outside panel and not on the info button, close
  if(!panel.contains(e.target) && e.target.id!=='infobtn'){
    toggleInfo();
  }
});

let waveMode=0;
function setWaveMode(m){
  waveMode=m;
  document.querySelectorAll('#wavemode button').forEach((btn,i)=>{
    btn.classList.toggle('active',i===m);
  });
  [disk.mat,jetUp.mat,jetDown.mat,infall.mat,tde.mat].forEach(mat=>{
    if(mat.uniforms.uMode) mat.uniforms.uMode.value=m;
  });
  compositeMat.uniforms.uMode.value=m;
  bgMat.uniforms.uMode.value=m;
  starsMat.uniforms.uMode.value=m;
}

function setSpinA(a) {
  spinA = Math.max(0, Math.min(0.998, a));
  rPlus = kerrEventHorizon(spinA);
  isco = kerrISCO(spinA);
  document.getElementById('spinval').textContent = 'a* = ' + spinA.toFixed(3);
  // Update disk inner edge uniform
  if(disk.mat && disk.mat.uniforms.uISCO) disk.mat.uniforms.uISCO.value = isco.prograde;
}

// ============================================================
// SOUND DESIGN — Web Audio API
// Deep space ambient drone, proximity rumble, pulse FX
// Initialized on first user interaction (autoplay policy)
// ============================================================
let audioCtx=null, audioInitialized=false;
let droneGain,rumbleGain,masterGain;
let droneOscs=[],rumbleOsc,rumbleLFO;

function initAudio(){
  if(audioInitialized) return;
  audioInitialized=true;

  audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  const now=audioCtx.currentTime;

  masterGain=audioCtx.createGain();
  masterGain.gain.value=0;
  masterGain.connect(audioCtx.destination);
  // Fade in over 3 seconds
  masterGain.gain.linearRampToValueAtTime(0.6, now+3);

  // === AMBIENT DRONE ===
  // Multiple detuned oscillators for rich, evolving texture
  droneGain=audioCtx.createGain();
  droneGain.gain.value=0.12;
  droneGain.connect(masterGain);

  // Low foundation — deep Bb
  const droneFreqs=[29.14, 29.14*1.002, 29.14*0.998]; // Bb0 with slight detune
  droneFreqs.forEach((freq,i)=>{
    const osc=audioCtx.createOscillator();
    osc.type='sine';
    osc.frequency.value=freq;
    const g=audioCtx.createGain();
    g.gain.value=0.35;
    osc.connect(g);
    g.connect(droneGain);
    osc.start();
    droneOscs.push({osc,gain:g});
  });

  // Mid harmonic layer — fifth above, filtered
  const midFreqs=[43.65, 43.65*1.003]; // F1
  midFreqs.forEach(freq=>{
    const osc=audioCtx.createOscillator();
    osc.type='triangle';
    osc.frequency.value=freq;
    const filter=audioCtx.createBiquadFilter();
    filter.type='lowpass';
    filter.frequency.value=120;
    filter.Q.value=2;
    const g=audioCtx.createGain();
    g.gain.value=0.2;
    osc.connect(filter);
    filter.connect(g);
    g.connect(droneGain);
    osc.start();
    droneOscs.push({osc,gain:g,filter});
  });

  // High ethereal whisper — very quiet, evolving
  const highOsc=audioCtx.createOscillator();
  highOsc.type='sine';
  highOsc.frequency.value=174.6; // F3
  const highFilter=audioCtx.createBiquadFilter();
  highFilter.type='bandpass';
  highFilter.frequency.value=175;
  highFilter.Q.value=15;
  const highGain=audioCtx.createGain();
  highGain.gain.value=0.03;
  highOsc.connect(highFilter);
  highFilter.connect(highGain);
  highGain.connect(droneGain);
  highOsc.start();
  droneOscs.push({osc:highOsc,gain:highGain,filter:highFilter});

  // LFO to modulate drone volume — slow breathing
  const droneLFO=audioCtx.createOscillator();
  droneLFO.type='sine';
  droneLFO.frequency.value=0.06; // ~16 second cycle
  const lfoGain=audioCtx.createGain();
  lfoGain.gain.value=0.03;
  droneLFO.connect(lfoGain);
  lfoGain.connect(droneGain.gain);
  droneLFO.start();

  // === PROXIMITY RUMBLE ===
  // Low freq noise that intensifies as camera approaches
  rumbleGain=audioCtx.createGain();
  rumbleGain.gain.value=0;
  rumbleGain.connect(masterGain);

  rumbleOsc=audioCtx.createOscillator();
  rumbleOsc.type='sawtooth';
  rumbleOsc.frequency.value=22;
  const rumbleFilter=audioCtx.createBiquadFilter();
  rumbleFilter.type='lowpass';
  rumbleFilter.frequency.value=60;
  rumbleFilter.Q.value=3;
  rumbleOsc.connect(rumbleFilter);
  rumbleFilter.connect(rumbleGain);
  rumbleOsc.start();

  // Rumble LFO — menacing throb
  rumbleLFO=audioCtx.createOscillator();
  rumbleLFO.type='sine';
  rumbleLFO.frequency.value=0.3;
  const rumbleLFOGain=audioCtx.createGain();
  rumbleLFOGain.gain.value=0.05;
  rumbleLFO.connect(rumbleLFOGain);
  rumbleLFOGain.connect(rumbleGain.gain);
  rumbleLFO.start();

  // === NOISE LAYER ===
  // Filtered white noise for texture — like radiation hiss
  const bufferSize=audioCtx.sampleRate*2;
  const noiseBuffer=audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
  const data=noiseBuffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i]=(Math.random()*2-1);
  const noiseNode=audioCtx.createBufferSource();
  noiseNode.buffer=noiseBuffer;
  noiseNode.loop=true;
  const noiseFilter=audioCtx.createBiquadFilter();
  noiseFilter.type='bandpass';
  noiseFilter.frequency.value=80;
  noiseFilter.Q.value=0.5;
  const noiseGain=audioCtx.createGain();
  noiseGain.gain.value=0.015;
  noiseNode.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(masterGain);
  noiseNode.start();

  // Store refs for proximity updates
  window._audioRefs={rumbleGain,rumbleFilter:rumbleFilter,noiseFilter,noiseGain,droneGain,masterGain,highGain};
}

function triggerPulseSound(){
  if(!audioCtx) return;
  const now=audioCtx.currentTime;

  // Deep impact — sub bass hit
  const impact=audioCtx.createOscillator();
  impact.type='sine';
  impact.frequency.setValueAtTime(80,now);
  impact.frequency.exponentialRampToValueAtTime(20,now+1.5);
  const impactGain=audioCtx.createGain();
  impactGain.gain.setValueAtTime(0.4,now);
  impactGain.gain.exponentialRampToValueAtTime(0.001,now+2);
  impact.connect(impactGain);
  impactGain.connect(masterGain);
  impact.start(now);
  impact.stop(now+2);

  // High shimmer — metallic ring
  const shimmer=audioCtx.createOscillator();
  shimmer.type='sine';
  shimmer.frequency.value=1200;
  const shimFilter=audioCtx.createBiquadFilter();
  shimFilter.type='bandpass';
  shimFilter.frequency.value=1200;
  shimFilter.Q.value=20;
  const shimGain=audioCtx.createGain();
  shimGain.gain.setValueAtTime(0.06,now);
  shimGain.gain.exponentialRampToValueAtTime(0.001,now+3);
  shimmer.connect(shimFilter);
  shimFilter.connect(shimGain);
  shimGain.connect(masterGain);
  shimmer.start(now);
  shimmer.stop(now+3);

  // Noise burst — whoosh
  const burstSize=audioCtx.sampleRate;
  const burstBuf=audioCtx.createBuffer(1,burstSize,audioCtx.sampleRate);
  const bd=burstBuf.getChannelData(0);
  for(let i=0;i<burstSize;i++) bd[i]=(Math.random()*2-1);
  const burst=audioCtx.createBufferSource();
  burst.buffer=burstBuf;
  const burstFilter=audioCtx.createBiquadFilter();
  burstFilter.type='lowpass';
  burstFilter.frequency.setValueAtTime(3000,now);
  burstFilter.frequency.exponentialRampToValueAtTime(100,now+1.5);
  const burstGain=audioCtx.createGain();
  burstGain.gain.setValueAtTime(0.15,now);
  burstGain.gain.exponentialRampToValueAtTime(0.001,now+1.5);
  burst.connect(burstFilter);
  burstFilter.connect(burstGain);
  burstGain.connect(masterGain);
  burst.start(now);

  // Momentary drone swell
  if(window._audioRefs){
    window._audioRefs.droneGain.gain.setValueAtTime(0.25,now);
    window._audioRefs.droneGain.gain.linearRampToValueAtTime(0.12,now+2);
  }
}

function updateAudio(){
  if(!window._audioRefs) return;
  const refs=window._audioRefs;
  const dist=sph.radius;

  // Proximity rumble: louder as camera gets closer
  // Range: radius 2.5 (max rumble) to 15 (silent)
  const proximity=Math.max(0,1.0-(dist-2.5)/12.5);
  const rumbleVol=proximity*proximity*0.15;
  refs.rumbleGain.gain.linearRampToValueAtTime(rumbleVol,audioCtx.currentTime+0.1);

  // Noise filter opens up when closer
  refs.noiseFilter.frequency.linearRampToValueAtTime(60+proximity*200,audioCtx.currentTime+0.1);
  refs.noiseGain.gain.linearRampToValueAtTime(0.01+proximity*0.03,audioCtx.currentTime+0.1);

  // High harmonic gets louder at medium distance (sweet spot)
  const midProx=Math.exp(-Math.pow(dist-6,2)*0.05);
  refs.highGain.gain.linearRampToValueAtTime(0.02+midProx*0.04,audioCtx.currentTime+0.1);
}

// Init audio on first interaction
['mousedown','touchstart','keydown'].forEach(evt=>{
  document.addEventListener(evt,initAudio,{once:false});
});

// ============================================================
// ANIMATION
// ============================================================
const clock=new THREE.Clock();
const timeMats=[disk.mat,jetUp.mat,jetDown.mat,dustMat,infall.mat,starsMat,tde.mat];

function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();

  sph.theta+=(tgt.theta-sph.theta)*0.05;
  sph.phi+=(tgt.phi-sph.phi)*0.05;
  sph.radius+=(tgt.radius-sph.radius)*0.05;
  if(!isDragging) tgt.theta+=0.0003;

  camera.position.set(
    sph.radius*Math.sin(sph.phi)*Math.sin(sph.theta),
    sph.radius*Math.cos(sph.phi),
    sph.radius*Math.sin(sph.phi)*Math.cos(sph.theta)
  );
  camera.lookAt(0,0,0);
  pulse*=0.94;
  updateAudio();

  timeMats.forEach(m=>{
    if(m.uniforms.uTime)m.uniforms.uTime.value=t;
    if(m.uniforms.uPulse)m.uniforms.uPulse.value=pulse;
  });

  // Update disk
  const pa=disk.posAttr,ca=disk.colAttr,sa=disk.sizAttr,bc=disk.baseColors,bs=disk.baseSizes;
  const camA=Math.atan2(camera.position.x,camera.position.z);
  const curISCO = isco.prograde;
  for(let i=0;i<DISK_N;i++){
    const r=disk.radii[i];
    // Frame dragging — amplified for visibility
    const frameDrag=kerrFrameDrag(spinA,r)*3.0;
    disk.angles[i]+=(disk.velocities[i]+frameDrag)*0.004;
    const a=disk.angles[i];
    pa.array[i*3]=Math.cos(a)*r;
    pa.array[i*3+2]=Math.sin(a)*r;

    // Particles inside ISCO: fade out (unstable plunging orbits)
    // Particles inside event horizon: completely hidden
    let visibility = 1.0;
    if(r < rPlus * 1.05) {
      visibility = 0.0;
    } else if(r < curISCO) {
      // Fade zone: particles exist but are unstable, dim them significantly
      const f = (r - rPlus * 1.05) / (curISCO - rPlus * 1.05);
      visibility = f * f * 0.3; // very dim inside ISCO
    }

    // Update size based on visibility
    sa.array[i] = bs[i] * visibility;

    // Doppler beaming
    const dop=0.5+0.6*Math.cos(a-camA);
    const df=0.5+dop*0.55;
    // Gravitational redshift — Kerr-corrected
    const redshiftFactor = kerrTimeDilation(spinA, r);
    const rShift = 1.0 - (1.0 - redshiftFactor) * 0.3;
    const gShift = redshiftFactor * 0.85 + 0.15;
    const bShift = redshiftFactor * redshiftFactor;
    ca.array[i*3]  =bc[i*3]  *df*rShift*visibility;
    ca.array[i*3+1]=bc[i*3+1]*df*gShift*visibility;
    ca.array[i*3+2]=bc[i*3+2]*df*bShift*visibility;
  }
  pa.needsUpdate=true;ca.needsUpdate=true;sa.needsUpdate=true;

  // Update infall particles
  updateInfall(t);

  // Update tidal disruption event
  updateTDE(1.0);

  // Update time dilation HUD (Kerr-corrected)
  {
    const camR = sph.radius;
    const camDilation = kerrTimeDilation(spinA, camR);
    document.getElementById('td-cam').style.width = (camDilation * 100) + '%';
    document.getElementById('td-cam-val').textContent = camDilation.toFixed(3);

    // Update ISCO label and value dynamically
    const iscoD = kerrTimeDilation(spinA, isco.prograde);
    const innerD = kerrTimeDilation(spinA, rPlus * 2.0);
    const outerD = kerrTimeDilation(spinA, 7.5 * M_BH * 2);

    // Update bar widths and values
    const tdIsco=document.getElementById('td-isco');
    const tdInner=document.getElementById('td-inner');
    const tdOuter=document.getElementById('td-outer');
    if(tdIsco){tdIsco.style.width=(iscoD*100)+'%';}
    if(tdInner){tdInner.style.width=(innerD*100)+'%';}
    if(tdOuter){tdOuter.style.width=(outerD*100)+'%';}
    // Update value text
    const valEls=document.querySelectorAll('#timedilation .td-val');
    if(valEls[1]) valEls[1].textContent=iscoD.toFixed(3);
    if(valEls[2]) valEls[2].textContent=innerD.toFixed(3);
    if(valEls[3]) valEls[3].textContent=outerD.toFixed(3);
    // Update ISCO label
    const lblEls=document.querySelectorAll('#timedilation .td-label');
    if(lblEls[1]) lblEls[1].textContent='ISCO ('+isco.prograde.toFixed(1)+' r)';

    // Animate clock dots
    const rates = [
      { id: 'tc-eh',    factor: 0.001, color: '#f44' },
      { id: 'tc-isco',  factor: iscoD, color: '#fa4' },
      { id: 'tc-inner', factor: innerD, color: '#fb4' },
      { id: 'tc-outer', factor: outerD, color: '#be5' },
      { id: 'tc-cam',   factor: camDilation, color: '#fc8' },
      { id: 'tc-inf',   factor: 1.0,   color: '#8d8' }
    ];
    for (const r of rates) {
      const el = document.getElementById(r.id);
      if (!el) continue;
      const tickPhase = Math.sin(t * Math.PI * 2.0 * r.factor);
      const isOn = tickPhase > 0.3;
      el.textContent = isOn ? '●' : '○';
      el.style.color = r.color;
      el.style.opacity = isOn ? 1.0 : 0.25;
    }
  }

  // Update BG shader camera + Kerr params
  bgMat.uniforms.uCamPos.value.copy(camera.position);
  bgMat.uniforms.uTime.value=t;
  bgMat.uniforms.uRPlus.value=rPlus;
  bgMat.uniforms.uSpinA.value=spinA;

  // Update void sphere size and ergosphere
  voidSphere.scale.setScalar(rPlus);
  ergoMat.uniforms.uRPlus.value=rPlus;
  ergoMat.uniforms.uSpinA.value=spinA;
  ergoMat.uniforms.uTime.value=t;

  // Update void mask camera + Kerr params
  voidMaskMat.uniforms.uCamPos.value.copy(camera.position);
  voidMaskMat.uniforms.uRes.value.set(window.innerWidth,window.innerHeight);
  voidMaskMat.uniforms.uRPlus.value=rPlus;

  // ---- RENDER PIPELINE ----

  // 0. Compute BH screen position for lens shader
  const bhPos3=new THREE.Vector3(0,0,0);
  bhPos3.project(camera);
  const bhScreenX=(bhPos3.x*0.5+0.5);
  const bhScreenY=(bhPos3.y*0.5+0.5);
  // Apparent angular radius: project a point on the event horizon
  const edgePos=new THREE.Vector3(rPlus,0,0);
  edgePos.project(camera);
  const edgeScreenX=(edgePos.x*0.5+0.5);
  const bhScreenR=Math.abs(edgeScreenX-bhScreenX)*1.1;

  lensMat.uniforms.uBHScreen.value.set(bhScreenX,bhScreenY);
  lensMat.uniforms.uBHRadius.value=Math.max(0.01,bhScreenR);

  // 1. Render stars to texture
  renderer.setRenderTarget(rtStars);
  renderer.setClearColor(0x000000,1);renderer.clear();
  renderer.render(starScene,camera);

  // 2. Apply gravitational lensing distortion
  lensMat.uniforms.tStars.value=rtStars.texture;
  postQuad.material=lensMat;
  renderer.setRenderTarget(rtStarsLensed);renderer.clear();
  renderer.render(postScene,ortho);

  // 3. Raymarched BG glow (Einstein ring)
  renderer.setRenderTarget(rtBG);renderer.clear();
  renderer.render(bgScene,ortho);

  // 4. Void mask
  postQuad.material=voidMaskMat;
  renderer.setRenderTarget(rtMask);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Particle scene (disk, jets, void, dust, infall — no stars)
  renderer.setRenderTarget(rtParticles);
  renderer.setClearColor(0x000000,1);renderer.clear();
  renderer.render(scene,camera);

  // 6. Combine: (lensedStars + bg) * (1-mask) + particles
  finalCombineMat.uniforms.tBG.value=rtBG.texture;
  finalCombineMat.uniforms.tStarsLensed.value=rtStarsLensed.texture;
  finalCombineMat.uniforms.tParticles.value=rtParticles.texture;
  finalCombineMat.uniforms.tMask.value=rtMask.texture;
  postQuad.material=finalCombineMat;
  renderer.setRenderTarget(rtCombined);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Bloom: extract bright
  threshMat.uniforms.tDiffuse.value=rtCombined.texture;
  postQuad.material=threshMat;
  renderer.setRenderTarget(rtBright);renderer.clear();
  renderer.render(postScene,ortho);

  // Blur passes (bloom)
  for(let p=0;p<3;p++){
    blurH.uniforms.tDiffuse.value=p===0?rtBright.texture:rtBlurB.texture;
    postQuad.material=blurH;
    renderer.setRenderTarget(rtBlurA);renderer.clear();
    renderer.render(postScene,ortho);
    blurV.uniforms.tDiffuse.value=rtBlurA.texture;
    postQuad.material=blurV;
    renderer.setRenderTarget(rtBlurB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 5b. Anamorphic streak passes — ultra-wide horizontal blur
  // Start from bright extract, run 4 wide horizontal passes for massive spread
  for(let s=0;s<4;s++){
    streakBlurMat.uniforms.tDiffuse.value=s===0?rtBright.texture:rtStreakB.texture;
    postQuad.material=streakBlurMat;
    renderer.setRenderTarget(rtStreakA);renderer.clear();
    renderer.render(postScene,ortho);
    // Ping-pong
    streakBlurMat.uniforms.tDiffuse.value=rtStreakA.texture;
    renderer.setRenderTarget(rtStreakB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 6. Final composite with bloom + streaks
  compositeMat.uniforms.tScene.value=rtCombined.texture;
  compositeMat.uniforms.tBloom.value=rtBlurB.texture;
  compositeMat.uniforms.tStreak.value=rtStreakB.texture;
  compositeMat.uniforms.uTime.value=t;
  compositeMat.uniforms.uBloomStr.value=1.4+pulse*1.2;
  postQuad.material=compositeMat;
  renderer.setRenderTarget(null);renderer.clear();
  renderer.render(postScene,ortho);
}
animate();

window.addEventListener('resize',()=>{
  const w=window.innerWidth,h=window.innerHeight;
  camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h);
  bgMat.uniforms.uRes.value.set(w,h);
  voidMaskMat.uniforms.uRes.value.set(w,h);
  const p=Math.min(window.devicePixelRatio,2);
  rtParticles.setSize(w*p,h*p);rtCombined.setSize(w*p,h*p);
  rtBG.setSize(w*p,h*p);rtMask.setSize(w*p,h*p);
  rtStars.setSize(w*p,h*p);rtStarsLensed.setSize(w*p,h*p);
  rtBright.setSize(w*p*0.5,h*p*0.5);
  [rtBlurA,rtBlurB].forEach(rt=>rt.setSize(w*p*0.5,h*p*0.5));
  [rtStreakA,rtStreakB].forEach(rt=>rt.setSize(w*p*0.25,h*p*0.25));
  [blurH,blurV].forEach(m=>m.uniforms.uRes.value.set(w*0.5,h*0.5));
  streakBlurMat.uniforms.uRes.value.set(w*0.25,h*0.25);
});
</script>
</body>
</html>
