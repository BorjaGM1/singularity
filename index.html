<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SINGULARITY</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@400;500&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;cursor:grab;font-family:'Instrument Sans',sans-serif;}
body:active{cursor:grabbing;}
canvas{display:block;}
#overlay{position:fixed;inset:0;pointer-events:none;z-index:10;
  background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.5) 100%);}
#info{position:fixed;bottom:24px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.3);font-size:11px;letter-spacing:3px;
  text-align:center;pointer-events:none;z-index:20;}
#wavemode{position:fixed;top:28px;right:28px;z-index:20;display:flex;gap:6px;}
#wavemode button{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  color:rgba(255,255,255,0.4);font-family:'Instrument Sans',sans-serif;font-size:10px;
  letter-spacing:2px;padding:6px 12px;cursor:pointer;transition:all 0.4s;text-transform:uppercase;}
#wavemode button:hover{background:rgba(255,255,255,0.12);color:rgba(255,255,255,0.6);}
#wavemode button.active{border-color:rgba(255,255,255,0.5);color:rgba(255,255,255,0.8);}
#wavemode button.active.vis{background:rgba(255,180,80,0.2);border-color:rgba(255,180,80,0.5);}
#wavemode button.active.xray{background:rgba(80,160,255,0.2);border-color:rgba(80,160,255,0.5);}
#wavemode button.active.radio{background:rgba(255,80,80,0.2);border-color:rgba(255,80,80,0.5);}
#spinctl{position:fixed;bottom:60px;right:28px;z-index:20;text-align:right;
  font-family:'Instrument Sans',sans-serif;font-size:9px;letter-spacing:2px;color:rgba(255,255,255,0.3);text-transform:uppercase;}
#spinctl label{display:block;margin-bottom:6px;}
#spinctl input[type=range]{-webkit-appearance:none;width:120px;height:3px;background:rgba(255,255,255,0.15);
  border-radius:2px;outline:none;cursor:pointer;}
#spinctl input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:12px;height:12px;
  border-radius:50%;background:rgba(255,255,255,0.5);border:1px solid rgba(255,255,255,0.3);cursor:pointer;}
#spinctl .spin-val{font-size:12px;color:rgba(255,255,255,0.5);font-variant-numeric:tabular-nums;margin-top:3px;}
/* Time dilation */
#timedilation{position:fixed;bottom:60px;left:28px;z-index:20;pointer-events:none;
  font-family:'Instrument Sans',sans-serif;font-size:10px;letter-spacing:1px;color:rgba(255,255,255,0.35);}
#timedilation .td-title{font-size:9px;letter-spacing:3px;text-transform:uppercase;margin-bottom:8px;
  color:rgba(255,255,255,0.25);}
#timedilation .td-row{display:flex;align-items:center;gap:8px;margin-bottom:5px;height:16px;}
#timedilation .td-label{width:90px;text-align:right;font-size:9px;}
#timedilation .td-bar{height:3px;background:rgba(255,255,255,0.1);border-radius:2px;width:80px;overflow:hidden;}
#timedilation .td-fill{height:100%;border-radius:2px;transition:width 0.3s;}
#timedilation .td-val{font-size:9px;width:40px;font-variant-numeric:tabular-nums;}
#timedilation .td-cam{color:rgba(255,200,100,0.6);}
#timedilation .td-clock{display:inline-block;width:16px;text-align:center;font-size:14px;line-height:14px;}
/* Info panel */
#infobtn{position:fixed;top:28px;left:28px;z-index:25;background:rgba(255,255,255,0.08);
  border:1px solid rgba(255,255,255,0.15);color:rgba(255,255,255,0.4);font-family:'Instrument Sans',sans-serif;
  font-size:10px;letter-spacing:2px;padding:6px 12px;cursor:pointer;transition:all 0.4s;text-transform:uppercase;}
#infobtn:hover{background:rgba(255,255,255,0.12);color:rgba(255,255,255,0.6);}
#infobtn.active{border-color:rgba(255,255,255,0.5);color:rgba(255,255,255,0.8);background:rgba(255,255,255,0.1);}
#infopanel{position:fixed;top:0;right:-420px;width:400px;height:100%;z-index:30;
  background:rgba(0,0,0,0.92);border-left:1px solid rgba(255,255,255,0.08);
  padding:32px 28px;overflow-y:auto;transition:right 0.4s cubic-bezier(0.4,0,0.2,1);
  font-family:'Instrument Sans',sans-serif;color:rgba(255,255,255,0.6);font-size:13px;line-height:1.7;}
#infopanel.open{right:0;}
#infopanel h2{font-size:11px;letter-spacing:4px;text-transform:uppercase;color:rgba(255,255,255,0.3);
  margin:28px 0 12px;font-weight:500;}
#infopanel h2:first-child{margin-top:0;}
#infopanel p{margin-bottom:12px;color:rgba(255,255,255,0.5);}
#infopanel .highlight{color:rgba(255,200,100,0.8);}
#infopanel .key{display:inline-block;background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  border-radius:3px;padding:1px 6px;font-size:11px;color:rgba(255,255,255,0.5);margin:0 2px;}
#infopanel .section{margin-bottom:24px;padding-bottom:24px;border-bottom:1px solid rgba(255,255,255,0.06);}
#infopanel .close{position:sticky;top:0;float:right;background:rgba(0,0,0,0.8);border:none;color:rgba(255,255,255,0.3);
  font-size:20px;cursor:pointer;padding:8px 12px;z-index:31;}
#infopanel .close:hover{color:rgba(255,255,255,0.6);}
#infopanel ul{margin:8px 0 12px 16px;color:rgba(255,255,255,0.45);font-size:12px;}
#infopanel li{margin-bottom:6px;}
#title{position:fixed;top:28px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.45);font-size:13px;letter-spacing:12px;
  text-transform:uppercase;pointer-events:none;z-index:20;font-weight:500;}
</style>
</head>
<body>
<div id="overlay"></div>
<div id="title">SINGULARITY</div>
<button id="infobtn" onclick="toggleInfo()">Info</button>
<div id="wavemode">
  <button class="vis active" onclick="setWaveMode(0)">Visible</button>
  <button class="xray" onclick="setWaveMode(1)">X-Ray</button>
  <button class="radio" onclick="setWaveMode(2)">Radio</button>
</div>

<div id="infopanel">
  <button class="close" onclick="toggleInfo()">✕</button>

  <div class="section">
    <h2>What is this?</h2>
    <p>A real-time simulation of a <span class="highlight">supermassive black hole</span> with an accretion disk, relativistic jets, and gravitational lensing. Everything you see is computed using actual physics — General Relativity, Schwarzschild spacetime geometry, and blackbody radiation.</p>
    <p>Every galaxy is believed to harbor a supermassive black hole at its center, ranging from millions to billions of solar masses. When gas, dust, or even whole stars fall close enough, they form a swirling accretion disk that heats to millions of degrees — making the black hole visible across the universe despite the hole itself emitting no light.</p>
    <p>Built entirely in a single HTML file with Three.js and WebGL shaders. No external assets, no server — everything runs in your browser.</p>
  </div>

  <div class="section">
    <h2>Accretion Disk</h2>
    <p>The glowing ring of material orbiting the black hole. In reality, this is superheated gas (mostly hydrogen and helium) spiraling inward, heated by friction and compression to millions of degrees.</p>
    <ul>
      <li><span class="highlight">90,000 particles</span> placed using fractal noise density for realistic clumping and structure.</li>
      <li><span class="highlight">Keplerian Orbits</span> — inner particles orbit faster than outer ones, following Kepler's third law: v ∝ 1/√r. This differential rotation is what generates the friction that heats the disk.</li>
      <li><span class="highlight">Temperature Gradient</span> — white-hot inner edge (closest to the event horizon) through yellow and orange to dim red at the outer edge. This matches real accretion disk physics where temperature ∝ r<sup>−3/4</sup>.</li>
      <li><span class="highlight">Doppler Beaming</span> — the side of the disk rotating toward you appears brighter and slightly blue-shifted; the receding side appears dimmer and red-shifted. This asymmetry was clearly visible in the Event Horizon Telescope's images of M87* and Sagittarius A*.</li>
      <li><span class="highlight">Gravitational Redshift</span> — photons emitted near the event horizon lose energy climbing out of the gravity well. The formula z = 1/√(1 − r<sub>s</sub>/r) − 1 means particles at the inner disk edge appear noticeably redder than their true temperature. Blue light is affected most strongly.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Event Horizon &amp; Gravitational Lensing</h2>
    <p>The <span class="highlight">event horizon</span> is the boundary beyond which nothing — not even light — can escape. The black sphere you see is actually the <span class="highlight">black hole shadow</span>, which appears larger than the event horizon because light passing nearby gets bent inward.</p>
    <ul>
      <li><span class="highlight">Photon Sphere</span> (r = 1.5 r<sub>s</sub>) — at this radius, light can theoretically orbit the black hole in an unstable circular path. Light that grazes this radius gets deflected by enormous angles, creating a bright <span class="highlight">Einstein ring</span>.</li>
      <li><span class="highlight">Geodesic Ray Tracing</span> (default, press <span class="key">L</span> to toggle) — each pixel traces a light ray through curved Schwarzschild spacetime using the exact null geodesic equation: <strong>a = -(M/r³) × r̂ × (1 + 3h²/r²)</strong>, where h is the photon's angular momentum. This naturally produces the correct shadow, photon ring, primary and secondary Einstein rings, and multiple images of background stars. For spinning black holes, Kerr frame-dragging twists rays: <strong>a<sub>drag</sub> = 2Ma*/(r³) × (ẑ × r̂)</strong>, creating the asymmetric photon ring observed by the Event Horizon Telescope. 64 integration steps per pixel with adaptive step size and velocity Verlet integration.</li>
      <li><span class="highlight">Classic Lensing</span> (press <span class="key">L</span>) — the 25,000 particle-based background stars are warped by a screen-space post-process with deflection ∝ 1/b². Faster but less physically accurate — no secondary images or proper photon ring asymmetry.</li>
      <li><span class="highlight">Multiple Images</span> — in geodesic mode, a single star behind the black hole can appear as TWO images on opposite sides (primary + secondary Einstein ring), because light can pass on either side of the photon sphere. Very close to the shadow edge, light wraps further around, creating increasingly compressed image copies — the "photon ring".</li>
    </ul>
    <p>This uses the same fundamental physics as the rendering of Gargantua in <em>Interstellar</em> (Thorne &amp; James, 2015) and Eric Bruneton's real-time black hole shader, though simplified for 60fps browser performance.</p>
  </div>

  <div class="section">
    <h2>Relativistic Jets</h2>
    <p>Twin beams of plasma ejected along the black hole's rotation axis at velocities approaching the speed of light. Not all accreting black holes produce jets — the mechanism involves magnetic field lines twisted by the spinning accretion disk (the Blandford–Znajek process) or by the spinning black hole itself.</p>
    <ul>
      <li>Jets can extend <span class="highlight">millions of light-years</span> into intergalactic space, making them the largest single structures in the universe.</li>
      <li>The jets contain plasma heated to billions of degrees, making them bright in <span class="highlight">X-ray</span> wavelengths.</li>
      <li>Charged particles spiraling in the jet's magnetic fields emit <span class="highlight">synchrotron radiation</span>, which is why jets dominate in radio observations — try switching to Radio mode to see this effect.</li>
      <li>In the simulation: 5,000 particles per jet, helically twisted, with blue-white core coloring.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Matter Infall</h2>
    <p>12 clumps of gas continuously spiral inward from the outer disk, accelerating as they fall deeper into the gravity well. They leave bright trails that fade as they cross the event horizon.</p>
    <p>In reality, matter doesn't fall smoothly — turbulence, magnetic reconnection events, and instabilities create clumps and flares. The inner accretion flow is chaotic and variable, which is why real black holes "flicker" in brightness on timescales of minutes to hours.</p>
  </div>

  <div class="section">
    <h2>Hawking Radiation</h2>
    <p>The faint flickering particles at the event horizon represent <span class="highlight">Hawking radiation</span> — one of the most profound predictions in theoretical physics, proposed by Stephen Hawking in 1974.</p>
    <p><span class="highlight">How it works:</span> Quantum mechanics says that even "empty" vacuum is actually seething with <span class="highlight">virtual particle-antiparticle pairs</span> that pop into existence and annihilate each other almost instantly. Near the event horizon, something extraordinary happens: one particle can fall into the black hole while the other escapes. The escaping particle carries away real energy, and the black hole loses a tiny amount of mass.</p>
    <ul>
      <li><span class="highlight">Temperature</span> — a black hole radiates like a blackbody with temperature T = ℏc³/(8πGMk<sub>B</sub>). Smaller black holes are HOTTER. A stellar-mass black hole (~10 M☉) has a temperature of ~6 nanokelvin — far colder than the cosmic microwave background. Only microscopic black holes would glow visibly.</li>
      <li><span class="highlight">Evaporation</span> — over astronomical timescales, Hawking radiation causes black holes to slowly shrink and eventually evaporate completely. A stellar-mass BH would take ~10<sup>67</sup> years. A supermassive BH: ~10<sup>100</sup> years. The universe is only 1.4 × 10<sup>10</sup> years old.</li>
      <li><span class="highlight">Information Paradox</span> — if a black hole evaporates completely, what happens to the information about everything that fell in? This remains one of the deepest unsolved problems in physics, sitting at the intersection of quantum mechanics and general relativity.</li>
    </ul>
    <p><span class="highlight">In the simulation:</span> 200 particles spawn just outside the event horizon, drift outward (the escaping particle), and fade with quantum-like flickering. The spawn rate increases when the horizon is smaller (higher Hawking temperature). Color shifts bluer for smaller horizons (hotter radiation). The effect is deliberately subtle — in reality, Hawking radiation from astrophysical black holes is undetectably faint, dwarfed by the cosmic microwave background by a factor of trillions.</p>
    <p>Hawking radiation has never been directly observed, but analog experiments using sonic black holes in Bose-Einstein condensates have confirmed the theoretical mechanism.</p>
  </div>

  <div class="section">
    <h2>Tidal Disruption Event (TDE)</h2>
    <p>Press <span class="key">T</span> or <span class="key">Double-click</span> to trigger one.</p>
    <p>A TDE is one of the most violent events in the universe. It occurs when a star wanders too close to a supermassive black hole — typically through gravitational interactions with other stars in the dense galactic core.</p>
    <p><span class="highlight">What happens physically:</span></p>
    <ul>
      <li><span class="highlight">Approach</span> — the star falls toward the black hole on a nearly parabolic orbit, accelerating as it descends into the gravity well.</li>
      <li><span class="highlight">Tidal Radius</span> — at ~2.8 r<sub>s</sub>, the <em>differential</em> gravitational force across the star (stronger on the near side, weaker on the far side) exceeds the star's own self-gravity. The star can no longer hold itself together.</li>
      <li><span class="highlight">Spaghettification</span> — the star is stretched along the radial direction and compressed perpendicular to it. It elongates into a thin stream of hot gas — the famous "spaghettification" coined by Stephen Hawking.</li>
      <li><span class="highlight">Debris Stream</span> — roughly half the stellar mass gains enough energy to escape entirely. The other half forms a long, thin stream that wraps around the black hole, eventually circularizing into a temporary accretion disk.</li>
      <li><span class="highlight">Flare</span> — the infalling debris heats to extreme temperatures, producing a brilliant flare visible across billions of light-years. The flare typically peaks in UV/X-ray and fades over weeks to months.</li>
    </ul>
    <p><span class="highlight">Observational history:</span></p>
    <ul>
      <li>First well-confirmed TDEs were detected in X-ray surveys by ROSAT in the 1990s — sudden brightening in the centers of otherwise quiet galaxies.</li>
      <li>Modern surveys (ZTF, LSST, eROSITA) now detect several TDEs per year.</li>
      <li>TDEs are invaluable for astronomers — they briefly "light up" dormant black holes that would otherwise be completely invisible, revealing their mass and spin.</li>
      <li>The tidal radius depends on black hole mass: for black holes above ~10<sup>8</sup> solar masses, Sun-like stars are swallowed whole because the tidal radius falls inside the event horizon.</li>
    </ul>
    <p><span class="highlight">In the simulation:</span> 2,500 particles start clustered as a compact star, fall on a trajectory with angular momentum, get tidally stretched at the tidal radius (force ∝ r<sup>−3.5</sup>), and form an orbiting debris stream. Color evolves from white-blue (intact star) through yellow-white (disruption) to orange-red (cooling debris). Particles that reach r &lt; 0.5 r<sub>s</sub> are absorbed. Sound design includes a rising pitch during approach and a filtered noise burst at disruption.</p>
  </div>

  <div class="section">
    <h2>Time Dilation (dτ/dt)</h2>
    <p>In General Relativity, time flows slower in stronger gravitational fields. This isn't an illusion — it's a real, measurable effect. The <span class="highlight">dτ/dt</span> value (proper time / coordinate time) shows how fast a local clock ticks compared to a distant observer's clock.</p>
    <p>The formula is: <span class="highlight">dτ/dt = √(1 − r<sub>s</sub>/r)</span></p>
    <ul>
      <li><span class="highlight">Event Horizon</span> (r = r<sub>s</sub>) → 0.000 — time completely stops as seen from outside. A clock falling toward the event horizon would appear to slow down and freeze at the boundary — its last photons redshifted into oblivion. From the clock's own perspective, it crosses normally.</li>
      <li><span class="highlight">ISCO</span> (r = 3r<sub>s</sub>) → 0.577 — the Innermost Stable Circular Orbit. Below this radius, no stable orbit exists — any perturbation causes matter to spiral inward. This is the inner edge of the accretion disk. Time flows at 58% normal speed.</li>
      <li><span class="highlight">Inner Disk</span> (r = 2r<sub>s</sub>) → 0.707 — matter here is on unstable plunging orbits. Extremely hot and fast. Time at 71%.</li>
      <li><span class="highlight">Outer Disk</span> (r = 7.5r<sub>s</sub>) → 0.926 — nearly normal time. Gravitational time dilation is measurable but small at this distance.</li>
      <li><span class="highlight">Camera</span> → varies — this is YOU. Zoom in and watch your clock slow down. At minimum zoom distance (~2.5 r<sub>s</sub>), you'd experience significant time dilation.</li>
      <li><span class="highlight">Distant Observer</span> → 1.000 — infinitely far from the black hole. Normal time. This is the reference frame.</li>
    </ul>
    <p>The <span class="highlight">blinking dots</span> (●/○) next to each row tick at rates proportional to their time dilation factor. The distant observer blinks steadily. The ISCO dot blinks noticeably slower. The event horizon dot is essentially frozen. Zoom in and watch your camera dot slow down.</p>
    <p>This same effect operates on Earth, just far weaker. GPS satellites orbit at ~20,200 km altitude where gravity is weaker — their clocks tick ~38 microseconds faster per day than ground clocks. Without relativistic corrections, GPS would drift by ~10 km per day.</p>
  </div>

  <div class="section">
    <h2>Wavelength Modes</h2>
    <p>Real astronomers observe black holes across the electromagnetic spectrum. Each wavelength reveals different physics:</p>
    <ul>
      <li><span class="highlight">Visible</span> — what your eyes would see (if you could survive). Blackbody thermal radiation from hot gas. The accretion disk glows orange-white to red based on temperature. This is the hardest band to observe because dust in galaxies blocks visible light.</li>
      <li><span class="highlight">X-Ray</span> — how space telescopes like Chandra and XMM-Newton see black holes. Gas at millions of degrees emits X-rays. The blue-white palette reflects the extreme temperatures. Jets glow bright because they contain ultra-hot plasma. Most known stellar-mass black holes were first discovered in X-ray. The corona — a mysterious hot region above the disk — is brightest in X-ray.</li>
      <li><span class="highlight">Radio</span> — how radio telescopes (VLA, ALMA, EHT) observe them. False-color red/yellow (radio has no "real" color). Jets become dominant because they emit <span class="highlight">synchrotron radiation</span> — charged particles spiraling in magnetic fields at relativistic speeds. The Event Horizon Telescope's famous images of M87* and Sgr A* were captured at 1.3mm radio wavelength. Stars virtually disappear because stars are faint radio emitters.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Gravitational Waves</h2>
    <p>Ripples in the fabric of spacetime itself, predicted by Einstein in 1916 and directly detected by LIGO in 2015 — one of the greatest experimental achievements in physics history.</p>
    <p><span class="highlight">What they are:</span> When massive objects accelerate — black holes merging, neutron stars colliding, stars being tidally disrupted — they send out ripples that literally stretch and compress space as they pass. These waves travel at the speed of light and carry energy away from the source.</p>
    <ul>
      <li><span class="highlight">Detection</span> — LIGO/Virgo measure spacetime distortions of ~10<sup>−21</sup> meters — a thousand times smaller than a proton. The first detection (GW150914) came from two black holes merging 1.3 billion light-years away.</li>
      <li><span class="highlight">Quadrupole radiation</span> — gravitational waves squeeze space in one direction while stretching it perpendicular, oscillating back and forth. This is visible in the simulation as a screen-space distortion ripple.</li>
      <li><span class="highlight">Energy loss</span> — gravitational waves carry enormous energy. The first detected merger radiated ~3 solar masses of pure energy in gravitational waves in a fraction of a second — briefly outshining the entire observable universe.</li>
    </ul>
    <p><span class="highlight">In the simulation:</span> Press <span class="key">Space</span> or trigger a TDE to emit gravitational wave rings. You'll see expanding distortion ripples in the screen (the composite shader warps the image) and the accretion disk particles physically wobble as the wave passes through. The disk oscillation shows how gravitational waves stretch and compress the matter they pass through. Up to 4 simultaneous waves with sub-bass sound (12-25 Hz rumble).</p>
  </div>

  <div class="section">
    <h2>Particle Collisions &amp; Shockwaves</h2>
    <p>The accretion disk is not a calm, smooth flow — it's a violent, turbulent environment. When streams of matter collide with the disk, they produce <span class="highlight">shockwaves</span> and <span class="highlight">hot spots</span> that ripple outward.</p>
    <ul>
      <li><span class="highlight">Matter Infall Impacts</span> — when infalling gas clumps cross the disk plane, they collide with orbiting material. The collision heats the gas and produces an expanding shockwave ring visible as a bright ripple propagating through the disk.</li>
      <li><span class="highlight">TDE Debris Impacts</span> — tidal disruption debris plowing through the disk creates larger, brighter shockwaves. Trigger a TDE and watch for bright flares as the debris stream intersects the disk.</li>
      <li><span class="highlight">MRI Turbulence</span> — the Magnetorotational Instability (MRI) is the main driver of turbulence in real accretion disks. Magnetic field lines threading the disk get stretched by differential rotation, creating turbulent eddies that heat the gas. The simulation generates random hot spots to approximate this effect.</li>
      <li><span class="highlight">Impact Sparks</span> — bright white-yellow particles burst outward from collision sites, then fade as the shocked gas cools.</li>
      <li><span class="highlight">Shockwave Rings</span> — expanding rings of brightened disk particles that propagate outward from each impact. Particles in the wavefront grow temporarily brighter and larger, mimicking the density and temperature jump across a real shock front.</li>
    </ul>
    <p>In real accretion disks, shocks are responsible for much of the observed X-ray variability — the rapid flickering seen in X-ray binaries comes from turbulent hot spots orbiting and colliding in the inner disk.</p>
  </div>

  <div class="section">
    <h2>Visual Effects</h2>
    <ul>
      <li><span class="highlight">Anamorphic Streaks</span> — cinematic horizontal light streaks from the brightest regions, simulating an anamorphic lens flare. These are an artistic effect (not physical), created by 4 passes of ultra-wide horizontal blur at quarter resolution.</li>
      <li><span class="highlight">Bloom</span> — bright regions bleed light into neighboring pixels, simulating how real cameras and eyes respond to intense light sources. 3-pass Gaussian blur with threshold extraction.</li>
      <li><span class="highlight">Chromatic Aberration</span> — slight red/blue fringing at the edges of the frame, simulating imperfect optics.</li>
      <li><span class="highlight">Film Grain</span> — subtle noise overlay for cinematic texture.</li>
      <li><span class="highlight">Ambient Sound</span> — deep space drone built from detuned oscillators, proximity-reactive rumble, radiation noise hiss. The pulse (spacebar) triggers a sub-bass impact with metallic shimmer. TDE events have their own rising-pitch approach sound with a tearing noise burst.</li>
    </ul>
  </div>

  <div class="section">
    <h2>Controls</h2>
    <ul>
      <li><span class="key">Drag</span> Orbit the camera around the black hole</li>
      <li><span class="key">Scroll</span> Zoom in/out (affects time dilation!)</li>
      <li><span class="key">Space</span> Gravitational pulse — visual + sound burst</li>
      <li><span class="key">1</span> <span class="key">2</span> <span class="key">3</span> Switch wavelength (Visible / X-Ray / Radio)</li>
      <li><span class="key">T</span> or <span class="key">Double-click</span> Trigger a tidal disruption event</li>
      <li><span class="key">Spin slider</span> (bottom-right) Adjust black hole angular momentum a*</li>
      <li><span class="key">B</span> Add a companion black hole (max 4, 5 total)</li>
      <li><span class="key">L</span> Toggle between geodesic ray-traced and classic screen-space lensing</li>
      <li><span class="key">I</span> Toggle this info panel</li>
    </ul>
  </div>

  <div class="section">
    <h2>The Physics — Key Equations</h2>
    <p>This simulation uses the <span class="highlight">Schwarzschild metric</span> — the exact solution to Einstein's field equations for a non-rotating, uncharged black hole, published by Karl Schwarzschild in 1916, just months after Einstein published General Relativity.</p>
    <ul>
      <li><strong>Schwarzschild radius:</strong> r<sub>s</sub> = 2GM/c² — the event horizon radius. For our Sun, this would be ~3 km. For the M87* black hole (6.5 billion solar masses), it's ~19 billion km.</li>
      <li><strong>Orbital velocity:</strong> v = √(GM/r) — Kepler's law. Inner disk particles orbit faster.</li>
      <li><strong>Gravitational redshift:</strong> z = 1/√(1 − r<sub>s</sub>/r) − 1 — photon energy loss climbing out of the well.</li>
      <li><strong>Time dilation:</strong> dτ/dt = √(1 − r<sub>s</sub>/r) — proper time versus coordinate time.</li>
      <li><strong>Photon sphere:</strong> r = 1.5 r<sub>s</sub> — where light can orbit (unstably) around the black hole.</li>
      <li><strong>ISCO:</strong> r = 3 r<sub>s</sub> — innermost stable circular orbit (for Schwarzschild; spinning black holes differ).</li>
      <li><strong>Tidal acceleration:</strong> a<sub>tidal</sub> ∝ r<sup>−3</sup> — differential gravity that tears apart stars.</li>
      <li><strong>Gravitational lensing:</strong> deflection ∝ 1/b² (impact parameter) — Schwarzschild light bending.</li>
    </ul>
  </div>

  <div class="section">
    <h2>What is Black Hole Spin?</h2>
    <p>Black holes have only three measurable properties: <span class="highlight">mass</span>, <span class="highlight">spin</span> (angular momentum), and <span class="highlight">electric charge</span> (negligible in nature). This is the "no-hair theorem" — all other information about the matter that formed the black hole is lost.</p>
    <p>Spin is measured by the dimensionless parameter <span class="highlight">a* = Jc/GM²</span>, where J is angular momentum. It ranges from 0 (non-rotating, "Schwarzschild" black hole) to a theoretical maximum of 1 (an "extremal Kerr" black hole, where the event horizon rotates at the speed of light).</p>
    <p><span class="highlight">Why do black holes spin?</span> For the same reason an ice skater spins faster when pulling in their arms — conservation of angular momentum. When a massive star collapses, or when gas spirals inward from an accretion disk, the angular momentum gets concentrated into a smaller and smaller space. Almost all real black holes spin, and many spin very fast.</p>
    <p><span class="highlight">Real spin measurements:</span></p>
    <ul>
      <li><span class="highlight">M87*</span> (6.5 billion M☉, imaged by the EHT) — a* ≈ 0.9</li>
      <li><span class="highlight">Cygnus X-1</span> (21 M☉, first confirmed BH) — a* > 0.95</li>
      <li><span class="highlight">GRS 1915+105</span> (12 M☉, microquasar) — a* ≈ 0.998</li>
      <li><span class="highlight">Sagittarius A*</span> (4 million M☉, our galaxy's center) — a* ≈ 0.9 (estimated)</li>
    </ul>
    <p>Spin is measured by observing the inner edge of the accretion disk (which depends on ISCO radius), the shape of X-ray reflection spectra (iron line profile), and gravitational wave signals from merging black holes.</p>
  </div>

  <div class="section">
    <h2>Kerr Black Hole — What Changes with Spin</h2>
    <p>Use the <span class="highlight">spin slider</span> (bottom-right) to change a*. The simulation updates everything in real-time.</p>

    <p><span class="highlight">Event Horizon Shrinks</span></p>
    <p>r<sub>+</sub> = M(1 + √(1−a*²)). A non-spinning black hole has its horizon at the full Schwarzschild radius. At a*≈1, the horizon shrinks to half that size. You can see the black sphere physically get smaller as you increase spin. This is because the spinning spacetime "supports" the horizon at a smaller radius — loosely analogous to how a spinning top is more stable.</p>
    <ul>
      <li>a* = 0.0 → r<sub>+</sub> = 1.00 r<sub>s</sub></li>
      <li>a* = 0.5 → r<sub>+</sub> = 0.93 r<sub>s</sub></li>
      <li>a* = 0.7 → r<sub>+</sub> = 0.86 r<sub>s</sub> (default)</li>
      <li>a* = 0.9 → r<sub>+</sub> = 0.72 r<sub>s</sub></li>
      <li>a* = 0.998 → r<sub>+</sub> = 0.53 r<sub>s</sub></li>
    </ul>

    <p><span class="highlight">The Ergosphere</span></p>
    <p>The purple-blue glow between the horizon and r=1.0. Inside this region, spacetime itself rotates so fast that <em>nothing</em> can remain stationary — not matter, not light, not even spacetime itself. Everything is forced to co-rotate with the black hole. It's oblate: at the equator it always extends to r=1.0 regardless of spin, but at the poles it touches the horizon. The rotating streaks visualize the direction of frame-dragging.</p>
    <p>The ergosphere is where the <span class="highlight">Penrose process</span> operates: in principle, you can extract energy from a spinning black hole by sending matter into the ergosphere and splitting it so one piece falls in while the other escapes with MORE energy than the original particle had. This is not science fiction — it's a proven consequence of General Relativity and may power real astrophysical jets.</p>

    <p><span class="highlight">Frame Dragging (Lense-Thirring Effect)</span></p>
    <p>The spinning black hole drags spacetime with it, like a ball spinning in honey. Everything near the black hole gains extra angular velocity — the inner disk spins faster than Kepler's law alone would predict. The formula: ω<sub>fd</sub> = 2Ma*/(r(r²+a²M²)+2a²M³). Inner particles are dragged most.</p>
    <p>This effect is real and measurable: NASA's Gravity Probe B (2004-2011) measured frame-dragging from Earth's rotation — a shift of just 37 milliarcseconds per year. Near a spinning black hole, the effect is billions of times stronger.</p>

    <p><span class="highlight">ISCO Moves Inward</span></p>
    <p>The most visually dramatic effect. The Innermost Stable Circular Orbit (ISCO) — the inner edge of the accretion disk — depends on spin:</p>
    <ul>
      <li>a* = 0.0 → ISCO = 3.00 r<sub>s</sub> (big gap between disk and horizon)</li>
      <li>a* = 0.5 → ISCO = 2.32 r<sub>s</sub></li>
      <li>a* = 0.7 → ISCO = 1.70 r<sub>s</sub> (default)</li>
      <li>a* = 0.9 → ISCO = 1.15 r<sub>s</sub></li>
      <li>a* = 0.998 → ISCO = 0.62 r<sub>s</sub> (disk almost touches horizon)</li>
    </ul>
    <p>This is how astronomers measure spin in real black holes — by observing how close the inner disk edge gets. A closer inner edge means more gravitational energy is radiated before matter falls in. A maximally spinning BH can convert ~42% of infalling mass to energy (vs. ~6% for non-spinning). For comparison, nuclear fusion converts only ~0.7%. Spinning black holes are the most efficient energy sources in the universe.</p>
    <p>Try dragging the slider from 0 to 0.998 — watch the inner disk region empty out at low spin and fill in completely at high spin.</p>

    <p><span class="highlight">Time Dilation Changes</span></p>
    <p>All dτ/dt values in the HUD (bottom-left) recalculate in real-time using the Kerr metric. At higher spin, the ISCO is closer to the horizon, so time there flows much slower. The blinking clock dots update accordingly.</p>
  </div>

  <div class="section">
    <h2>Multiple Black Holes &amp; Mergers</h2>
    <p>Press <span class="key">B</span> to add a companion black hole (up to 4 companions + the primary = 5 total). Each companion orbits the primary under full N-body gravitational dynamics.</p>
    <p><span class="highlight">What happens:</span></p>
    <ul>
      <li><span class="highlight">N-body Gravity</span> — every black hole feels gravitational attraction from every other. Companions orbit the primary and interact with each other, producing complex dynamics including three-body chaos.</li>
      <li><span class="highlight">Disk Perturbation</span> — companion BHs gravitationally tug on disk particles as they pass through. You can see the disk warp near a passing companion — spiral arms and density waves form.</li>
      <li><span class="highlight">Gravitational Lensing</span> — each companion produces its own Einstein ring and shadow in the starfield. Multiple overlapping lensing patterns create complex distortions.</li>
      <li><span class="highlight">Orbital Trails</span> — each companion leaves a fading trail. Chaotic orbits produce spirograph-like patterns.</li>
      <li><span class="highlight">Inspiral</span> — close-orbiting pairs emit gravitational waves, losing energy and spiraling inward with increasing orbital frequency (the LIGO "chirp").</li>
      <li><span class="highlight">Merger</span> — when two BHs touch, they merge with a massive gravitational wave burst, spark shower, and characteristic chirp-then-ringdown sound.</li>
    </ul>
    <p><span class="highlight">Real multi-BH systems:</span> OJ 287 is a confirmed binary SMBH (150M M☉ orbiting 18B M☉, 12-year period). The Milky Way–Andromeda merger in ~4.5 billion years will produce a binary SMBH. Three-body BH interactions are genuinely chaotic. LIGO has detected dozens of BH-BH mergers since 2015.</p>
    <p><span class="highlight">In the simulation:</span> Companions have random mass (0.15–0.35× primary), spin, and orbital parameters. N-body gravity with GW energy loss drives inspiral. Void mask and lensing shaders support 4 companion shadows and Einstein rings simultaneously.</p>
  </div>

  <div class="section" style="border:none;">
    <h2>Simplifications &amp; Known Limits</h2>
    <p>This simulation prioritizes visual accuracy and real-time performance over full GR ray-tracing. Notable simplifications:</p>
    <ul>
      <li>Gravitational lensing in geodesic mode uses the Schwarzschild metric with first-order Kerr frame-dragging correction. Full Kerr null geodesics (Carter constant, separate prograde/retrograde critical curves) would produce more accurate asymmetric shadow shapes at extreme spin. The classic mode uses screen-space 1/b² distortion.</li>
      <li>The accretion disk is geometrically thin. Real disks can be thick (ADAF/RIAF at low accretion rates) or slim (at super-Eddington rates).</li>
      <li>TDE timescales are compressed — real events unfold over weeks to months, not seconds.</li>
      <li>No magnetohydrodynamics (MHD) — magnetic fields play a crucial role in jet formation (Blandford-Znajek process), disk turbulence (MRI instability), and angular momentum transport.</li>
      <li>The Penrose process and superradiance are not simulated — only the visual ergosphere is shown.</li>
      <li>Retrograde orbits are not modeled — all disk particles orbit prograde.</li>
    </ul>
  </div>
</div>

<div id="info">drag to orbit · scroll to zoom · space to pulse · 1/2/3 wavelength · T disruption · B add black hole · L toggle lensing · I info</div>
<div id="timedilation">
  <div class="td-title">Time Dilation · dτ/dt</div>
  <div class="td-row"><span class="td-label">Event Horizon</span><div class="td-bar"><div class="td-fill" id="td-eh" style="width:0%;background:#f44;"></div></div><span class="td-val">0.000</span><span class="td-clock" id="tc-eh">·</span></div>
  <div class="td-row"><span class="td-label">ISCO (3 rs)</span><div class="td-bar"><div class="td-fill" id="td-isco" style="width:57.7%;background:#fa4;"></div></div><span class="td-val">0.577</span><span class="td-clock" id="tc-isco">·</span></div>
  <div class="td-row"><span class="td-label">Inner Disk</span><div class="td-bar"><div class="td-fill" id="td-inner" style="width:70.7%;background:#fb4;"></div></div><span class="td-val">0.707</span><span class="td-clock" id="tc-inner">·</span></div>
  <div class="td-row"><span class="td-label">Outer Disk</span><div class="td-bar"><div class="td-fill" id="td-outer" style="width:92.6%;background:#be5;"></div></div><span class="td-val">0.926</span><span class="td-clock" id="tc-outer">·</span></div>
  <div class="td-row td-cam"><span class="td-label">▸ Camera</span><div class="td-bar"><div class="td-fill" id="td-cam" style="width:90%;background:#fc8;"></div></div><span class="td-val" id="td-cam-val">0.900</span><span class="td-clock" id="tc-cam">·</span></div>
  <div class="td-row"><span class="td-label">Distant Observer</span><div class="td-bar"><div class="td-fill" id="td-inf" style="width:100%;background:#8d8;"></div></div><span class="td-val">1.000</span><span class="td-clock" id="tc-inf">·</span></div>
</div>
<div id="spinctl">
  <label>Black Hole Spin · a*</label>
  <input type="range" id="spinslider" min="0" max="0.998" step="0.01" value="0.7" oninput="setSpinA(parseFloat(this.value))">
  <div class="spin-val" id="spinval">a* = 0.700</div>
  <div class="spin-val" id="bhcount" style="margin-top:8px;color:rgba(255,255,255,0.3);">1 BH</div>
  <div class="spin-val" id="lensmodebadge" style="margin-top:4px;color:rgba(180,160,255,0.5);font-size:10px;">GEODESIC LENSING</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// SINGULARITY — HYBRID
// Raymarched gravitationally-lensed starfield background
// + Particle accretion disk, jets, void sphere
// + Full bloom pipeline
// ============================================================

// === Procedural sprite textures ===
function genSprite(size,falloff,softness){
  const c=document.createElement('canvas');c.width=c.height=size;
  const ctx=c.getContext('2d'),img=ctx.createImageData(size,size),h=size/2;
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){
    const d=Math.sqrt(((x-h)/h)**2+((y-h)/h)**2);
    const a=Math.min(1,Math.exp(-d*d*falloff)+Math.exp(-d*d*softness)*0.3);
    const i=(y*size+x)*4;img.data[i]=img.data[i+1]=img.data[i+2]=255;img.data[i+3]=a*255|0;
  }
  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c);tex.needsUpdate=true;return tex;
}
const diskTex=genSprite(64,4.0,1.2),jetTex=genSprite(32,3.0,0.8);

// ============================================================
// KERR BLACK HOLE PHYSICS
// Spin parameter a* ∈ [0, 0.998]. a*=0 → Schwarzschild, a*→1 → extremal Kerr
// All lengths in units where Schwarzschild radius RS = 2M = 1.0, so M = 0.5
// ============================================================
const M_BH = 0.5; // mass in our units (RS = 2M = 1.0)
let spinA = 0.7;   // dimensionless spin parameter a* = a/M

function kerrEventHorizon(a) {
  // r+ = M(1 + √(1 - a*²))
  return M_BH * (1.0 + Math.sqrt(Math.max(0, 1.0 - a * a)));
}

function kerrErgosphere(a, cosTheta) {
  // r_ergo(θ) = M + √(M² - a²M²cos²θ) = M(1 + √(1 - a*²cos²θ))
  return M_BH * (1.0 + Math.sqrt(Math.max(0, 1.0 - a * a * cosTheta * cosTheta)));
}

function kerrISCO(a) {
  // Exact ISCO formula for prograde orbit in Kerr spacetime
  // Returns r_isco in our coordinate units
  const a2 = a * a;
  const z1 = 1.0 + Math.pow(1.0 - a2, 1.0/3.0) * (Math.pow(1.0 + a, 1.0/3.0) + Math.pow(Math.max(0, 1.0 - a), 1.0/3.0));
  const z2 = Math.sqrt(3.0 * a2 + z1 * z1);
  const pro = 3.0 + z2 - Math.sqrt(Math.max(0, (3.0 - z1) * (3.0 + z1 + 2.0 * z2)));
  const retro = 3.0 + z2 + Math.sqrt(Math.max(0, (3.0 - z1) * (3.0 + z1 + 2.0 * z2)));
  return { prograde: pro * M_BH, retrograde: retro * M_BH };
}

function kerrFrameDrag(a, r) {
  // Frame-dragging angular velocity ω = 2Ma*/(r(r²+a²M²)+2a²M³)
  // Simplified for equatorial plane
  const aM = a * M_BH;
  const r2 = r * r;
  const a2M2 = aM * aM;
  return (2.0 * M_BH * aM) / (r * (r2 + a2M2) + 2.0 * a2M2 * M_BH);
}

function kerrTimeDilation(a, r) {
  // Approximate Kerr time dilation at equator
  // dτ/dt = √(1 - 2M/r) for Schwarzschild
  // For Kerr: dτ/dt ≈ √(1 - 2M/(r + a²M²/r))  (simplified equatorial)
  const a2M2 = a * a * M_BH * M_BH;
  const rEff = r + a2M2 / r;
  return Math.sqrt(Math.max(0.001, 1.0 - 2.0 * M_BH / rEff));
}

// Current derived values (updated when spin changes)
let rPlus = kerrEventHorizon(spinA);
let isco = kerrISCO(spinA);
let rErgoEquator = 1.0; // Always 2M = 1.0 at equator

// ============================================================
// N-BODY BLACK HOLE SYSTEM
// Companion BHs orbit the primary, interact gravitationally,
// perturb the disk, and merge with massive gwave bursts.
// ============================================================
const MAX_COMPANIONS = 4;
const companions = [];

function addCompanion(mass, distance, speed) {
  if (companions.length >= MAX_COMPANIONS) return;
  mass = mass || 0.12 + Math.random() * 0.18;
  distance = distance || 3.5 + Math.random() * 4.0;
  // Circular orbital speed: v = sqrt(GM/r), boosted slightly for elliptical stability
  speed = speed || Math.sqrt(0.5 / distance) * 1.08;

  const angle = Math.random() * Math.PI * 2;
  const tangent = angle + Math.PI * 0.5;

  const comp = {
    mass: mass,
    x: Math.cos(angle) * distance,
    z: Math.sin(angle) * distance,
    y: (Math.random() - 0.5) * 0.05,
    vx: Math.cos(tangent) * speed,
    vz: Math.sin(tangent) * speed,
    vy: 0,
    spin: 0.3 + Math.random() * 0.5,
    alive: true,
    voidMesh: null,
    glowMesh: null,
    trail: [],
    trailMesh: null
  };

  // Create void sphere for this companion
  const rH = comp.mass * (1.0 + Math.sqrt(Math.max(0, 1.0 - comp.spin * comp.spin)));
  const voidGeo = new THREE.SphereGeometry(1.0, 48, 48);
  comp.voidMesh = new THREE.Mesh(voidGeo, new THREE.ShaderMaterial({
    vertexShader: `void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader: `void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);}`,
    depthWrite: true, depthTest: true, side: THREE.FrontSide
  }));
  comp.voidMesh.scale.setScalar(rH);
  comp.voidMesh.position.set(comp.x, comp.y, comp.z);
  scene.add(comp.voidMesh);

  // Glow ring around companion — small accretion glow
  const glowGeo = new THREE.RingGeometry(rH * 1.2, rH * 2.5, 64);
  const glowMat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 } },
    vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader: `varying vec2 vUv; uniform float uTime;
      void main(){
        float r=length(vUv-0.5)*2.0;
        float ring=exp(-pow(r-0.6,2.0)*20.0);
        float pulse=0.8+0.2*sin(uTime*3.0);
        float a=ring*0.25*pulse;
        if(a<0.01) discard;
        vec3 col=mix(vec3(1.0,0.7,0.3),vec3(1.0,0.95,0.8),ring);
        gl_FragColor=vec4(col,a);
      }`,
    transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
  });
  comp.glowMesh = new THREE.Mesh(glowGeo, glowMat);
  comp.glowMesh.position.set(comp.x, comp.y, comp.z);
  comp.glowMesh.rotation.x = Math.PI * 0.5 + 0.08;
  scene.add(comp.glowMesh);

  // Trail geometry — orbital trail
  const trailN = 120;
  const trailPos = new Float32Array(trailN * 3);
  const trailCol = new Float32Array(trailN * 3);
  const trailSiz = new Float32Array(trailN);
  for (let i = 0; i < trailN; i++) {
    trailPos[i*3] = comp.x; trailPos[i*3+1] = comp.y; trailPos[i*3+2] = comp.z;
    const fade = 1.0 - i / trailN;
    trailCol[i*3] = 0.6 * fade; trailCol[i*3+1] = 0.4 * fade; trailCol[i*3+2] = 0.15 * fade;
    trailSiz[i] = (rH * 0.6) * fade;
  }
  comp.trail = [];
  for (let i = 0; i < trailN; i++) comp.trail.push({ x: comp.x, y: comp.y, z: comp.z });
  const trailGeo = new THREE.BufferGeometry();
  trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
  trailGeo.setAttribute('color', new THREE.BufferAttribute(trailCol, 3));
  trailGeo.setAttribute('size', new THREE.BufferAttribute(trailSiz, 1));
  comp.trailMesh = new THREE.Points(trailGeo, new THREE.ShaderMaterial({
    uniforms: { uTex: { value: diskTex } },
    vertexShader: `attribute float size; varying vec3 vC;
      void main(){ vC=color; vec4 mv=modelViewMatrix*vec4(position,1.0);
      gl_PointSize=size*(80.0/-mv.z); gl_Position=projectionMatrix*mv; }`,
    fragmentShader: `varying vec3 vC; uniform sampler2D uTex;
      void main(){ float a=texture2D(uTex,gl_PointCoord).a*0.5;
      if(a<0.01)discard; gl_FragColor=vec4(vC,a); }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  }));
  scene.add(comp.trailMesh);

  companions.push(comp);
  updateCompanionCount();

  // Sound: low thud announcing arrival
  if (audioCtx && masterGain) {
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    o.type = 'sine'; o.frequency.setValueAtTime(40, now); o.frequency.exponentialRampToValueAtTime(15, now + 0.8);
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.12, now); g.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
    o.connect(g); g.connect(masterGain); o.start(now); o.stop(now + 1.0);
  }
}

function mergeCompanion(idx) {
  const comp = companions[idx];
  if (!comp || !comp.alive) return;

  // Absorb mass into primary
  const oldMass = M_BH;
  // Don't change M_BH directly as it would break everything — just visual/sound
  const mergerMass = comp.mass;

  // Massive gravitational wave burst
  spawnGWave(2.0 + mergerMass * 3.0, 35, 0.25);
  spawnGWave(1.5 + mergerMass * 2.0, 30, 0.18);

  // Huge spark burst at merger point
  spawnSparks(comp.x, comp.y, comp.z, 60, 3.0);
  spawnShock(comp.x, comp.z, 2.0, 5.0, 0.06);

  // Merger sound — deep bass + rising chirp
  if (audioCtx && masterGain) {
    const now = audioCtx.currentTime;
    // Inspiral chirp
    const chirp = audioCtx.createOscillator();
    chirp.type = 'sine';
    chirp.frequency.setValueAtTime(30, now);
    chirp.frequency.exponentialRampToValueAtTime(250, now + 0.3);
    chirp.frequency.exponentialRampToValueAtTime(20, now + 1.5);
    const cg = audioCtx.createGain();
    cg.gain.setValueAtTime(0.2, now);
    cg.gain.linearRampToValueAtTime(0.35, now + 0.3);
    cg.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
    chirp.connect(cg); cg.connect(masterGain);
    chirp.start(now); chirp.stop(now + 2.0);

    // Deep impact
    const imp = audioCtx.createOscillator();
    imp.type = 'sine'; imp.frequency.value = 18;
    const ig = audioCtx.createGain();
    ig.gain.setValueAtTime(0.3, now + 0.3);
    ig.gain.exponentialRampToValueAtTime(0.001, now + 3.0);
    imp.connect(ig); ig.connect(masterGain);
    imp.start(now + 0.3); imp.stop(now + 3.0);
  }

  // Remove meshes
  scene.remove(comp.voidMesh);
  scene.remove(comp.glowMesh);
  scene.remove(comp.trailMesh);
  comp.alive = false;

  // Clean from array
  companions.splice(idx, 1);
  updateCompanionCount();

  // Visual flash — pulse
  pulse = Math.min(pulse + 0.5, 1.0);
}

function updateCompanions(dt) {
  const G = 0.5;
  const primaryMass = 1.0;
  const step = 0.025; // ~6x larger: visible orbits in 30-60 sec

  // Leapfrog integration for better energy conservation
  // Step 1: half-step velocity update
  for (let i = 0; i < companions.length; i++) {
    const ci = companions[i];
    if (!ci.alive) continue;

    let ax = 0, ay = 0, az = 0;

    // Gravity from primary
    const r2p = ci.x * ci.x + ci.y * ci.y + ci.z * ci.z;
    const rp = Math.sqrt(r2p);
    const fp = G * primaryMass / (r2p + 0.08);
    ax -= ci.x / rp * fp;
    ay -= ci.y / rp * fp;
    az -= ci.z / rp * fp;

    // Gravity from other companions
    for (let j = 0; j < companions.length; j++) {
      if (i === j) continue;
      const cj = companions[j];
      if (!cj.alive) continue;
      const dx = ci.x - cj.x, dy = ci.y - cj.y, dz = ci.z - cj.z;
      const r2 = dx * dx + dy * dy + dz * dz;
      const r = Math.sqrt(r2);
      const f = G * cj.mass * 2.0 / (r2 + 0.3);
      ax -= dx / r * f;
      ay -= dy / r * f;
      az -= dz / r * f;
    }

    // Half-step velocity
    ci.vx += ax * step * 0.5;
    ci.vy += ay * step * 0.5;
    ci.vz += az * step * 0.5;

    // Full-step position
    ci.x += ci.vx * step;
    ci.y += ci.vy * step;
    ci.z += ci.vz * step;

    // Dampen y to keep in disk plane
    ci.vy *= 0.99;
  }

  // Step 2: recompute acceleration at new position, second half-step velocity
  for (let i = 0; i < companions.length; i++) {
    const ci = companions[i];
    if (!ci.alive) continue;

    let ax = 0, ay = 0, az = 0;
    const r2p = ci.x * ci.x + ci.y * ci.y + ci.z * ci.z;
    const rp = Math.sqrt(r2p);
    const fp = G * primaryMass / (r2p + 0.08);
    ax -= ci.x / rp * fp;
    ay -= ci.y / rp * fp;
    az -= ci.z / rp * fp;

    for (let j = 0; j < companions.length; j++) {
      if (i === j) continue;
      const cj = companions[j];
      if (!cj.alive) continue;
      const dx = ci.x - cj.x, dy = ci.y - cj.y, dz = ci.z - cj.z;
      const r2 = dx * dx + dy * dy + dz * dz;
      const r = Math.sqrt(r2);
      const f = G * cj.mass * 2.0 / (r2 + 0.3);
      ax -= dx / r * f;
      ay -= dy / r * f;
      az -= dz / r * f;
    }

    ci.vx += ax * step * 0.5;
    ci.vy += ay * step * 0.5;
    ci.vz += az * step * 0.5;

    // GW energy loss — only very close, very gentle
    if (rp < 2.5) {
      const gwDrag = 1.0 - 0.0001 / (rp * rp * rp);
      ci.vx *= gwDrag; ci.vy *= gwDrag; ci.vz *= gwDrag;
      if (Math.random() < 0.004 / (rp * rp)) {
        spawnGWave(0.2 / rp, 15, 0.15);
      }
    }

    // Gentle drag only at very large radius to prevent full escape
    if (rp > 20) {
      const escapeDrag = 0.998;
      ci.vx *= escapeDrag; ci.vy *= escapeDrag; ci.vz *= escapeDrag;
    }
  }

  // Check mergers and update meshes
  for (let i = companions.length - 1; i >= 0; i--) {
    const ci = companions[i];
    if (!ci.alive) continue;

    const rp = Math.sqrt(ci.x * ci.x + ci.y * ci.y + ci.z * ci.z);
    const mergeR = rPlus + ci.mass * 1.2;
    if (rp < mergeR) {
      mergeCompanion(i);
      continue;
    }

    // Check merger with other companions
    for (let j = i - 1; j >= 0; j--) {
      const cj = companions[j];
      if (!cj.alive) continue;
      const dx = ci.x - cj.x, dy = ci.y - cj.y, dz = ci.z - cj.z;
      const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      const mergeD = (ci.mass + cj.mass) * 2.0;
      if (dist < mergeD) {
        // Merge smaller into larger
        if (ci.mass >= cj.mass) {
          ci.mass += cj.mass * 0.8;
          spawnGWave(1.5, 25, 0.2);
          spawnSparks(cj.x, cj.y, cj.z, 40, 2.0);
          scene.remove(cj.voidMesh); scene.remove(cj.glowMesh); scene.remove(cj.trailMesh);
          cj.alive = false;
          companions.splice(j, 1);
          if (i > j) i--;
        } else {
          cj.mass += ci.mass * 0.8;
          spawnGWave(1.5, 25, 0.2);
          spawnSparks(ci.x, ci.y, ci.z, 40, 2.0);
          scene.remove(ci.voidMesh); scene.remove(ci.glowMesh); scene.remove(ci.trailMesh);
          ci.alive = false;
          companions.splice(i, 1);
          break;
        }
        updateCompanionCount();
      }
    }
    if (!ci.alive) continue;

    // Update meshes
    const rH = ci.mass * (1.0 + Math.sqrt(Math.max(0, 1.0 - ci.spin * ci.spin)));
    ci.voidMesh.position.set(ci.x, ci.y, ci.z);
    ci.voidMesh.scale.setScalar(rH);
    ci.glowMesh.position.set(ci.x, ci.y, ci.z);
    ci.glowMesh.scale.setScalar(Math.max(0.5, ci.mass * 3.0));
    if (ci.glowMesh.material.uniforms) ci.glowMesh.material.uniforms.uTime.value = performance.now() * 0.001;

    // Update trail
    ci.trail.unshift({ x: ci.x, y: ci.y, z: ci.z });
    if (ci.trail.length > 120) ci.trail.pop();
    const tpa = ci.trailMesh.geometry.attributes.position;
    for (let t = 0; t < Math.min(120, ci.trail.length); t++) {
      tpa.array[t*3] = ci.trail[t].x;
      tpa.array[t*3+1] = ci.trail[t].y;
      tpa.array[t*3+2] = ci.trail[t].z;
    }
    tpa.needsUpdate = true;
  }
}

// Get gravitational perturbation from companions at a disk position
function getCompanionGravity(x, z) {
  let ax = 0, az = 0;
  for (let i = 0; i < companions.length; i++) {
    const c = companions[i];
    if (!c.alive) continue;
    const dx = x - c.x, dz = z - c.z;
    const r2 = dx * dx + dz * dz + 0.1;
    const r = Math.sqrt(r2);
    const f = c.mass * 0.3 / (r2 + 0.2);
    ax -= dx / r * f;
    az -= dz / r * f;
  }
  return { ax, az };
}

function updateCompanionCount() {
  const el = document.getElementById('bhcount');
  if (el) el.textContent = (1 + companions.length) + ' BH' + (companions.length > 0 ? 's' : '');
}

// === JS noise for particle placement ===
function hash2(x,y){let h=x*374761393+y*668265263;h=(h^(h>>13))*1274126177;return((h^(h>>16))&0x7fffffff)/0x7fffffff;}
function sNoise(x,y){const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy;
  const sx=fx*fx*(3-2*fx),sy=fy*fy*(3-2*fy);
  return hash2(ix,iy)*(1-sx)*(1-sy)+hash2(ix+1,iy)*sx*(1-sy)+hash2(ix,iy+1)*(1-sx)*sy+hash2(ix+1,iy+1)*sx*sy;}
function fbm(x,y,o){let v=0,a=0.5,f=1;for(let i=0;i<o;i++){v+=sNoise(x*f,y*f)*a;a*=0.5;f*=2;}return v;}

// ============================================================
// RENDERER
// ============================================================
const renderer=new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.autoClear=false;
document.body.appendChild(renderer.domElement);

const pxr=Math.min(window.devicePixelRatio,2);
function makeRT(s){return new THREE.WebGLRenderTarget(window.innerWidth*pxr*s,window.innerHeight*pxr*s,
  {type:THREE.HalfFloatType,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter});}

// Render targets
let rtBG=makeRT(1);          // raymarched background (full res for alignment)
let rtStars=makeRT(1);       // raw star render
let rtStarsLensed=makeRT(1); // gravitationally lensed stars
let rtParticles=makeRT(1);   // particle scene
let rtCombined=makeRT(1);    // combined
let rtBright=makeRT(0.5);
let rtBlurA=makeRT(0.5),rtBlurB=makeRT(0.5);
let rtStreakA=makeRT(0.25),rtStreakB=makeRT(0.25); // lower res for wide streaks

const fsGeo=new THREE.PlaneGeometry(2,2);
const ortho=new THREE.OrthographicCamera(-1,1,1,-1,0,1);

// ============================================================
// PASS 1: RAYMARCHED LENSED STARFIELD
// Only traces stars through curved spacetime — no disk rendering
// ============================================================
const CAM_FOV=55.0;
const FOV_MULT=2.0*Math.tan(CAM_FOV*0.5*Math.PI/180.0); // ≈1.039

const bgMat=new THREE.ShaderMaterial({
  uniforms:{
    uRes:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},
    uCamPos:{value:new THREE.Vector3(0,3,8)},
    uTime:{value:0},
    uFov:{value:FOV_MULT},
    uMode:{value:0},
    uRPlus:{value:rPlus},
    uSpinA:{value:spinA},
    uLensMode:{value:1}  // 0=classic glow only, 1=geodesic ray-traced
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    precision highp float;
    uniform vec2 uRes;
    uniform vec3 uCamPos;
    uniform float uTime,uFov,uMode,uRPlus,uSpinA,uLensMode;
    varying vec2 vUv;

    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}

    // ---- Procedural starfield ----
    float hash21(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    float hash31(vec3 p){return fract(sin(dot(p,vec3(127.1,311.7,74.7)))*43758.5453);}

    vec3 starfield(vec3 dir){
      // Spherical coords
      float theta=acos(clamp(dir.y,-1.0,1.0));
      float phi=atan(dir.z,dir.x);
      // Multi-scale grid for varying star densities
      vec3 col=vec3(0.0);
      // Dense field
      for(int layer=0;layer<2;layer++){
        float scale=layer==0?30.0:60.0;
        float threshold=layer==0?0.92:0.96;
        float bright=layer==0?1.0:0.4;
        vec2 grid=vec2(phi*scale/6.2832,theta*scale/3.14159);
        vec2 cell=floor(grid);
        for(int dx=-1;dx<=1;dx++){
          for(int dy=-1;dy<=1;dy++){
            vec2 c=cell+vec2(float(dx),float(dy));
            float h1=hash21(c+float(layer)*500.0);
            if(h1<threshold) continue;
            float h2=hash21(c+vec2(100.0,200.0)+float(layer)*500.0);
            float h3=hash21(c+vec2(300.0,400.0)+float(layer)*500.0);
            vec2 starPos=c+vec2(h1,h2);
            float dist=length(grid-starPos);
            // Sharp point-like star
            float s=exp(-dist*dist*200.0)*(0.3+h1*h1*3.0)*bright;
            // Twinkle
            s*=0.85+0.15*sin(uTime*0.5+h3*100.0);
            // Star color: temperature
            vec3 starCol;
            if(h3>0.75) starCol=vec3(0.7,0.8,1.0);      // hot blue
            else if(h3>0.45) starCol=vec3(1.0,0.97,0.92); // white
            else if(h3>0.2) starCol=vec3(1.0,0.88,0.7);   // yellow
            else starCol=vec3(1.0,0.65,0.45);              // orange-red
            col+=starCol*s;
          }
        }
      }
      return col;
    }

    // ---- Null geodesic ray-tracing ----
    // Schwarzschild + Kerr frame-dragging
    // Acceleration on photon: a = -(M/r³)*pos*(1 + 3h²/r²) + Kerr drag
    // This is exact for Schwarzschild, first-order for Kerr

    vec3 traceRay(vec3 ro, vec3 rd, out float hitBH, out float photonRingGlow){
      float M=uRPlus*0.5/(1.0+sqrt(max(0.0,1.0-uSpinA*uSpinA))); // M from rPlus
      float rs=2.0*M;
      hitBH=0.0;
      photonRingGlow=0.0;

      vec3 pos=ro;
      vec3 vel=rd*1.0; // unit speed (null geodesic)
      float minR=1e10;
      float dt=0.3; // adaptive step

      for(int i=0;i<64;i++){
        float r=length(pos);
        if(r<uRPlus*1.01){
          hitBH=1.0;
          return vec3(0.0);
        }
        if(r>80.0){
          break; // escaped — sample stars at current direction
        }

        // Track closest approach for photon ring detection
        if(r<minR) minR=r;

        // Adaptive step size — smaller near the BH for accuracy
        dt=clamp(r*0.08,0.05,0.5);

        // Angular momentum
        vec3 h=cross(pos,vel);
        float h2=dot(h,h);
        float r2=r*r;
        float r3=r2*r;

        // Schwarzschild geodesic acceleration
        vec3 acc=-M/r3*pos*(1.0+3.0*h2/r2);

        // Kerr frame-dragging: twist around spin axis (y-axis)
        if(uSpinA>0.01){
          float aKerr=uSpinA*M; // dimensional spin
          // Frame drag: Omega_fd = 2Ma/(r³) approximately
          // Adds tangential acceleration perpendicular to pos in equatorial plane
          vec3 spinAxis=vec3(0.0,1.0,0.0);
          vec3 tangent=cross(spinAxis,normalize(pos));
          float dragStrength=2.0*M*aKerr/(r3+aKerr*aKerr*r);
          acc+=tangent*dragStrength*length(vel);
        }

        // Velocity Verlet integration
        vec3 newVel=vel+acc*dt;
        pos+=0.5*(vel+newVel)*dt;
        vel=newVel;

        // Renormalize velocity (null geodesic: keep |v| constant in flat-space approx)
        vel=normalize(vel);
      }

      // Photon ring glow — rays that passed very close to photon sphere
      float photonSphere=rs*1.5; // 3M
      float closestRatio=minR/photonSphere;
      // Strong glow for rays that graze the photon sphere
      photonRingGlow=exp(-pow(closestRatio-1.0,2.0)*80.0)*2.0;
      // Secondary ring: rays that went ~halfway around
      photonRingGlow+=exp(-pow(closestRatio-1.02,2.0)*200.0)*0.8;

      return normalize(vel); // final direction — sample stars here
    }

    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));

      // === GEODESIC MODE ===
      if(uLensMode>0.5){
        float hitBH,prGlow;
        vec3 finalDir=traceRay(uCamPos,rd,hitBH,prGlow);

        if(hitBH>0.5){
          // Shadow — pure black with faint edge glow
          float b=length(cross(uCamPos,rd));
          float edgeGlow=exp(-pow(b-uRPlus*1.1,2.0)*5.0)*0.04;
          vec3 edgeCol=uMode<0.5?vec3(1.0,0.85,0.6):(uMode<1.5?vec3(0.4,0.6,1.0):vec3(1.0,0.4,0.1));
          gl_FragColor=vec4(edgeCol*edgeGlow,1.0);
          return;
        }

        // Sample procedural starfield at deflected direction
        vec3 stars=starfield(finalDir);

        // Einstein ring amplification — conservation of surface brightness
        // Rays near photon sphere are highly magnified
        stars*=(1.0+prGlow*3.0);

        // Photon ring glow
        vec3 ringCol=uMode<0.5?vec3(1.0,0.9,0.72):(uMode<1.5?vec3(0.6,0.8,1.0):vec3(1.0,0.5,0.2));
        stars+=ringCol*prGlow*0.12;

        // Ergosphere glow
        if(uSpinA>0.01){
          float b=length(cross(uCamPos,rd));
          float ergoR=0.5*(uRPlus+1.0);
          float ergoWidth=1.0-uRPlus;
          float ergoGlow=exp(-pow(b-ergoR,2.0)/(ergoWidth*ergoWidth*0.3))*0.04*uSpinA;
          vec3 ergoCol=uMode<0.5?vec3(0.4,0.3,0.9):(uMode<1.5?vec3(0.3,0.3,1.0):vec3(0.6,0.2,0.5));
          stars+=ergoCol*ergoGlow;
        }

        // Wavelength mode tint
        if(uMode>0.5&&uMode<1.5){
          float lum=dot(stars,vec3(0.33));
          stars=mix(stars,vec3(0.6,0.8,1.0)*lum*1.5,0.3);
        } else if(uMode>1.5){
          float lum=dot(stars,vec3(0.33));
          stars=mix(stars,vec3(1.0,0.5,0.2)*lum*1.5,0.3);
        }

        gl_FragColor=vec4(stars,1.0);
        return;
      }

      // === CLASSIC MODE (original glow-only) ===
      float b=length(cross(uCamPos,rd));
      float photonR=uRPlus*(1.0+0.5/(1.0+uSpinA));
      float ringGlow=exp(-pow(b-photonR,2.0)*18.0)*0.15;
      float shadowEdge=exp(-pow(b-uRPlus*1.1,2.0)*5.0)*0.06;
      float ergoGlow=0.0;
      if(uSpinA>0.01){
        float ergoR=0.5*(uRPlus+1.0);
        float ergoWidth=1.0-uRPlus;
        ergoGlow=exp(-pow(b-ergoR,2.0)/(ergoWidth*ergoWidth*0.3))*0.04*uSpinA;
      }
      vec3 ringCol,edgeCol,ergoCol;
      if(uMode<0.5){
        ringCol=vec3(1.0,0.9,0.72); edgeCol=vec3(1.0,0.85,0.6); ergoCol=vec3(0.4,0.3,0.9);
      } else if(uMode<1.5){
        ringCol=vec3(0.6,0.8,1.0); edgeCol=vec3(0.4,0.6,1.0); ergoCol=vec3(0.3,0.3,1.0);
      } else {
        ringCol=vec3(1.0,0.5,0.2); edgeCol=vec3(1.0,0.4,0.1); ergoCol=vec3(0.6,0.2,0.5);
      }
      vec3 col=ringCol*ringGlow+edgeCol*shadowEdge+ergoCol*ergoGlow;
      gl_FragColor=vec4(col,1.0);
    }
  `
});
const bgScene=new THREE.Scene();
bgScene.add(new THREE.Mesh(fsGeo.clone(),bgMat));

// ============================================================
// PASS 2: PARTICLE SCENE (from V7)
// ============================================================
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(55,window.innerWidth/window.innerHeight,0.1,1000);

// Event horizon — opaque black void (scalable for Kerr)
const voidSphere = new THREE.Mesh(
  new THREE.SphereGeometry(1.0,96,96),
  new THREE.ShaderMaterial({
    vertexShader:`void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);}`,
    depthWrite:true,depthTest:true,side:THREE.FrontSide
  })
);
voidSphere.scale.setScalar(rPlus);
scene.add(voidSphere);

// Ergosphere — translucent shell showing frame-dragging region
// Oblate: radius = 1.0 at equator, rPlus at poles
const ergoGeo = new THREE.SphereGeometry(1.0, 64, 64);
const ergoMat = new THREE.ShaderMaterial({
  uniforms: { uRPlus: { value: rPlus }, uSpinA: { value: spinA }, uTime: { value: 0 } },
  vertexShader: `
    varying vec3 vPos; varying vec3 vNorm;
    uniform float uRPlus, uSpinA;
    void main() {
      // Scale: equator stays at 1.0, poles shrink to rPlus
      vec3 p = position;
      float cosT = abs(p.y); // |cos(theta)|
      float rErgo = 0.5 * (1.0 + sqrt(max(0.0, 1.0 - uSpinA*uSpinA*cosT*cosT)));
      p *= rErgo;
      vPos = p;
      vNorm = normalMatrix * normal;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
    }`,
  fragmentShader: `
    varying vec3 vPos; varying vec3 vNorm;
    uniform float uSpinA, uTime;
    void main() {
      if(uSpinA < 0.01) discard; // No ergosphere for Schwarzschild
      float rim = 1.0 - abs(dot(normalize(vNorm), normalize(-vPos)));
      float equator = 1.0 - abs(vPos.y) / length(vPos);
      float pulse = 0.85 + 0.15 * sin(uTime * 0.5);
      // Much stronger alpha: clearly visible at moderate spin
      float alpha = rim * equator * uSpinA * 0.35 * pulse;
      alpha += rim * rim * rim * uSpinA * 0.15; // extra rim glow
      if(alpha < 0.003) discard;
      vec3 col = mix(vec3(0.25, 0.15, 0.7), vec3(0.6, 0.4, 1.0), rim);
      // Add spinning streaks to show frame-dragging rotation
      float streakAngle = atan(vPos.z, vPos.x);
      float streak = pow(abs(sin(streakAngle * 4.0 + uTime * uSpinA * 2.0)), 8.0);
      col += vec3(0.2, 0.1, 0.4) * streak * uSpinA;
      gl_FragColor = vec4(col, alpha);
    }`,
  transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.FrontSide
});
const ergoMesh = new THREE.Mesh(ergoGeo, ergoMat);
scene.add(ergoMesh);

// Particle starfield — in separate scene for gravitational lensing
const starTex=genSprite(32,8.0,2.0);
const starScene=new THREE.Scene();
const starsMat=(function(){
  const N=25000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=60+Math.random()*250,th=Math.random()*Math.PI*2,ph=Math.acos(2*Math.random()-1);
    pos[i*3]=r*Math.sin(ph)*Math.cos(th);pos[i*3+1]=r*Math.sin(ph)*Math.sin(th);pos[i*3+2]=r*Math.cos(ph);
    const t=Math.random(),c=t>0.85?[.7,.8,1]:(t>.5?[1,.97,.92]:(t>.2?[1,.88,.7]:[1,.65,.45]));
    col[i*3]=c[0];col[i*3+1]=c[1];col[i*3+2]=c[2];
    siz[i]=0.4+Math.pow(Math.random(),3)*5.0;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:starTex},uMode:{value:0}},
    vertexShader:`attribute float size;varying vec3 vC;varying float vS;uniform float uTime;
      void main(){vC=color;vS=size;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(200.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;varying float vS;uniform float uTime,uMode;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a;
        float tw=0.9+0.1*sin(uTime*0.4+vS*23.0);
        vec3 c=vC*tw*1.5;
        if(uMode>0.5&&uMode<1.5){
          float lum=dot(c,vec3(0.33));
          c=vec3(0.7,0.85,1.0)*lum;
        } else if(uMode>1.5){
          float lum=dot(c,vec3(0.33));
          c=vec3(lum*0.3,lum*0.15,lum*0.05);
        }
        gl_FragColor=vec4(c*a,a*tw);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  starScene.add(new THREE.Points(geo,mat));
  return mat;
})();

// Accretion disk — 90k noise-density particles
const DISK_N=90000;
const disk={radii:new Float32Array(DISK_N),angles:new Float32Array(DISK_N),
  velocities:new Float32Array(DISK_N),baseColors:null,baseSizes:null,posAttr:null,colAttr:null,sizAttr:null,mat:null};

(function(){
  const N=DISK_N;
  const pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  let placed=0;
  while(placed<N){
    const r=1.02+Math.pow(Math.random(),0.45)*6.2;
    const angle=Math.random()*Math.PI*2;
    const nx=Math.cos(angle)*r,nz=Math.sin(angle)*r;
    const density=0.42+fbm(nx*0.3,nz*0.3,3)*0.28+fbm(nx*0.8+100,nz*0.8+100,2)*0.18+fbm(nx*2+200,nz*2+200,2)*0.1;
    if(Math.random()>density) continue;
    const i=placed;
    const tNorm=(r-1.02)/6.2;
    const thickness=0.008+tNorm*0.065;
    pos[i*3]=nx;pos[i*3+1]=(Math.random()-0.5)*thickness;pos[i*3+2]=nz;
    disk.radii[i]=r;disk.angles[i]=angle;
    disk.velocities[i]=1.0/Math.pow(r,1.5);
    const cn=(Math.random()-0.5)*0.03;
    let cr,cg,cb;
    if(tNorm<0.03){cr=1.0+cn;cg=0.95+cn;cb=0.82;}
    else if(tNorm<0.08){const b=(tNorm-0.03)/0.05;cr=1.0+cn;cg=0.95-b*0.05+cn;cb=0.82-b*0.25;}
    else if(tNorm<0.18){const b=(tNorm-0.08)/0.1;cr=1.0+cn;cg=0.9-b*0.08+cn;cb=0.55-b*0.2;}
    else if(tNorm<0.35){const b=(tNorm-0.18)/0.17;cr=1.0+cn;cg=0.8-b*0.15+cn*0.5;cb=0.32-b*0.15;}
    else if(tNorm<0.55){const b=(tNorm-0.35)/0.2;cr=1.0-b*0.05+cn;cg=0.6-b*0.2+cn*0.3;cb=0.15-b*0.07;}
    else if(tNorm<0.78){const b=(tNorm-0.55)/0.23;cr=0.92-b*0.14+cn;cg=0.35-b*0.15+cn*0.2;cb=0.07-b*0.03;}
    else{const b=(tNorm-0.78)/0.22;cr=0.7-b*0.28+cn;cg=0.15-b*0.08;cb=0.03;}
    const bn=0.88+(fbm(nx*0.3,nz*0.3,3)-0.5)*0.16+(fbm(nx*0.8+100,nz*0.8+100,2)-0.5)*0.06;
    cr*=bn;cg*=bn;cb*=bn;
    col[i*3]=Math.max(0,Math.min(1,cr));col[i*3+1]=Math.max(0,Math.min(1,cg));col[i*3+2]=Math.max(0,Math.min(1,cb));
    siz[i]=(0.22+Math.random()*0.8)*(1.0-tNorm*0.2);
    placed++;
  }
  disk.baseColors=new Float32Array(col);
  disk.baseSizes=new Float32Array(siz);
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  disk.mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:diskTex},uMode:{value:0},uISCO:{value:isco.prograde}},
    vertexShader:`
      attribute float size;varying vec3 vC;varying float vR;
      uniform float uTime,uPulse;
      void main(){
        vC=color*(1.0+uPulse*0.35);
        vR=length(position.xz);
        vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(100.0/-mv.z)*(1.0+uPulse*0.2);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`
      varying vec3 vC;varying float vR;uniform sampler2D uTex;uniform float uMode,uISCO;
      void main(){
        float a=texture2D(uTex,gl_PointCoord).a*0.7;
        if(a<0.01)discard;
        float ib=1.0+smoothstep(uISCO*1.5,uISCO,vR)*1.0;
        vec3 c=vC*ib;
        if(uMode>0.5&&uMode<1.5){
          // X-RAY: remap to blue-white-purple
          float lum=dot(c,vec3(0.3,0.5,0.2));
          float hot=smoothstep(0.0,1.5,lum);
          vec3 xc=mix(vec3(0.1,0.0,0.3),vec3(0.3,0.5,1.0),hot);
          xc=mix(xc,vec3(0.9,0.95,1.0),hot*hot);
          c=xc*lum*2.0;
        } else if(uMode>1.5){
          // RADIO: remap to red-yellow synchrotron
          float lum=dot(c,vec3(0.3,0.5,0.2));
          float hot=smoothstep(0.0,1.2,lum);
          vec3 rc=mix(vec3(0.3,0.0,0.0),vec3(1.0,0.3,0.0),hot);
          rc=mix(rc,vec3(1.0,1.0,0.2),hot*hot*0.6);
          c=rc*lum*1.5;
        }
        gl_FragColor=vec4(c,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  disk.posAttr=geo.attributes.position;
  disk.colAttr=geo.attributes.color;
  disk.sizAttr=geo.attributes.size;
  const points=new THREE.Points(geo,disk.mat);
  points.rotation.x=0.08;points.rotation.z=0.05;
  scene.add(points);
})();

// Jets
function createJet(dir){
  const N=5000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const t=Math.pow(Math.random(),0.6);
    const h=t*14*dir,spread=t*t*0.45;
    const a=Math.random()*Math.PI*2,r=Math.random()*spread;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=h;pos[i*3+2]=Math.sin(a)*r;
    const b=1.0-t*0.85;
    col[i*3]=(0.4+t*0.15)*b;col[i*3+1]=(0.55+t*0.05)*b;col[i*3+2]=1.0*b;
    siz[i]=(1.0-t*0.6)*1.2;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:jetTex},uMode:{value:0}},
    vertexShader:`attribute float size;varying vec3 vC;uniform float uTime,uPulse;
      void main(){vC=color*(1.0+uPulse*0.3);
        vec3 p=position;float h=abs(p.y);
        p.x+=sin(uTime*2.5+h*1.2)*0.03*h*0.07;
        p.z+=cos(uTime*2.5+h*1.2)*0.03*h*0.07;
        vec4 mv=modelViewMatrix*vec4(p,1.0);
        gl_PointSize=size*(65.0/-mv.z)*(1.0+uPulse*0.4);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;uniform float uMode;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.35;
        if(a<0.01)discard;
        vec3 c=vC;
        if(uMode>0.5&&uMode<1.5){
          // X-RAY: jets are bright in X-ray — hot blue-white
          float lum=dot(c,vec3(0.3,0.4,0.3));
          c=vec3(0.5,0.7,1.0)*lum*3.0;
          a*=1.5;
        } else if(uMode>1.5){
          // RADIO: jets are VERY bright — synchrotron emission
          float lum=dot(c,vec3(0.3,0.4,0.3));
          c=vec3(1.0,0.6,0.1)*lum*4.0;
          a*=2.5;
        }
        gl_FragColor=vec4(c,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  return{points:new THREE.Points(geo,mat),mat};
}
const jetUp=createJet(1),jetDown=createJet(-1);
scene.add(jetUp.points);scene.add(jetDown.points);

// Dust halo
const dustMat=(function(){
  const N=4000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=5+Math.random()*14,a=Math.random()*Math.PI*2,y=(Math.random()-0.5)*2;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=y;pos[i*3+2]=Math.sin(a)*r;
    col[i*3]=0.3;col[i*3+1]=0.15;col[i*3+2]=0.05;
    siz[i]=0.3+Math.random()*0.7;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:diskTex}},
    vertexShader:`attribute float size;varying vec3 vC;
      void main(){vC=color;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(55.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.1;
        if(a<0.01)discard;gl_FragColor=vec4(vC,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  scene.add(new THREE.Points(geo,mat));return mat;
})();

// ============================================================
// MATTER INFALL — particles spiraling into the void with trails
// Each "clump" is a trail of points that spiral inward, accelerate,
// brighten, and vanish at the event horizon, then respawn
// ============================================================
const INFALL_CLUMPS = 12;
const TRAIL_LEN = 40;
const INFALL_N = INFALL_CLUMPS * TRAIL_LEN;
const infall = { clumps: [], posAttr: null, colAttr: null, sizAttr: null, mat: null };

(function(){
  const pos = new Float32Array(INFALL_N * 3);
  const col = new Float32Array(INFALL_N * 3);
  const siz = new Float32Array(INFALL_N);

  // Initialize clumps
  for (let c = 0; c < INFALL_CLUMPS; c++) {
    infall.clumps.push({
      r: 3.0 + Math.random() * 4.0,        // start radius
      angle: Math.random() * Math.PI * 2,    // current angle
      phase: Math.random() * Math.PI * 2,    // y-wobble phase
      speed: 0.15 + Math.random() * 0.1,     // angular speed multiplier
      drift: 0.003 + Math.random() * 0.004,  // inward drift rate
      brightness: 0.5 + Math.random() * 0.5,
      trail: []  // store past positions
    });
    // Pre-fill trail
    const clump = infall.clumps[c];
    for (let t = 0; t < TRAIL_LEN; t++) {
      clump.trail.push({ x: 0, y: 0, z: 0 });
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));

  const glowTex = genSprite(64, 3.0, 0.8);
  infall.mat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPulse: { value: 0 }, uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC; varying float vA;
      uniform float uPulse;
      void main() {
        vC = color;
        vA = color.r + color.g + color.b;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (90.0 / -mv.z) * (1.0 + uPulse * 0.3);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; varying float vA; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a * 0.8;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(0.6,0.8,1.0) * lum * 2.5;
        } else if(uMode > 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(1.0,0.5,0.1) * lum * 2.0;
        }
        gl_FragColor = vec4(c, a);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });

  infall.posAttr = geo.attributes.position;
  infall.colAttr = geo.attributes.color;
  infall.sizAttr = geo.attributes.size;

  const points = new THREE.Points(geo, infall.mat);
  points.rotation.x = 0.08; points.rotation.z = 0.05;
  scene.add(points);
})();

function updateInfall(time) {
  const pa = infall.posAttr, ca = infall.colAttr, sa = infall.sizAttr;

  for (let c = 0; c < INFALL_CLUMPS; c++) {
    const cl = infall.clumps[c];

    // Keplerian angular velocity + acceleration as it spirals in
    const omega = cl.speed / Math.pow(cl.r, 1.5);
    cl.angle += omega * 0.015;

    // Inward spiral — accelerates as it gets closer
    const driftAccel = 1.0 + Math.pow(3.0 / Math.max(cl.r, 1.1), 2.0) * 2.0;
    cl.r -= cl.drift * driftAccel * 0.015;

    // Small y wobble
    const y = Math.sin(cl.phase + time * 0.5) * 0.015 * cl.r * 0.3;

    // Current head position
    const hx = Math.cos(cl.angle) * cl.r;
    const hz = Math.sin(cl.angle) * cl.r;

    // Push new position to trail front, shift old ones back
    for (let t = TRAIL_LEN - 1; t > 0; t--) {
      cl.trail[t].x = cl.trail[t-1].x;
      cl.trail[t].y = cl.trail[t-1].y;
      cl.trail[t].z = cl.trail[t-1].z;
    }
    cl.trail[0].x = hx;
    cl.trail[0].y = y;
    cl.trail[0].z = hz;

    // Respawn when it reaches the void
    if (cl.r < 1.05) {
      cl.r = 4.0 + Math.random() * 3.5;
      cl.angle = Math.random() * Math.PI * 2;
      cl.drift = 0.003 + Math.random() * 0.004;
      cl.speed = 0.15 + Math.random() * 0.1;
      cl.brightness = 0.5 + Math.random() * 0.5;
      // Reset trail to new position to avoid streaks across screen
      const nx = Math.cos(cl.angle) * cl.r;
      const nz = Math.sin(cl.angle) * cl.r;
      for (let t = 0; t < TRAIL_LEN; t++) {
        cl.trail[t].x = nx; cl.trail[t].y = 0; cl.trail[t].z = nz;
      }
    }

    // Write trail to buffers
    for (let t = 0; t < TRAIL_LEN; t++) {
      const idx = c * TRAIL_LEN + t;
      const trailFade = 1.0 - t / TRAIL_LEN; // 1.0 at head, 0.0 at tail

      pa.array[idx*3]   = cl.trail[t].x;
      pa.array[idx*3+1] = cl.trail[t].y;
      pa.array[idx*3+2] = cl.trail[t].z;

      // Color: gets hotter (whiter) as radius decreases
      const rNorm = Math.max(0, Math.min(1, (cl.r - 1.0) / 6.0));
      const heat = 1.0 - rNorm; // 1.0 = at void, 0.0 = outer edge

      // Trail head: bright hot color. Tail: fades to disk color
      const headR = 1.0;
      const headG = 0.7 + heat * 0.25;
      const headB = 0.3 + heat * 0.6;

      const intensity = trailFade * trailFade * cl.brightness * (0.8 + heat * 1.5);
      ca.array[idx*3]   = headR * intensity;
      ca.array[idx*3+1] = headG * intensity;
      ca.array[idx*3+2] = headB * intensity;

      // Size: head is bigger, tail tapers
      sa.array[idx] = (0.3 + heat * 0.6) * trailFade * cl.brightness;
    }
  }

  pa.needsUpdate = true;
  ca.needsUpdate = true;
  sa.needsUpdate = true;
}

// ============================================================
// TIDAL DISRUPTION EVENT — click to spawn a star that gets shredded
// Star approaches on parabolic orbit, spaghettifies at tidal radius,
// debris streams around the black hole
// ============================================================
const TDE_N = 2500;
const tde = {
  active: false,
  phase: 0, // 0=inactive, 1=approaching, 2=disrupting, 3=streaming, 4=fading
  timer: 0,
  starPos: new THREE.Vector3(15, 2, 0),
  starVel: new THREE.Vector3(-0.5, -0.1, 0.3),
  particles: [],
  posAttr: null, colAttr: null, sizAttr: null, mat: null
};

(function(){
  const pos = new Float32Array(TDE_N * 3);
  const col = new Float32Array(TDE_N * 3);
  const siz = new Float32Array(TDE_N);

  for (let i = 0; i < TDE_N; i++) {
    tde.particles.push({
      x: 0, y: 0, z: 0,
      vx: 0, vy: 0, vz: 0,
      alive: false,
      life: 0,
      maxLife: 0,
      brightness: 0
    });
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));

  const glowTex = genSprite(64, 3.5, 1.0);
  tde.mat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPulse: { value: 0 }, uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC;
      uniform float uPulse;
      void main() {
        vC = color * (1.0 + uPulse * 0.4);
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (120.0 / -mv.z);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = mix(vec3(0.2,0.3,0.8), vec3(0.8,0.9,1.0), min(1.0, lum)) * lum * 2.0;
        } else if(uMode > 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = mix(vec3(0.5,0.1,0.0), vec3(1.0,0.8,0.2), min(1.0, lum)) * lum * 1.5;
        }
        gl_FragColor = vec4(c, a * 0.9);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });

  tde.posAttr = geo.attributes.position;
  tde.colAttr = geo.attributes.color;
  tde.sizAttr = geo.attributes.size;

  const points = new THREE.Points(geo, tde.mat);
  scene.add(points);
})();

function spawnTDE() {
  // Always allow re-triggering — just reset
  tde.active = true;
  tde.phase = 1;
  tde.timer = 0;

  // Random approach direction — always comes from outside
  const angle = Math.random() * Math.PI * 2;
  const elev = (Math.random() - 0.5) * 0.5;
  const dist = 14 + Math.random() * 4;
  tde.starPos.set(
    Math.cos(angle) * dist,
    elev * dist * 0.2,
    Math.sin(angle) * dist
  );

  // Velocity: strong angular momentum so debris ORBITS rather than plunging straight in
  const toCenter = new THREE.Vector3().sub(tde.starPos).normalize();
  const tangent = new THREE.Vector3(-toCenter.z, 0, toCenter.x);
  const speed = 0.055 + Math.random() * 0.015;
  tde.starVel.copy(toCenter).multiplyScalar(speed * 0.5);
  tde.starVel.addScaledVector(tangent, speed * 0.8); // more tangential = more orbit

  // Reset all particles — clump them at star position
  for (let i = 0; i < TDE_N; i++) {
    const p = tde.particles[i];
    // Tight Gaussian cluster for star shape
    const gr = () => (Math.random() + Math.random() + Math.random() - 1.5) * 0.12;
    p.x = tde.starPos.x + gr();
    p.y = tde.starPos.y + gr();
    p.z = tde.starPos.z + gr();
    p.vx = tde.starVel.x;
    p.vy = tde.starVel.y;
    p.vz = tde.starVel.z;
    p.alive = true;
    p.life = 0;
    p.maxLife = 800 + Math.random() * 600;
    p.brightness = 0.6 + Math.random() * 0.4;
  }

  // Play disruption sound
  if (audioCtx && masterGain) {
    const now = audioCtx.currentTime;
    // Rising pitch — approaching star
    const rise = audioCtx.createOscillator();
    rise.type = 'sine';
    rise.frequency.setValueAtTime(60, now);
    rise.frequency.exponentialRampToValueAtTime(300, now + 3);
    rise.frequency.exponentialRampToValueAtTime(40, now + 5);
    const riseGain = audioCtx.createGain();
    riseGain.gain.setValueAtTime(0.0, now);
    riseGain.gain.linearRampToValueAtTime(0.15, now + 1);
    riseGain.gain.linearRampToValueAtTime(0.25, now + 3);
    riseGain.gain.exponentialRampToValueAtTime(0.001, now + 6);
    rise.connect(riseGain);
    riseGain.connect(masterGain);
    rise.start(now);
    rise.stop(now + 6);

    // Tear sound — noise burst at disruption moment
    setTimeout(() => {
      if (!audioCtx) return;
      const now2 = audioCtx.currentTime;
      const tearBuf = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
      const td = tearBuf.getChannelData(0);
      for (let i = 0; i < td.length; i++) td[i] = (Math.random() * 2 - 1);
      const tear = audioCtx.createBufferSource();
      tear.buffer = tearBuf;
      const tearFilter = audioCtx.createBiquadFilter();
      tearFilter.type = 'bandpass';
      tearFilter.frequency.value = 200;
      tearFilter.Q.value = 1;
      const tearGain = audioCtx.createGain();
      tearGain.gain.setValueAtTime(0.2, now2);
      tearGain.gain.exponentialRampToValueAtTime(0.001, now2 + 2);
      tear.connect(tearFilter);
      tearFilter.connect(tearGain);
      tearGain.connect(masterGain);
      tear.start(now2);
    }, 2500);

    // Gravitational wave burst when star is disrupted
    setTimeout(() => { spawnGWave(1.2, 30, 0.2); }, 2500);
  }
}

function updateTDE(dt) {
  if (!tde.active) return;
  tde.timer += dt;

  const pa = tde.posAttr, ca = tde.colAttr, sa = tde.sizAttr;
  const RS = 1.0;
  const tidalRadius = 2.8; // where spaghettification begins
  let anyAlive = false;

  for (let i = 0; i < TDE_N; i++) {
    const p = tde.particles[i];
    if (!p.alive) {
      pa.array[i*3] = pa.array[i*3+1] = pa.array[i*3+2] = 0;
      ca.array[i*3] = ca.array[i*3+1] = ca.array[i*3+2] = 0;
      sa.array[i] = 0;
      continue;
    }

    p.life++;
    anyAlive = true;

    // Distance to BH
    const r = Math.sqrt(p.x * p.x + p.y * p.y + p.z * p.z);

    // Gravitational acceleration — tuned so debris orbits visibly before falling in
    const gStrength = 0.25 / (r * r);
    const ax = -p.x / r * gStrength;
    const ay = -p.y / r * gStrength;
    const az = -p.z / r * gStrength;

    // Tidal force: differential gravity stretches the star into a stream
    // Stronger effect for more dramatic spaghettification
    if (r < tidalRadius && r > RS * 0.8) {
      const tidalStrength = 0.0008 * Math.pow(tidalRadius / r, 3.5);
      const rx = p.x / r, ry = p.y / r, rz = p.z / r;
      // Stretch along radial direction
      p.vx += rx * tidalStrength * (1.0 + (Math.random() - 0.5) * 0.6);
      p.vy += ry * tidalStrength * (Math.random() - 0.5) * 0.4;
      p.vz += rz * tidalStrength * (1.0 + (Math.random() - 0.5) * 0.6);
      // Small perpendicular compression — squeeze into thin stream
      const px = p.y * rz - p.z * ry;
      const py = p.z * rx - p.x * rz;
      const pz = p.x * ry - p.y * rx;
      const pl = Math.sqrt(px*px + py*py + pz*pz) + 0.001;
      p.vx -= px / pl * tidalStrength * 0.15;
      p.vy -= py / pl * tidalStrength * 0.15;
      p.vz -= pz / pl * tidalStrength * 0.15;
    }

    // Light drag at very large radii to keep debris from escaping entirely
    if (r > 12) {
      const drag = 0.998;
      p.vx *= drag; p.vy *= drag; p.vz *= drag;
    }

    p.vx += ax;
    p.vy += ay;
    p.vz += az;

    p.x += p.vx;
    p.y += p.vy;
    p.z += p.vz;

    // Absorbed by black hole — only at very center
    if (r < RS * 0.5) {
      p.alive = false;
      continue;
    }

    // Fade over lifetime
    if (p.life > p.maxLife) {
      p.alive = false;
      continue;
    }

    // Color: starts white-blue (hot star), shifts to orange-red as debris
    const lifeFrac = p.life / p.maxLife;
    const fade = 1.0 - lifeFrac * lifeFrac;
    const proximity = Math.max(0, 1.0 - (r - 1.0) / 5.0); // brighter when close

    let cr, cg, cb;
    if (lifeFrac < 0.12) {
      // Intact star: bright white-blue
      cr = 0.95; cg = 0.95; cb = 1.0;
    } else if (lifeFrac < 0.35) {
      // Disruption: hot yellow-white, very bright
      const t = (lifeFrac - 0.12) / 0.23;
      cr = 1.0; cg = 0.95 - t * 0.2; cb = 0.9 - t * 0.45;
    } else {
      // Streaming debris: cools to orange-red
      const t = (lifeFrac - 0.35) / 0.65;
      cr = 1.0 - t * 0.2; cg = 0.75 - t * 0.4; cb = 0.45 - t * 0.35;
    }

    // Boost brightness when close to BH (heating from compression)
    const heatBoost = 1.0 + proximity * 0.8;
    const intensity = p.brightness * fade * heatBoost;
    pa.array[i*3]   = p.x;
    pa.array[i*3+1] = p.y;
    pa.array[i*3+2] = p.z;
    ca.array[i*3]   = cr * intensity;
    ca.array[i*3+1] = cg * intensity;
    ca.array[i*3+2] = cb * intensity;

    // Size: compact when star, larger as debris, extra large near BH
    const sizeBase = lifeFrac < 0.12 ? 0.2 : (0.2 + lifeFrac * 0.35 + proximity * 0.2);
    sa.array[i] = sizeBase * p.brightness * fade;
  }

  pa.needsUpdate = true;
  ca.needsUpdate = true;
  sa.needsUpdate = true;

  // Deactivate when all particles dead
  if (!anyAlive) {
    tde.active = false;
    tde.phase = 0;
  }
}

// ============================================================
// PARTICLE COLLISIONS — shockwaves, hot spots, impact sparks
// When matter streams (infall, TDE debris) cross the disk,
// they create expanding shockwave rings and bright impact flares.
// Disk turbulence also produces random hot spots (MRI-like).
// ============================================================
const MAX_SHOCKS = 24;
const shocks = [];
for (let i = 0; i < MAX_SHOCKS; i++) {
  shocks.push({ active: false, x: 0, z: 0, radius: 0, maxRadius: 0, intensity: 0, age: 0, speed: 0 });
}

function spawnShock(x, z, intensity, maxRadius, speed) {
  // Find inactive slot
  let slot = null;
  for (let i = 0; i < MAX_SHOCKS; i++) {
    if (!shocks[i].active) { slot = shocks[i]; break; }
  }
  if (!slot) {
    // Steal oldest
    let oldest = shocks[0];
    for (let i = 1; i < MAX_SHOCKS; i++) if (shocks[i].age > oldest.age) oldest = shocks[i];
    slot = oldest;
  }
  slot.active = true;
  slot.x = x;
  slot.z = z;
  slot.radius = 0.05;
  slot.maxRadius = maxRadius || 2.5;
  slot.intensity = intensity || 1.0;
  slot.age = 0;
  slot.speed = speed || 0.04;

  // Impact sound — short crackle
  if (audioCtx && masterGain && intensity > 0.5) {
    const now = audioCtx.currentTime;
    const click = audioCtx.createOscillator();
    click.type = 'square';
    click.frequency.setValueAtTime(150 + Math.random() * 200, now);
    click.frequency.exponentialRampToValueAtTime(30, now + 0.15);
    const cg = audioCtx.createGain();
    cg.gain.setValueAtTime(intensity * 0.06, now);
    cg.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    click.connect(cg);
    cg.connect(masterGain);
    click.start(now);
    click.stop(now + 0.2);
  }
}

// Spark particles — bright flashes at impact sites
const SPARK_N = 600;
const sparks = { particles: [], posAttr: null, colAttr: null, sizAttr: null, mat: null };

(function(){
  const pos = new Float32Array(SPARK_N * 3);
  const col = new Float32Array(SPARK_N * 3);
  const siz = new Float32Array(SPARK_N);
  for (let i = 0; i < SPARK_N; i++) {
    sparks.particles.push({ alive: false, x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, life: 0, maxLife: 0 });
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));
  const glowTex = genSprite(32, 5.0, 1.5);
  sparks.mat = new THREE.ShaderMaterial({
    uniforms: { uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC;
      void main() {
        vC = color;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (80.0 / -mv.z);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5) {
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(0.5,0.7,1.0) * lum * 2.5;
        } else if(uMode > 1.5) {
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(1.0,0.6,0.1) * lum * 2.0;
        }
        gl_FragColor = vec4(c, a);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });
  sparks.posAttr = geo.attributes.position;
  sparks.colAttr = geo.attributes.color;
  sparks.sizAttr = geo.attributes.size;
  const points = new THREE.Points(geo, sparks.mat);
  points.rotation.x = 0.08; points.rotation.z = 0.05; // match disk tilt
  scene.add(points);
})();

function spawnSparks(x, y, z, count, intensity) {
  let spawned = 0;
  for (let i = 0; i < SPARK_N && spawned < count; i++) {
    const p = sparks.particles[i];
    if (p.alive) continue;
    p.alive = true;
    p.x = x + (Math.random() - 0.5) * 0.1;
    p.y = y + (Math.random() - 0.5) * 0.1;
    p.z = z + (Math.random() - 0.5) * 0.1;
    // Radial burst velocity
    const angle = Math.random() * Math.PI * 2;
    const spd = 0.01 + Math.random() * 0.03 * intensity;
    p.vx = Math.cos(angle) * spd;
    p.vy = (Math.random() - 0.3) * spd * 0.8;
    p.vz = Math.sin(angle) * spd;
    p.life = 0;
    p.maxLife = 30 + Math.random() * 50;
    spawned++;
  }
}

function updateCollisions() {
  // 1. Update active shockwaves
  for (let i = 0; i < MAX_SHOCKS; i++) {
    const s = shocks[i];
    if (!s.active) continue;
    s.radius += s.speed;
    s.age++;
    s.intensity *= 0.985;
    if (s.radius > s.maxRadius || s.intensity < 0.01) {
      s.active = false;
    }
  }

  // 2. Check infall particles crossing inner disk — spawn impacts
  const infPA = infall.posAttr;
  if (infPA) {
    for (let c = 0; c < INFALL_CLUMPS; c++) {
      const headIdx = c * TRAIL_LEN;
      const x = infPA.array[headIdx * 3];
      const z = infPA.array[headIdx * 3 + 2];
      const y = infPA.array[headIdx * 3 + 1];
      const r = Math.sqrt(x * x + z * z);
      // Impact when infall clump is in the disk plane and at disk radius
      if (Math.abs(y) < 0.08 && r > rPlus * 1.2 && r < 4.0) {
        // Only trigger occasionally (not every frame)
        if (Math.random() < 0.008) {
          spawnShock(x, z, 0.6 + Math.random() * 0.4, 1.5 + Math.random(), 0.03);
          spawnSparks(x, y, z, 8 + Math.floor(Math.random() * 8), 1.0);
        }
      }
    }
  }

  // 3. Check TDE particles crossing disk plane — bigger impacts
  if (tde.active) {
    for (let i = 0; i < TDE_N; i += 25) { // sample every 25th for performance
      const p = tde.particles[i];
      if (!p.alive) continue;
      const r = Math.sqrt(p.x * p.x + p.z * p.z);
      if (Math.abs(p.y) < 0.1 && r > rPlus * 1.2 && r < 7.0) {
        if (Math.random() < 0.004) {
          spawnShock(p.x, p.z, 0.8 + Math.random() * 0.5, 2.0 + Math.random() * 1.5, 0.035);
          spawnSparks(p.x, p.y, p.z, 12 + Math.floor(Math.random() * 10), 1.5);
        }
      }
    }
  }

  // 4. Random MRI turbulence — spontaneous hot spots in the disk
  if (Math.random() < 0.003) {
    const r = 1.5 + Math.random() * 4.0;
    const angle = Math.random() * Math.PI * 2;
    spawnShock(Math.cos(angle) * r, Math.sin(angle) * r, 0.3 + Math.random() * 0.3, 1.0 + Math.random(), 0.025);
    if (Math.random() < 0.4) {
      const y = (Math.random() - 0.5) * 0.03;
      spawnSparks(Math.cos(angle) * r, y, Math.sin(angle) * r, 4 + Math.floor(Math.random() * 6), 0.6);
    }
  }

  // 5. Update spark particles
  const spa = sparks.posAttr, sca = sparks.colAttr, ssa = sparks.sizAttr;
  for (let i = 0; i < SPARK_N; i++) {
    const p = sparks.particles[i];
    if (!p.alive) {
      spa.array[i*3] = spa.array[i*3+1] = spa.array[i*3+2] = 0;
      sca.array[i*3] = sca.array[i*3+1] = sca.array[i*3+2] = 0;
      ssa.array[i] = 0;
      continue;
    }
    p.life++;
    if (p.life > p.maxLife) { p.alive = false; continue; }
    p.x += p.vx;
    p.y += p.vy;
    p.z += p.vz;
    p.vy *= 0.95; // damp vertical
    p.vx *= 0.98; p.vz *= 0.98;
    const fade = 1.0 - (p.life / p.maxLife);
    const flash = p.life < 5 ? 2.0 : 1.0; // initial flash
    spa.array[i*3] = p.x;
    spa.array[i*3+1] = p.y;
    spa.array[i*3+2] = p.z;
    // Hot white-yellow color
    sca.array[i*3]   = 1.0 * fade * flash;
    sca.array[i*3+1] = 0.9 * fade * flash;
    sca.array[i*3+2] = 0.5 * fade * flash;
    ssa.array[i] = (0.15 + Math.random() * 0.1) * fade;
  }
  spa.needsUpdate = true;
  sca.needsUpdate = true;
  ssa.needsUpdate = true;
}

// Get total shock brightness at a disk position (used in disk animation loop)
function getShockBrightness(x, z) {
  let bright = 0;
  for (let i = 0; i < MAX_SHOCKS; i++) {
    const s = shocks[i];
    if (!s.active) continue;
    const dx = x - s.x, dz = z - s.z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    // Ring brightness — peaks at the wavefront, falls off behind it
    const ringDist = Math.abs(dist - s.radius);
    const ringWidth = 0.15 + s.radius * 0.08;
    const ring = Math.exp(-ringDist * ringDist / (ringWidth * ringWidth));
    // Also some fill brightness inside the ring
    const fill = dist < s.radius ? Math.exp(-dist * 0.5) * 0.3 : 0;
    bright += (ring + fill) * s.intensity;
  }
  return Math.min(bright, 2.5);
}

// ============================================================
// HAWKING RADIATION — quantum particle pairs at the event horizon
// Virtual pairs form at the horizon; one escapes, one falls in.
// Faint flickering particles that drift outward and vanish.
// ============================================================
const HAWKING_N = 200;
const hawking = { posAttr: null, colAttr: null, sizAttr: null, particles: [] };

(function(){
  const pos = new Float32Array(HAWKING_N * 3);
  const col = new Float32Array(HAWKING_N * 3);
  const siz = new Float32Array(HAWKING_N);

  for (let i = 0; i < HAWKING_N; i++) {
    hawking.particles.push({
      alive: false, x: 0, y: 0, z: 0,
      vx: 0, vy: 0, vz: 0,
      life: 0, maxLife: 0, brightness: 0
    });
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));
  const glowTex = genSprite(32, 6.0, 2.0);
  hawking.mat = new THREE.ShaderMaterial({
    uniforms: { uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC;
      void main() {
        vC = color;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (60.0 / -mv.z);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5) {
          float lum = dot(c, vec3(0.33));
          c = vec3(0.6, 0.8, 1.0) * lum * 3.0;
        } else if(uMode > 1.5) {
          float lum = dot(c, vec3(0.33));
          c = vec3(lum * 0.5, lum * 0.2, lum * 0.05);
        }
        gl_FragColor = vec4(c, a * 0.7);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });

  hawking.posAttr = geo.attributes.position;
  hawking.colAttr = geo.attributes.color;
  hawking.sizAttr = geo.attributes.size;
  scene.add(new THREE.Points(geo, hawking.mat));
})();

function updateHawking(t) {
  // Spawn new pairs — rate inversely proportional to horizon size (smaller BH = more radiation)
  const spawnRate = 0.08 * (1.0 / (rPlus + 0.1));
  if (Math.random() < spawnRate) {
    // Find dead particle
    for (let i = 0; i < HAWKING_N; i++) {
      const p = hawking.particles[i];
      if (p.alive) continue;
      // Spawn on horizon surface
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2.0 * Math.random() - 1.0);
      const hR = rPlus * 1.02; // just outside horizon
      p.x = hR * Math.sin(phi) * Math.cos(theta);
      p.y = hR * Math.cos(phi);
      p.z = hR * Math.sin(phi) * Math.sin(theta);
      // Drift outward — the escaping particle
      const spd = 0.003 + Math.random() * 0.008;
      p.vx = p.x / hR * spd;
      p.vy = p.y / hR * spd;
      p.vz = p.z / hR * spd;
      // Add slight tangential drift
      p.vx += (Math.random() - 0.5) * 0.003;
      p.vy += (Math.random() - 0.5) * 0.003;
      p.vz += (Math.random() - 0.5) * 0.003;
      p.alive = true;
      p.life = 0;
      p.maxLife = 40 + Math.random() * 80;
      p.brightness = 0.3 + Math.random() * 0.7;
      break;
    }
  }

  const pa = hawking.posAttr, ca = hawking.colAttr, sa = hawking.sizAttr;
  for (let i = 0; i < HAWKING_N; i++) {
    const p = hawking.particles[i];
    if (!p.alive) {
      pa.array[i*3] = pa.array[i*3+1] = pa.array[i*3+2] = 0;
      ca.array[i*3] = ca.array[i*3+1] = ca.array[i*3+2] = 0;
      sa.array[i] = 0;
      continue;
    }
    p.life++;
    if (p.life > p.maxLife) { p.alive = false; continue; }

    p.x += p.vx;
    p.y += p.vy;
    p.z += p.vz;
    // Slight gravitational pull back
    const r = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);
    const pull = 0.0001 / (r * r);
    p.vx -= p.x / r * pull;
    p.vy -= p.y / r * pull;
    p.vz -= p.z / r * pull;

    const lifeFrac = p.life / p.maxLife;
    // Quick flash in, slow fade out
    const fade = lifeFrac < 0.1 ? lifeFrac / 0.1 : 1.0 - Math.pow((lifeFrac - 0.1) / 0.9, 2.0);
    // Quantum flicker — random intensity variation
    const flicker = 0.5 + 0.5 * Math.sin(t * 30.0 + i * 17.3) * Math.sin(t * 47.0 + i * 7.1);
    const bright = p.brightness * fade * flicker;

    pa.array[i*3] = p.x;
    pa.array[i*3+1] = p.y;
    pa.array[i*3+2] = p.z;
    // Color: thermal spectrum — Hawking temperature ∝ 1/M
    // Bluish-white for hotter (smaller) BH, reddish for larger
    const temp = 1.0 / (rPlus + 0.1);
    const tNorm = Math.min(1.0, temp * 0.8);
    ca.array[i*3]   = (0.6 + tNorm * 0.4) * bright;
    ca.array[i*3+1] = (0.6 + tNorm * 0.3) * bright;
    ca.array[i*3+2] = (0.8 + tNorm * 0.2) * bright;
    sa.array[i] = (0.08 + 0.06 * p.brightness) * fade;
  }
  pa.needsUpdate = true;
  ca.needsUpdate = true;
  sa.needsUpdate = true;
}

// ============================================================
// GRAVITATIONAL WAVE RIPPLES — spacetime distortion rings
// Triggered by TDE impacts and pulses. Expanding rings that
// subtly distort the starfield and brighten the disk.
// ============================================================
const MAX_GWAVES = 8;
const gwaves = [];
for (let i = 0; i < MAX_GWAVES; i++) {
  gwaves.push({ active: false, radius: 0, maxRadius: 0, amplitude: 0, age: 0, speed: 0 });
}

function spawnGWave(amplitude, maxRadius, speed) {
  let slot = null;
  for (let i = 0; i < MAX_GWAVES; i++) {
    if (!gwaves[i].active) { slot = gwaves[i]; break; }
  }
  if (!slot) {
    let oldest = gwaves[0];
    for (let i = 1; i < MAX_GWAVES; i++) if (gwaves[i].age > oldest.age) oldest = gwaves[i];
    slot = oldest;
  }
  slot.active = true;
  slot.radius = 0.1;
  slot.maxRadius = maxRadius || 20.0;
  slot.amplitude = amplitude || 1.0;
  slot.age = 0;
  slot.speed = speed || 0.15; // fast — gravitational waves travel at c

  // Low rumble sound
  if (audioCtx && masterGain && amplitude > 0.3) {
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    o.type = 'sine';
    o.frequency.setValueAtTime(25, now);
    o.frequency.exponentialRampToValueAtTime(12, now + 1.5);
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(amplitude * 0.08, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
    o.connect(g); g.connect(masterGain);
    o.start(now); o.stop(now + 2.0);
  }
}

function updateGWaves() {
  for (let i = 0; i < MAX_GWAVES; i++) {
    const w = gwaves[i];
    if (!w.active) continue;
    w.radius += w.speed;
    w.age++;
    w.amplitude *= 0.993;
    if (w.radius > w.maxRadius || w.amplitude < 0.005) {
      w.active = false;
    }
  }
}

// Returns displacement amount for gravitational wave distortion at a given 3D radius from BH
function getGWaveDisplacement(r3d) {
  let disp = 0;
  for (let i = 0; i < MAX_GWAVES; i++) {
    const w = gwaves[i];
    if (!w.active) continue;
    const ringDist = Math.abs(r3d - w.radius);
    const width = 0.4 + w.radius * 0.05;
    disp += Math.sin(ringDist / width * Math.PI * 2.0) * Math.exp(-ringDist * ringDist / (width * width)) * w.amplitude;
  }
  return disp;
}

// ============================================================
// COMPOSITE + BLOOM SHADERS
// ============================================================

// Gravitational lensing distortion for starfield
const lensMat=new THREE.ShaderMaterial({
  uniforms:{
    tStars:{value:null},
    uBHScreen:{value:new THREE.Vector2(0.5,0.5)}, // BH center in screen UV
    uBHRadius:{value:0.1}, // apparent angular radius of shadow in screen units
    uStrength:{value:1.5},
    uCompScreen0:{value:new THREE.Vector3(0,0,0)}, // xy=screen pos, z=screen radius
    uCompScreen1:{value:new THREE.Vector3(0,0,0)},
    uCompScreen2:{value:new THREE.Vector3(0,0,0)},
    uCompScreen3:{value:new THREE.Vector3(0,0,0)}
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform sampler2D tStars;
    uniform vec2 uBHScreen;
    uniform float uBHRadius, uStrength;
    uniform vec3 uCompScreen0, uCompScreen1, uCompScreen2, uCompScreen3;
    varying vec2 vUv;

    vec3 lensOneBH(vec2 uv, vec2 bhPos, float bhR, float str) {
      vec2 delta = uv - bhPos;
      float dist = length(delta);
      vec2 dir = delta / max(dist, 0.0001);
      float photonR = bhR * 1.5;
      if(dist < bhR * 0.85) return vec3(-1.0); // inside shadow
      float deflection = str * bhR * bhR / (dist * dist + bhR * 0.1);
      float photonProx = exp(-pow(dist - photonR, 2.0) / (bhR * bhR * 0.15));
      deflection += photonProx * bhR * 0.3;
      return vec3(dir * deflection, 1.0 + photonProx * 3.0);
    }

    void main(){
      // Primary BH
      vec2 delta0 = vUv - uBHScreen;
      float dist0 = length(delta0);
      if(dist0 < uBHRadius * 0.85){
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); return;
      }

      // Accumulate lensing from all BHs
      vec2 totalDeflect = vec2(0.0);
      float totalAmp = 1.0;
      bool inShadow = false;

      // Primary
      vec3 l0 = lensOneBH(vUv, uBHScreen, uBHRadius, uStrength);
      if(l0.x < -0.5) { inShadow = true; }
      else { totalDeflect += l0.xy; totalAmp *= l0.z; }

      // Companions
      vec3 comps[4];
      comps[0]=uCompScreen0; comps[1]=uCompScreen1; comps[2]=uCompScreen2; comps[3]=uCompScreen3;
      for(int i=0;i<4;i++){
        if(comps[i].z < 0.001) continue;
        vec2 cDelta = vUv - comps[i].xy;
        if(length(cDelta) < comps[i].z * 0.85) { inShadow = true; break; }
        vec3 cl = lensOneBH(vUv, comps[i].xy, comps[i].z, uStrength * 0.8);
        if(cl.x > -0.5) { totalDeflect += cl.xy; totalAmp *= cl.z; }
      }

      if(inShadow) { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); return; }

      vec2 lensedUV = clamp(vUv + totalDeflect, 0.0, 1.0);
      vec3 col = texture2D(tStars, lensedUV).rgb * totalAmp;
      gl_FragColor = vec4(col, 1.0);
    }
  `
});

// Combine BG + particles
const combineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec4 fg=texture2D(tParticles,vUv);
      // Particles use additive blending on black, so just add them to background
      // But where the void sphere rendered black, suppress the background too
      // Detect void: if particle pass is pure black AND we expect the void there
      float fgBright=dot(fg.rgb,vec3(1.0));
      // Use a mask: areas that rendered to exactly 0 might be void or empty space
      // We differentiate by checking if depth would have been written (void sphere)
      // Simple approach: if fg is very dark, show bg; if fg has content, add it
      vec3 col=bg+fg.rgb;
      gl_FragColor=vec4(col,1.0);
    }`
});

// But we need the void sphere to BLOCK the background stars behind it.
// Problem: with additive particle blending, the void renders as black (adds nothing).
// Solution: render the void sphere separately to a mask, or use a different approach.

// Better approach: render void sphere to write a mask in alpha channel
// Actually, simplest: render the particle scene with the void sphere writing alpha=1 black,
// then composite properly.

// Let me use a two-step approach for the particle scene:
// The void sphere renders with depthWrite=true and outputs black.
// Particles render on top with additive blending.
// If we render particles to a texture, void areas = black, space areas = black, particle areas = bright.
// We can't distinguish void from empty space...

// SOLUTION: Render a void-only pass to get a silhouette mask.
const voidMaskMat=new THREE.ShaderMaterial({
  uniforms:{uCamPos:{value:new THREE.Vector3()},uRes:{value:new THREE.Vector2()},uFov:{value:FOV_MULT},uRPlus:{value:rPlus},
    uComp0:{value:new THREE.Vector4(0,0,0,0)},uComp1:{value:new THREE.Vector4(0,0,0,0)},
    uComp2:{value:new THREE.Vector4(0,0,0,0)},uComp3:{value:new THREE.Vector4(0,0,0,0)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform vec3 uCamPos;uniform vec2 uRes;uniform float uFov,uRPlus;varying vec2 vUv;
    uniform vec4 uComp0,uComp1,uComp2,uComp3; // xyz=position, w=radius
    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}
    float sphereHit(vec3 ro,vec3 rd,vec3 center,float radius){
      vec3 oc=ro-center;
      float b=dot(oc,rd); float c=dot(oc,oc)-radius*radius;
      float d=b*b-c; return d>0.0?1.0:0.0;
    }
    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));
      // Primary BH at origin
      float mask=sphereHit(uCamPos,rd,vec3(0.0),uRPlus);
      // Companion BHs
      vec4 comps[4]; comps[0]=uComp0; comps[1]=uComp1; comps[2]=uComp2; comps[3]=uComp3;
      for(int i=0;i<4;i++){
        if(comps[i].w>0.01) mask=max(mask,sphereHit(uCamPos,rd,comps[i].xyz,comps[i].w));
      }
      gl_FragColor=vec4(vec3(mask),1.0);
    }`
});

// Final combine: (lensedStars + BG glow) * (1-voidMask) + particles
const finalCombineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null},tMask:{value:null},tStarsLensed:{value:null},uLensMode:{value:1}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles,tMask,tStarsLensed;uniform float uLensMode;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec3 fg=texture2D(tParticles,vUv).rgb;
      float mask=texture2D(tMask,vUv).r;
      if(uLensMode>0.5){
        // Geodesic mode: bg already has lensed stars + shadow
        // Only mask the particle layer
        vec3 col=bg+fg*(1.0-mask*0.85);
        gl_FragColor=vec4(col,1.0);
      } else {
        // Classic mode: separate star + bg layers
        vec3 stars=texture2D(tStarsLensed,vUv).rgb;
        vec3 col=(stars+bg)*(1.0-mask)+fg;
        gl_FragColor=vec4(col,1.0);
      }
    }`
});

// Bloom threshold
const threshMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uThreshold:{value:0.28}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform float uThreshold;varying vec2 vUv;
    void main(){vec4 c=texture2D(tDiffuse,vUv);float b=dot(c.rgb,vec3(0.2126,0.7152,0.0722));
      gl_FragColor=b>uThreshold?c*smoothstep(uThreshold,uThreshold+0.4,b):vec4(0.0);}`
});
function mkBlur(h){return new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.5,window.innerHeight*0.5)},
    uDir:{value:h?new THREE.Vector2(1,0):new THREE.Vector2(0,1)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes,uDir;varying vec2 vUv;
    void main(){vec2 tx=uDir/uRes;vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv-tx*4.0)*0.0162;r+=texture2D(tDiffuse,vUv-tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv-tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv-tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv)*0.2270;r+=texture2D(tDiffuse,vUv+tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv+tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv+tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv+tx*4.0)*0.0162;gl_FragColor=r;}`});}
const blurH=mkBlur(true),blurV=mkBlur(false);

// Anamorphic streak — ultra-wide horizontal blur (13-tap, very spread)
const streakBlurMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.25,window.innerHeight*0.25)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes;varying vec2 vUv;
    void main(){
      float tx=1.0/uRes.x*3.0; // 3x spread for very wide streaks
      vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv+vec2(-6.0*tx,0))*0.012;
      r+=texture2D(tDiffuse,vUv+vec2(-5.0*tx,0))*0.025;
      r+=texture2D(tDiffuse,vUv+vec2(-4.0*tx,0))*0.045;
      r+=texture2D(tDiffuse,vUv+vec2(-3.0*tx,0))*0.075;
      r+=texture2D(tDiffuse,vUv+vec2(-2.0*tx,0))*0.105;
      r+=texture2D(tDiffuse,vUv+vec2(-1.0*tx,0))*0.135;
      r+=texture2D(tDiffuse,vUv)*0.155;
      r+=texture2D(tDiffuse,vUv+vec2(1.0*tx,0))*0.135;
      r+=texture2D(tDiffuse,vUv+vec2(2.0*tx,0))*0.105;
      r+=texture2D(tDiffuse,vUv+vec2(3.0*tx,0))*0.075;
      r+=texture2D(tDiffuse,vUv+vec2(4.0*tx,0))*0.045;
      r+=texture2D(tDiffuse,vUv+vec2(5.0*tx,0))*0.025;
      r+=texture2D(tDiffuse,vUv+vec2(6.0*tx,0))*0.012;
      // Slightly warm tint for cinematic look
      r.rgb*=vec3(1.0,0.95,0.85);
      gl_FragColor=r;
    }`
});

// Final output with bloom
const compositeMat=new THREE.ShaderMaterial({
  uniforms:{tScene:{value:null},tBloom:{value:null},tStreak:{value:null},uBloomStr:{value:1.5},uTime:{value:0},uMode:{value:0},
    uGWave0:{value:new THREE.Vector3(0,0,0)},uGWave1:{value:new THREE.Vector3(0,0,0)},uGWave2:{value:new THREE.Vector3(0,0,0)},uGWave3:{value:new THREE.Vector3(0,0,0)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tScene,tBloom,tStreak;uniform float uBloomStr,uTime,uMode;varying vec2 vUv;
    uniform vec3 uGWave0,uGWave1,uGWave2,uGWave3; // x=radius, y=amplitude, z=active
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      // Gravitational wave screen-space distortion
      vec2 center=vec2(0.5);
      vec2 uv=vUv;
      vec3 gw[4];
      gw[0]=uGWave0; gw[1]=uGWave1; gw[2]=uGWave2; gw[3]=uGWave3;
      for(int i=0;i<4;i++){
        if(gw[i].z<0.5) continue;
        float r=gw[i].x; float amp=gw[i].y;
        float dist=length(uv-center)*2.0; // 0 at center, ~1 at edges
        float ringDist=abs(dist-r*0.06);
        float width=0.02+r*0.003;
        float wave=sin(ringDist/width*6.28)*exp(-ringDist*ringDist/(width*width))*amp;
        vec2 dir=normalize(uv-center+0.001);
        uv+=dir*wave*0.008;
      }
      vec3 sc=texture2D(tScene,uv).rgb,bl=texture2D(tBloom,uv).rgb;
      vec3 streak=texture2D(tStreak,uv).rgb;
      vec3 col=sc+bl*uBloomStr+streak*0.6;
      float d=length(vUv-0.5),ca=d*d*0.004;
      col.r+=texture2D(tBloom,uv+vec2(ca)).r*uBloomStr*0.18;
      col.b+=texture2D(tBloom,uv-vec2(ca)).b*uBloomStr*0.18;
      // Mode-dependent overall tint
      if(uMode>0.5&&uMode<1.5){
        // X-RAY: cool blue tint, higher contrast
        col=col*vec3(0.7,0.85,1.2);
        col=pow(col,vec3(1.1)); // slightly more contrast
      } else if(uMode>1.5){
        // RADIO: warm tint, false color feel
        col=col*vec3(1.1,0.9,0.7);
      }
      col*=1.0-d*0.6;
      col+=(hash(vUv*800.0+fract(uTime))-0.5)*0.02;
      gl_FragColor=vec4(col,1.0);}`
});

// Fullscreen quad + scene for post-processing
const postScene=new THREE.Scene();
const postQuad=new THREE.Mesh(fsGeo.clone(),compositeMat);
postScene.add(postQuad);

let rtMask=makeRT(1);

// ============================================================
// CAMERA
// ============================================================
let isDragging=false,prevMouse={x:0,y:0};
let sph={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let tgt={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let pulse=0;

function pD(x,y){if(document.getElementById('infopanel').classList.contains('open'))return;isDragging=true;prevMouse={x,y};}
function pM(x,y){if(!isDragging)return;
  tgt.theta-=(x-prevMouse.x)*0.004;
  tgt.phi=Math.max(0.2,Math.min(Math.PI-0.2,tgt.phi-(y-prevMouse.y)*0.004));
  prevMouse={x,y};}
function pU(){isDragging=false;}
document.addEventListener('mousedown',e=>pD(e.clientX,e.clientY));
document.addEventListener('mousemove',e=>pM(e.clientX,e.clientY));
document.addEventListener('mouseup',pU);
document.addEventListener('touchstart',e=>{e.preventDefault();pD(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchmove',e=>{e.preventDefault();pM(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchend',pU);
document.addEventListener('wheel',e=>{
  if(document.getElementById('infopanel').classList.contains('open')) return;
  if(e.target.id==='spinslider') return;
  tgt.radius=Math.max(2.5,Math.min(25,tgt.radius+e.deltaY*0.008));
},{passive:true});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'){e.preventDefault();pulse=1.0;triggerPulseSound();spawnGWave(0.8, 25, 0.18);}
  if(e.key==='1') setWaveMode(0);
  if(e.key==='2') setWaveMode(1);
  if(e.key==='3') setWaveMode(2);
  if(e.key==='i'||e.key==='I') toggleInfo();
  if(e.key==='t'||e.key==='T') spawnTDE();
  if(e.key==='b'||e.key==='B') addCompanion();
  if(e.key==='l'||e.key==='L'){
    lensMode=1-lensMode;
    bgMat.uniforms.uLensMode.value=lensMode;
    finalCombineMat.uniforms.uLensMode.value=lensMode;
    const badge=document.getElementById('lensmodebadge');
    if(badge) badge.textContent=lensMode?'GEODESIC LENSING':'CLASSIC LENSING';
  }
});

document.addEventListener('dblclick',e=>{
  if(document.getElementById('infopanel').classList.contains('open')) return;
  spawnTDE();
});

function toggleInfo(){
  const panel=document.getElementById('infopanel');
  const btn=document.getElementById('infobtn');
  panel.classList.toggle('open');
  btn.classList.toggle('active');
}

// Click outside info panel to close
document.addEventListener('mousedown',e=>{
  const panel=document.getElementById('infopanel');
  if(!panel.classList.contains('open')) return;
  // If click is outside panel and not on the info button, close
  if(!panel.contains(e.target) && e.target.id!=='infobtn'){
    toggleInfo();
  }
});

let waveMode=0;
let lensMode=1; // 0=classic (screen-space), 1=geodesic (ray-traced)
function setWaveMode(m){
  waveMode=m;
  document.querySelectorAll('#wavemode button').forEach((btn,i)=>{
    btn.classList.toggle('active',i===m);
  });
  [disk.mat,jetUp.mat,jetDown.mat,infall.mat,tde.mat,sparks.mat,hawking.mat].forEach(mat=>{
    if(mat.uniforms.uMode) mat.uniforms.uMode.value=m;
  });
  compositeMat.uniforms.uMode.value=m;
  bgMat.uniforms.uMode.value=m;
  starsMat.uniforms.uMode.value=m;
}

function setSpinA(a) {
  spinA = Math.max(0, Math.min(0.998, a));
  rPlus = kerrEventHorizon(spinA);
  isco = kerrISCO(spinA);
  document.getElementById('spinval').textContent = 'a* = ' + spinA.toFixed(3);
  // Update disk inner edge uniform
  if(disk.mat && disk.mat.uniforms.uISCO) disk.mat.uniforms.uISCO.value = isco.prograde;
}

// ============================================================
// SOUND DESIGN — Web Audio API
// Deep space ambient drone, proximity rumble, pulse FX
// Initialized on first user interaction (autoplay policy)
// ============================================================
let audioCtx=null, audioInitialized=false;
let droneGain,rumbleGain,masterGain;
let droneOscs=[],rumbleOsc,rumbleLFO;

function initAudio(){
  if(audioInitialized) return;
  audioInitialized=true;

  audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  const now=audioCtx.currentTime;

  masterGain=audioCtx.createGain();
  masterGain.gain.value=0;
  masterGain.connect(audioCtx.destination);
  // Fade in over 3 seconds
  masterGain.gain.linearRampToValueAtTime(0.6, now+3);

  // === AMBIENT DRONE ===
  // Multiple detuned oscillators for rich, evolving texture
  droneGain=audioCtx.createGain();
  droneGain.gain.value=0.12;
  droneGain.connect(masterGain);

  // Low foundation — deep Bb
  const droneFreqs=[29.14, 29.14*1.002, 29.14*0.998]; // Bb0 with slight detune
  droneFreqs.forEach((freq,i)=>{
    const osc=audioCtx.createOscillator();
    osc.type='sine';
    osc.frequency.value=freq;
    const g=audioCtx.createGain();
    g.gain.value=0.35;
    osc.connect(g);
    g.connect(droneGain);
    osc.start();
    droneOscs.push({osc,gain:g});
  });

  // Mid harmonic layer — fifth above, filtered
  const midFreqs=[43.65, 43.65*1.003]; // F1
  midFreqs.forEach(freq=>{
    const osc=audioCtx.createOscillator();
    osc.type='triangle';
    osc.frequency.value=freq;
    const filter=audioCtx.createBiquadFilter();
    filter.type='lowpass';
    filter.frequency.value=120;
    filter.Q.value=2;
    const g=audioCtx.createGain();
    g.gain.value=0.2;
    osc.connect(filter);
    filter.connect(g);
    g.connect(droneGain);
    osc.start();
    droneOscs.push({osc,gain:g,filter});
  });

  // High ethereal whisper — very quiet, evolving
  const highOsc=audioCtx.createOscillator();
  highOsc.type='sine';
  highOsc.frequency.value=174.6; // F3
  const highFilter=audioCtx.createBiquadFilter();
  highFilter.type='bandpass';
  highFilter.frequency.value=175;
  highFilter.Q.value=15;
  const highGain=audioCtx.createGain();
  highGain.gain.value=0.03;
  highOsc.connect(highFilter);
  highFilter.connect(highGain);
  highGain.connect(droneGain);
  highOsc.start();
  droneOscs.push({osc:highOsc,gain:highGain,filter:highFilter});

  // LFO to modulate drone volume — slow breathing
  const droneLFO=audioCtx.createOscillator();
  droneLFO.type='sine';
  droneLFO.frequency.value=0.06; // ~16 second cycle
  const lfoGain=audioCtx.createGain();
  lfoGain.gain.value=0.03;
  droneLFO.connect(lfoGain);
  lfoGain.connect(droneGain.gain);
  droneLFO.start();

  // === PROXIMITY RUMBLE ===
  // Low freq noise that intensifies as camera approaches
  rumbleGain=audioCtx.createGain();
  rumbleGain.gain.value=0;
  rumbleGain.connect(masterGain);

  rumbleOsc=audioCtx.createOscillator();
  rumbleOsc.type='sawtooth';
  rumbleOsc.frequency.value=22;
  const rumbleFilter=audioCtx.createBiquadFilter();
  rumbleFilter.type='lowpass';
  rumbleFilter.frequency.value=60;
  rumbleFilter.Q.value=3;
  rumbleOsc.connect(rumbleFilter);
  rumbleFilter.connect(rumbleGain);
  rumbleOsc.start();

  // Rumble LFO — menacing throb
  rumbleLFO=audioCtx.createOscillator();
  rumbleLFO.type='sine';
  rumbleLFO.frequency.value=0.3;
  const rumbleLFOGain=audioCtx.createGain();
  rumbleLFOGain.gain.value=0.05;
  rumbleLFO.connect(rumbleLFOGain);
  rumbleLFOGain.connect(rumbleGain.gain);
  rumbleLFO.start();

  // === NOISE LAYER ===
  // Filtered white noise for texture — like radiation hiss
  const bufferSize=audioCtx.sampleRate*2;
  const noiseBuffer=audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
  const data=noiseBuffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i]=(Math.random()*2-1);
  const noiseNode=audioCtx.createBufferSource();
  noiseNode.buffer=noiseBuffer;
  noiseNode.loop=true;
  const noiseFilter=audioCtx.createBiquadFilter();
  noiseFilter.type='bandpass';
  noiseFilter.frequency.value=80;
  noiseFilter.Q.value=0.5;
  const noiseGain=audioCtx.createGain();
  noiseGain.gain.value=0.015;
  noiseNode.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(masterGain);
  noiseNode.start();

  // Store refs for proximity updates
  window._audioRefs={rumbleGain,rumbleFilter:rumbleFilter,noiseFilter,noiseGain,droneGain,masterGain,highGain};
}

function triggerPulseSound(){
  if(!audioCtx) return;
  const now=audioCtx.currentTime;

  // Deep impact — sub bass hit
  const impact=audioCtx.createOscillator();
  impact.type='sine';
  impact.frequency.setValueAtTime(80,now);
  impact.frequency.exponentialRampToValueAtTime(20,now+1.5);
  const impactGain=audioCtx.createGain();
  impactGain.gain.setValueAtTime(0.4,now);
  impactGain.gain.exponentialRampToValueAtTime(0.001,now+2);
  impact.connect(impactGain);
  impactGain.connect(masterGain);
  impact.start(now);
  impact.stop(now+2);

  // High shimmer — metallic ring
  const shimmer=audioCtx.createOscillator();
  shimmer.type='sine';
  shimmer.frequency.value=1200;
  const shimFilter=audioCtx.createBiquadFilter();
  shimFilter.type='bandpass';
  shimFilter.frequency.value=1200;
  shimFilter.Q.value=20;
  const shimGain=audioCtx.createGain();
  shimGain.gain.setValueAtTime(0.06,now);
  shimGain.gain.exponentialRampToValueAtTime(0.001,now+3);
  shimmer.connect(shimFilter);
  shimFilter.connect(shimGain);
  shimGain.connect(masterGain);
  shimmer.start(now);
  shimmer.stop(now+3);

  // Noise burst — whoosh
  const burstSize=audioCtx.sampleRate;
  const burstBuf=audioCtx.createBuffer(1,burstSize,audioCtx.sampleRate);
  const bd=burstBuf.getChannelData(0);
  for(let i=0;i<burstSize;i++) bd[i]=(Math.random()*2-1);
  const burst=audioCtx.createBufferSource();
  burst.buffer=burstBuf;
  const burstFilter=audioCtx.createBiquadFilter();
  burstFilter.type='lowpass';
  burstFilter.frequency.setValueAtTime(3000,now);
  burstFilter.frequency.exponentialRampToValueAtTime(100,now+1.5);
  const burstGain=audioCtx.createGain();
  burstGain.gain.setValueAtTime(0.15,now);
  burstGain.gain.exponentialRampToValueAtTime(0.001,now+1.5);
  burst.connect(burstFilter);
  burstFilter.connect(burstGain);
  burstGain.connect(masterGain);
  burst.start(now);

  // Momentary drone swell
  if(window._audioRefs){
    window._audioRefs.droneGain.gain.setValueAtTime(0.25,now);
    window._audioRefs.droneGain.gain.linearRampToValueAtTime(0.12,now+2);
  }
}

function updateAudio(){
  if(!window._audioRefs) return;
  const refs=window._audioRefs;
  const dist=sph.radius;

  // Proximity rumble: louder as camera gets closer
  // Range: radius 2.5 (max rumble) to 15 (silent)
  const proximity=Math.max(0,1.0-(dist-2.5)/12.5);
  const rumbleVol=proximity*proximity*0.15;
  refs.rumbleGain.gain.linearRampToValueAtTime(rumbleVol,audioCtx.currentTime+0.1);

  // Noise filter opens up when closer
  refs.noiseFilter.frequency.linearRampToValueAtTime(60+proximity*200,audioCtx.currentTime+0.1);
  refs.noiseGain.gain.linearRampToValueAtTime(0.01+proximity*0.03,audioCtx.currentTime+0.1);

  // High harmonic gets louder at medium distance (sweet spot)
  const midProx=Math.exp(-Math.pow(dist-6,2)*0.05);
  refs.highGain.gain.linearRampToValueAtTime(0.02+midProx*0.04,audioCtx.currentTime+0.1);
}

// Init audio on first interaction
['mousedown','touchstart','keydown'].forEach(evt=>{
  document.addEventListener(evt,initAudio,{once:false});
});

// ============================================================
// ANIMATION
// ============================================================
const clock=new THREE.Clock();
const timeMats=[disk.mat,jetUp.mat,jetDown.mat,dustMat,infall.mat,starsMat,tde.mat];

function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();

  sph.theta+=(tgt.theta-sph.theta)*0.05;
  sph.phi+=(tgt.phi-sph.phi)*0.05;
  sph.radius+=(tgt.radius-sph.radius)*0.05;
  if(!isDragging) tgt.theta+=0.0003;

  camera.position.set(
    sph.radius*Math.sin(sph.phi)*Math.sin(sph.theta),
    sph.radius*Math.cos(sph.phi),
    sph.radius*Math.sin(sph.phi)*Math.cos(sph.theta)
  );
  camera.lookAt(0,0,0);
  pulse*=0.94;
  updateAudio();

  timeMats.forEach(m=>{
    if(m.uniforms.uTime)m.uniforms.uTime.value=t;
    if(m.uniforms.uPulse)m.uniforms.uPulse.value=pulse;
  });

  // Update disk
  const pa=disk.posAttr,ca=disk.colAttr,sa=disk.sizAttr,bc=disk.baseColors,bs=disk.baseSizes;
  const camA=Math.atan2(camera.position.x,camera.position.z);
  const curISCO = isco.prograde;
  for(let i=0;i<DISK_N;i++){
    const r=disk.radii[i];
    // Frame dragging — amplified for visibility
    const frameDrag=kerrFrameDrag(spinA,r)*3.0;
    disk.angles[i]+=(disk.velocities[i]+frameDrag)*0.004;
    const a=disk.angles[i];
    let px=Math.cos(a)*r;
    let pz=Math.sin(a)*r;
    // Companion BH gravitational perturbation
    if (companions.length > 0) {
      const cg = getCompanionGravity(px, pz);
      // Convert acceleration to angular perturbation
      const tangentX = -Math.sin(a), tangentZ = Math.cos(a);
      const tangentForce = cg.ax * tangentX + cg.az * tangentZ;
      disk.angles[i] += tangentForce * 0.002;
      // Radial perturbation — slight wobble
      const radialForce = cg.ax * Math.cos(a) + cg.az * Math.sin(a);
      px += cg.ax * 0.15;
      pz += cg.az * 0.15;
    }
    pa.array[i*3]=px;
    pa.array[i*3+2]=pz;
    // Gravitational wave ripple — displaces particles perpendicular to disk
    const r3d = r; // approximate 3D distance
    const gwDisp = getGWaveDisplacement(r3d);
    pa.array[i*3+1] = pa.array[i*3+1] + gwDisp * 0.08;

    // Particles inside ISCO: fade out (unstable plunging orbits)
    // Particles inside event horizon: completely hidden
    let visibility = 1.0;
    if(r < rPlus * 1.05) {
      visibility = 0.0;
    } else if(r < curISCO) {
      // Fade zone: particles exist but are unstable, dim them significantly
      const f = (r - rPlus * 1.05) / (curISCO - rPlus * 1.05);
      visibility = f * f * 0.3; // very dim inside ISCO
    }

    // Update size based on visibility
    sa.array[i] = bs[i] * visibility;

    // Shockwave brightness boost
    const sx = pa.array[i*3], sz = pa.array[i*3+2];
    const shockBoost = getShockBrightness(sx, sz);

    // Doppler beaming
    const dop=0.5+0.6*Math.cos(a-camA);
    const df=0.5+dop*0.55;
    // Gravitational redshift — Kerr-corrected
    const redshiftFactor = kerrTimeDilation(spinA, r);
    const rShift = 1.0 - (1.0 - redshiftFactor) * 0.3;
    const gShift = redshiftFactor * 0.85 + 0.15;
    const bShift = redshiftFactor * redshiftFactor;
    const totalBright = (1.0 + shockBoost * 1.5);
    ca.array[i*3]  =bc[i*3]  *df*rShift*visibility*totalBright;
    ca.array[i*3+1]=bc[i*3+1]*df*gShift*visibility*totalBright;
    ca.array[i*3+2]=bc[i*3+2]*df*bShift*visibility*totalBright;
    // Shock makes particles bigger too
    if(shockBoost > 0.1) sa.array[i] *= (1.0 + shockBoost * 0.5);
  }
  pa.needsUpdate=true;ca.needsUpdate=true;sa.needsUpdate=true;

  // Update infall particles
  updateInfall(t);

  // Update tidal disruption event
  updateTDE(1.0);

  // Update collisions, shockwaves, sparks
  updateCollisions();

  // Update Hawking radiation
  updateHawking(t);

  // Update gravitational wave ripples
  updateGWaves();

  // Update companion black holes (N-body)
  updateCompanions(1.0);

  // Update time dilation HUD (Kerr-corrected)
  {
    const camR = sph.radius;
    const camDilation = kerrTimeDilation(spinA, camR);
    document.getElementById('td-cam').style.width = (camDilation * 100) + '%';
    document.getElementById('td-cam-val').textContent = camDilation.toFixed(3);

    // Update ISCO label and value dynamically
    const iscoD = kerrTimeDilation(spinA, isco.prograde);
    const innerD = kerrTimeDilation(spinA, rPlus * 2.0);
    const outerD = kerrTimeDilation(spinA, 7.5 * M_BH * 2);

    // Update bar widths and values
    const tdIsco=document.getElementById('td-isco');
    const tdInner=document.getElementById('td-inner');
    const tdOuter=document.getElementById('td-outer');
    if(tdIsco){tdIsco.style.width=(iscoD*100)+'%';}
    if(tdInner){tdInner.style.width=(innerD*100)+'%';}
    if(tdOuter){tdOuter.style.width=(outerD*100)+'%';}
    // Update value text
    const valEls=document.querySelectorAll('#timedilation .td-val');
    if(valEls[1]) valEls[1].textContent=iscoD.toFixed(3);
    if(valEls[2]) valEls[2].textContent=innerD.toFixed(3);
    if(valEls[3]) valEls[3].textContent=outerD.toFixed(3);
    // Update ISCO label
    const lblEls=document.querySelectorAll('#timedilation .td-label');
    if(lblEls[1]) lblEls[1].textContent='ISCO ('+isco.prograde.toFixed(1)+' r)';

    // Animate clock dots
    const rates = [
      { id: 'tc-eh',    factor: 0.001, color: '#f44' },
      { id: 'tc-isco',  factor: iscoD, color: '#fa4' },
      { id: 'tc-inner', factor: innerD, color: '#fb4' },
      { id: 'tc-outer', factor: outerD, color: '#be5' },
      { id: 'tc-cam',   factor: camDilation, color: '#fc8' },
      { id: 'tc-inf',   factor: 1.0,   color: '#8d8' }
    ];
    for (const r of rates) {
      const el = document.getElementById(r.id);
      if (!el) continue;
      const tickPhase = Math.sin(t * Math.PI * 2.0 * r.factor);
      const isOn = tickPhase > 0.3;
      el.textContent = isOn ? '●' : '○';
      el.style.color = r.color;
      el.style.opacity = isOn ? 1.0 : 0.25;
    }
  }

  // Update BG shader camera + Kerr params
  bgMat.uniforms.uCamPos.value.copy(camera.position);
  bgMat.uniforms.uTime.value=t;
  bgMat.uniforms.uRPlus.value=rPlus;
  bgMat.uniforms.uSpinA.value=spinA;

  // Update void sphere size and ergosphere
  voidSphere.scale.setScalar(rPlus);
  ergoMat.uniforms.uRPlus.value=rPlus;
  ergoMat.uniforms.uSpinA.value=spinA;
  ergoMat.uniforms.uTime.value=t;

  // Update void mask camera + Kerr params
  voidMaskMat.uniforms.uCamPos.value.copy(camera.position);
  voidMaskMat.uniforms.uRes.value.set(window.innerWidth,window.innerHeight);
  voidMaskMat.uniforms.uRPlus.value=rPlus;
  // Pass companion BH positions to void mask
  const compUniforms = [voidMaskMat.uniforms.uComp0, voidMaskMat.uniforms.uComp1, voidMaskMat.uniforms.uComp2, voidMaskMat.uniforms.uComp3];
  for (let ci = 0; ci < 4; ci++) {
    if (ci < companions.length && companions[ci].alive) {
      const c = companions[ci];
      const rH = c.mass * (1.0 + Math.sqrt(Math.max(0, 1.0 - c.spin * c.spin)));
      compUniforms[ci].value.set(c.x, c.y, c.z, rH);
    } else {
      compUniforms[ci].value.set(0, 0, 0, 0);
    }
  }

  // ---- RENDER PIPELINE ----

  // 0. Compute BH screen position for lens shader
  const bhPos3=new THREE.Vector3(0,0,0);
  bhPos3.project(camera);
  const bhScreenX=(bhPos3.x*0.5+0.5);
  const bhScreenY=(bhPos3.y*0.5+0.5);
  // Apparent angular radius: project a point on the event horizon
  const edgePos=new THREE.Vector3(rPlus,0,0);
  edgePos.project(camera);
  const edgeScreenX=(edgePos.x*0.5+0.5);
  const bhScreenR=Math.abs(edgeScreenX-bhScreenX)*1.1;

  lensMat.uniforms.uBHScreen.value.set(bhScreenX,bhScreenY);
  lensMat.uniforms.uBHRadius.value=Math.max(0.01,bhScreenR);

  // Compute companion screen positions for lensing
  const compLensUniforms = [lensMat.uniforms.uCompScreen0, lensMat.uniforms.uCompScreen1, lensMat.uniforms.uCompScreen2, lensMat.uniforms.uCompScreen3];
  for (let ci = 0; ci < 4; ci++) {
    if (ci < companions.length && companions[ci].alive) {
      const c = companions[ci];
      const rH = c.mass * (1.0 + Math.sqrt(Math.max(0, 1.0 - c.spin * c.spin)));
      const cPos = new THREE.Vector3(c.x, c.y, c.z).project(camera);
      const cScreenX = cPos.x * 0.5 + 0.5;
      const cScreenY = cPos.y * 0.5 + 0.5;
      // Project edge to get screen radius
      const cEdge = new THREE.Vector3(c.x + rH, c.y, c.z).project(camera);
      const cScreenR = Math.abs((cEdge.x * 0.5 + 0.5) - cScreenX) * 1.1;
      compLensUniforms[ci].value.set(cScreenX, cScreenY, Math.max(0.005, cScreenR));
    } else {
      compLensUniforms[ci].value.set(0, 0, 0);
    }
  }

  // 1. Render stars to texture (classic mode only)
  if(lensMode===0){
    renderer.setRenderTarget(rtStars);
    renderer.setClearColor(0x000000,1);renderer.clear();
    renderer.render(starScene,camera);

    // 2. Apply gravitational lensing distortion
    lensMat.uniforms.tStars.value=rtStars.texture;
    postQuad.material=lensMat;
    renderer.setRenderTarget(rtStarsLensed);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 3. Raymarched BG glow (Einstein ring)
  renderer.setRenderTarget(rtBG);renderer.clear();
  renderer.render(bgScene,ortho);

  // 4. Void mask
  postQuad.material=voidMaskMat;
  renderer.setRenderTarget(rtMask);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Particle scene (disk, jets, void, dust, infall — no stars)
  renderer.setRenderTarget(rtParticles);
  renderer.setClearColor(0x000000,1);renderer.clear();
  renderer.render(scene,camera);

  // 6. Combine: (lensedStars + bg) * (1-mask) + particles
  finalCombineMat.uniforms.tBG.value=rtBG.texture;
  finalCombineMat.uniforms.tStarsLensed.value=rtStarsLensed.texture;
  finalCombineMat.uniforms.tParticles.value=rtParticles.texture;
  finalCombineMat.uniforms.tMask.value=rtMask.texture;
  postQuad.material=finalCombineMat;
  renderer.setRenderTarget(rtCombined);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Bloom: extract bright
  threshMat.uniforms.tDiffuse.value=rtCombined.texture;
  postQuad.material=threshMat;
  renderer.setRenderTarget(rtBright);renderer.clear();
  renderer.render(postScene,ortho);

  // Blur passes (bloom)
  for(let p=0;p<3;p++){
    blurH.uniforms.tDiffuse.value=p===0?rtBright.texture:rtBlurB.texture;
    postQuad.material=blurH;
    renderer.setRenderTarget(rtBlurA);renderer.clear();
    renderer.render(postScene,ortho);
    blurV.uniforms.tDiffuse.value=rtBlurA.texture;
    postQuad.material=blurV;
    renderer.setRenderTarget(rtBlurB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 5b. Anamorphic streak passes — ultra-wide horizontal blur
  // Start from bright extract, run 4 wide horizontal passes for massive spread
  for(let s=0;s<4;s++){
    streakBlurMat.uniforms.tDiffuse.value=s===0?rtBright.texture:rtStreakB.texture;
    postQuad.material=streakBlurMat;
    renderer.setRenderTarget(rtStreakA);renderer.clear();
    renderer.render(postScene,ortho);
    // Ping-pong
    streakBlurMat.uniforms.tDiffuse.value=rtStreakA.texture;
    renderer.setRenderTarget(rtStreakB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 6. Final composite with bloom + streaks
  compositeMat.uniforms.tScene.value=rtCombined.texture;
  compositeMat.uniforms.tBloom.value=rtBlurB.texture;
  compositeMat.uniforms.tStreak.value=rtStreakB.texture;
  compositeMat.uniforms.uTime.value=t;
  compositeMat.uniforms.uBloomStr.value=1.4+pulse*1.2;
  // Pass gravitational wave data to composite shader
  const gwUniforms = [compositeMat.uniforms.uGWave0, compositeMat.uniforms.uGWave1, compositeMat.uniforms.uGWave2, compositeMat.uniforms.uGWave3];
  let gwIdx = 0;
  for (let i = 0; i < MAX_GWAVES && gwIdx < 4; i++) {
    if (gwaves[i].active) {
      gwUniforms[gwIdx].value.set(gwaves[i].radius, gwaves[i].amplitude, 1.0);
      gwIdx++;
    }
  }
  for (; gwIdx < 4; gwIdx++) gwUniforms[gwIdx].value.set(0, 0, 0);
  postQuad.material=compositeMat;
  renderer.setRenderTarget(null);renderer.clear();
  renderer.render(postScene,ortho);
}
animate();

window.addEventListener('resize',()=>{
  const w=window.innerWidth,h=window.innerHeight;
  camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h);
  bgMat.uniforms.uRes.value.set(w,h);
  voidMaskMat.uniforms.uRes.value.set(w,h);
  const p=Math.min(window.devicePixelRatio,2);
  rtParticles.setSize(w*p,h*p);rtCombined.setSize(w*p,h*p);
  rtBG.setSize(w*p,h*p);rtMask.setSize(w*p,h*p);
  rtStars.setSize(w*p,h*p);rtStarsLensed.setSize(w*p,h*p);
  rtBright.setSize(w*p*0.5,h*p*0.5);
  [rtBlurA,rtBlurB].forEach(rt=>rt.setSize(w*p*0.5,h*p*0.5));
  [rtStreakA,rtStreakB].forEach(rt=>rt.setSize(w*p*0.25,h*p*0.25));
  [blurH,blurV].forEach(m=>m.uniforms.uRes.value.set(w*0.5,h*0.5));
  streakBlurMat.uniforms.uRes.value.set(w*0.25,h*0.25);
});
</script>
</body>
</html>
