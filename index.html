<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SINGULARITY</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@400;500&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;cursor:grab;font-family:'Instrument Sans',sans-serif;}
body:active{cursor:grabbing;}
canvas{display:block;}
#overlay{position:fixed;inset:0;pointer-events:none;z-index:10;
  background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.5) 100%);}
#info{position:fixed;bottom:24px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.3);font-size:11px;letter-spacing:3px;
  text-align:center;pointer-events:none;z-index:20;}
#title{position:fixed;top:28px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.45);font-size:13px;letter-spacing:12px;
  text-transform:uppercase;pointer-events:none;z-index:20;font-weight:500;}
</style>
</head>
<body>
<div id="overlay"></div>
<div id="title">SINGULARITY</div>
<div id="info">drag to orbit · scroll to zoom · space to pulse</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// SINGULARITY — HYBRID
// Raymarched gravitationally-lensed starfield background
// + Particle accretion disk, jets, void sphere
// + Full bloom pipeline
// ============================================================

// === Procedural sprite textures ===
function genSprite(size,falloff,softness){
  const c=document.createElement('canvas');c.width=c.height=size;
  const ctx=c.getContext('2d'),img=ctx.createImageData(size,size),h=size/2;
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){
    const d=Math.sqrt(((x-h)/h)**2+((y-h)/h)**2);
    const a=Math.min(1,Math.exp(-d*d*falloff)+Math.exp(-d*d*softness)*0.3);
    const i=(y*size+x)*4;img.data[i]=img.data[i+1]=img.data[i+2]=255;img.data[i+3]=a*255|0;
  }
  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c);tex.needsUpdate=true;return tex;
}
const diskTex=genSprite(64,4.0,1.2),jetTex=genSprite(32,3.0,0.8);

// === JS noise for particle placement ===
function hash2(x,y){let h=x*374761393+y*668265263;h=(h^(h>>13))*1274126177;return((h^(h>>16))&0x7fffffff)/0x7fffffff;}
function sNoise(x,y){const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy;
  const sx=fx*fx*(3-2*fx),sy=fy*fy*(3-2*fy);
  return hash2(ix,iy)*(1-sx)*(1-sy)+hash2(ix+1,iy)*sx*(1-sy)+hash2(ix,iy+1)*(1-sx)*sy+hash2(ix+1,iy+1)*sx*sy;}
function fbm(x,y,o){let v=0,a=0.5,f=1;for(let i=0;i<o;i++){v+=sNoise(x*f,y*f)*a;a*=0.5;f*=2;}return v;}

// ============================================================
// RENDERER
// ============================================================
const renderer=new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.autoClear=false;
document.body.appendChild(renderer.domElement);

const pxr=Math.min(window.devicePixelRatio,2);
function makeRT(s){return new THREE.WebGLRenderTarget(window.innerWidth*pxr*s,window.innerHeight*pxr*s,
  {type:THREE.HalfFloatType,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter});}

// Render targets
let rtBG=makeRT(1);          // raymarched background (full res for alignment)
let rtParticles=makeRT(1);   // particle scene
let rtCombined=makeRT(1);    // combined
let rtBright=makeRT(0.5);
let rtBlurA=makeRT(0.5),rtBlurB=makeRT(0.5);

const fsGeo=new THREE.PlaneGeometry(2,2);
const ortho=new THREE.OrthographicCamera(-1,1,1,-1,0,1);

// ============================================================
// PASS 1: RAYMARCHED LENSED STARFIELD
// Only traces stars through curved spacetime — no disk rendering
// ============================================================
const CAM_FOV=55.0;
const FOV_MULT=2.0*Math.tan(CAM_FOV*0.5*Math.PI/180.0); // ≈1.039

const bgMat=new THREE.ShaderMaterial({
  uniforms:{
    uRes:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},
    uCamPos:{value:new THREE.Vector3(0,3,8)},
    uTime:{value:0},
    uFov:{value:FOV_MULT}
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    precision highp float;
    uniform vec2 uRes;
    uniform vec3 uCamPos;
    uniform float uTime,uFov;
    varying vec2 vUv;

    #define RS 1.0

    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}

    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));

      // Photon sphere / Einstein ring glow
      float b=length(cross(uCamPos,rd));
      float photonR=1.5*RS;
      float ringGlow=exp(-pow(b-photonR,2.0)*18.0)*0.15;
      // Wider soft glow around the shadow
      float shadowEdge=exp(-pow(b-1.2*RS,2.0)*5.0)*0.06;
      vec3 col=vec3(1.0,0.9,0.72)*ringGlow+vec3(1.0,0.85,0.6)*shadowEdge;

      gl_FragColor=vec4(col,1.0);
    }
  `
});
const bgScene=new THREE.Scene();
bgScene.add(new THREE.Mesh(fsGeo.clone(),bgMat));

// ============================================================
// PASS 2: PARTICLE SCENE (from V7)
// ============================================================
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(55,window.innerWidth/window.innerHeight,0.1,1000);

// Event horizon — opaque black void
scene.add(new THREE.Mesh(
  new THREE.SphereGeometry(1.0,96,96),
  new THREE.ShaderMaterial({
    vertexShader:`void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);}`,
    depthWrite:true,depthTest:true,side:THREE.FrontSide
  })
));

// Particle starfield — fixed positions, stable
const starTex=genSprite(32,8.0,2.0);
(function(){
  const N=25000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=60+Math.random()*250,th=Math.random()*Math.PI*2,ph=Math.acos(2*Math.random()-1);
    pos[i*3]=r*Math.sin(ph)*Math.cos(th);pos[i*3+1]=r*Math.sin(ph)*Math.sin(th);pos[i*3+2]=r*Math.cos(ph);
    const t=Math.random(),c=t>0.85?[.7,.8,1]:(t>.5?[1,.97,.92]:(t>.2?[1,.88,.7]:[1,.65,.45]));
    col[i*3]=c[0];col[i*3+1]=c[1];col[i*3+2]=c[2];
    siz[i]=0.4+Math.pow(Math.random(),3)*5.0;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  scene.add(new THREE.Points(geo,new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:starTex}},
    vertexShader:`attribute float size;varying vec3 vC;varying float vS;uniform float uTime;
      void main(){vC=color;vS=size;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(200.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;varying float vS;uniform float uTime;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a;
        float tw=0.9+0.1*sin(uTime*0.4+vS*23.0);
        gl_FragColor=vec4(vC*a*tw*1.5,a*tw);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  })));
})();

// Accretion disk — 90k noise-density particles
const DISK_N=90000;
const disk={radii:new Float32Array(DISK_N),angles:new Float32Array(DISK_N),
  velocities:new Float32Array(DISK_N),baseColors:null,posAttr:null,colAttr:null,mat:null};

(function(){
  const N=DISK_N;
  const pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  let placed=0;
  while(placed<N){
    const r=1.02+Math.pow(Math.random(),0.45)*6.2;
    const angle=Math.random()*Math.PI*2;
    const nx=Math.cos(angle)*r,nz=Math.sin(angle)*r;
    const density=0.42+fbm(nx*0.3,nz*0.3,3)*0.28+fbm(nx*0.8+100,nz*0.8+100,2)*0.18+fbm(nx*2+200,nz*2+200,2)*0.1;
    if(Math.random()>density) continue;
    const i=placed;
    const tNorm=(r-1.02)/6.2;
    const thickness=0.008+tNorm*0.065;
    pos[i*3]=nx;pos[i*3+1]=(Math.random()-0.5)*thickness;pos[i*3+2]=nz;
    disk.radii[i]=r;disk.angles[i]=angle;
    disk.velocities[i]=1.0/Math.pow(r,1.5);
    const cn=(Math.random()-0.5)*0.03;
    let cr,cg,cb;
    if(tNorm<0.03){cr=1.0+cn;cg=0.95+cn;cb=0.82;}
    else if(tNorm<0.08){const b=(tNorm-0.03)/0.05;cr=1.0+cn;cg=0.95-b*0.05+cn;cb=0.82-b*0.25;}
    else if(tNorm<0.18){const b=(tNorm-0.08)/0.1;cr=1.0+cn;cg=0.9-b*0.08+cn;cb=0.55-b*0.2;}
    else if(tNorm<0.35){const b=(tNorm-0.18)/0.17;cr=1.0+cn;cg=0.8-b*0.15+cn*0.5;cb=0.32-b*0.15;}
    else if(tNorm<0.55){const b=(tNorm-0.35)/0.2;cr=1.0-b*0.05+cn;cg=0.6-b*0.2+cn*0.3;cb=0.15-b*0.07;}
    else if(tNorm<0.78){const b=(tNorm-0.55)/0.23;cr=0.92-b*0.14+cn;cg=0.35-b*0.15+cn*0.2;cb=0.07-b*0.03;}
    else{const b=(tNorm-0.78)/0.22;cr=0.7-b*0.28+cn;cg=0.15-b*0.08;cb=0.03;}
    const bn=0.88+(fbm(nx*0.3,nz*0.3,3)-0.5)*0.16+(fbm(nx*0.8+100,nz*0.8+100,2)-0.5)*0.06;
    cr*=bn;cg*=bn;cb*=bn;
    col[i*3]=Math.max(0,Math.min(1,cr));col[i*3+1]=Math.max(0,Math.min(1,cg));col[i*3+2]=Math.max(0,Math.min(1,cb));
    siz[i]=(0.22+Math.random()*0.8)*(1.0-tNorm*0.2);
    placed++;
  }
  disk.baseColors=new Float32Array(col);
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  disk.mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:diskTex}},
    vertexShader:`
      attribute float size;varying vec3 vC;varying float vR;
      uniform float uTime,uPulse;
      void main(){
        vC=color*(1.0+uPulse*0.35);
        vR=length(position.xz);
        vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(100.0/-mv.z)*(1.0+uPulse*0.2);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`
      varying vec3 vC;varying float vR;uniform sampler2D uTex;
      void main(){
        float a=texture2D(uTex,gl_PointCoord).a*0.7;
        if(a<0.01)discard;
        float ib=1.0+smoothstep(4.0,1.02,vR)*1.0;
        gl_FragColor=vec4(vC*ib,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  disk.posAttr=geo.attributes.position;
  disk.colAttr=geo.attributes.color;
  const points=new THREE.Points(geo,disk.mat);
  points.rotation.x=0.08;points.rotation.z=0.05;
  scene.add(points);
})();

// Jets
function createJet(dir){
  const N=5000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const t=Math.pow(Math.random(),0.6);
    const h=t*14*dir,spread=t*t*0.45;
    const a=Math.random()*Math.PI*2,r=Math.random()*spread;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=h;pos[i*3+2]=Math.sin(a)*r;
    const b=1.0-t*0.85;
    col[i*3]=(0.4+t*0.15)*b;col[i*3+1]=(0.55+t*0.05)*b;col[i*3+2]=1.0*b;
    siz[i]=(1.0-t*0.6)*1.2;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:jetTex}},
    vertexShader:`attribute float size;varying vec3 vC;uniform float uTime,uPulse;
      void main(){vC=color*(1.0+uPulse*0.3);
        vec3 p=position;float h=abs(p.y);
        p.x+=sin(uTime*2.5+h*1.2)*0.03*h*0.07;
        p.z+=cos(uTime*2.5+h*1.2)*0.03*h*0.07;
        vec4 mv=modelViewMatrix*vec4(p,1.0);
        gl_PointSize=size*(65.0/-mv.z)*(1.0+uPulse*0.4);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.35;
        if(a<0.01)discard;gl_FragColor=vec4(vC,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  return{points:new THREE.Points(geo,mat),mat};
}
const jetUp=createJet(1),jetDown=createJet(-1);
scene.add(jetUp.points);scene.add(jetDown.points);

// Dust halo
const dustMat=(function(){
  const N=4000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=5+Math.random()*14,a=Math.random()*Math.PI*2,y=(Math.random()-0.5)*2;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=y;pos[i*3+2]=Math.sin(a)*r;
    col[i*3]=0.3;col[i*3+1]=0.15;col[i*3+2]=0.05;
    siz[i]=0.3+Math.random()*0.7;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:diskTex}},
    vertexShader:`attribute float size;varying vec3 vC;
      void main(){vC=color;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(55.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.1;
        if(a<0.01)discard;gl_FragColor=vec4(vC,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  scene.add(new THREE.Points(geo,mat));return mat;
})();

// ============================================================
// COMPOSITE + BLOOM SHADERS
// ============================================================

// Combine BG + particles
const combineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec4 fg=texture2D(tParticles,vUv);
      // Particles use additive blending on black, so just add them to background
      // But where the void sphere rendered black, suppress the background too
      // Detect void: if particle pass is pure black AND we expect the void there
      float fgBright=dot(fg.rgb,vec3(1.0));
      // Use a mask: areas that rendered to exactly 0 might be void or empty space
      // We differentiate by checking if depth would have been written (void sphere)
      // Simple approach: if fg is very dark, show bg; if fg has content, add it
      vec3 col=bg+fg.rgb;
      gl_FragColor=vec4(col,1.0);
    }`
});

// But we need the void sphere to BLOCK the background stars behind it.
// Problem: with additive particle blending, the void renders as black (adds nothing).
// Solution: render the void sphere separately to a mask, or use a different approach.

// Better approach: render void sphere to write a mask in alpha channel
// Actually, simplest: render the particle scene with the void sphere writing alpha=1 black,
// then composite properly.

// Let me use a two-step approach for the particle scene:
// The void sphere renders with depthWrite=true and outputs black.
// Particles render on top with additive blending.
// If we render particles to a texture, void areas = black, space areas = black, particle areas = bright.
// We can't distinguish void from empty space...

// SOLUTION: Render a void-only pass to get a silhouette mask.
const voidMaskMat=new THREE.ShaderMaterial({
  uniforms:{uCamPos:{value:new THREE.Vector3()},uRes:{value:new THREE.Vector2()},uFov:{value:FOV_MULT}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform vec3 uCamPos;uniform vec2 uRes;uniform float uFov;varying vec2 vUv;
    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}
    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));
      // Ray-sphere intersection for void (r=1.0)
      vec3 oc=uCamPos;
      float b2=dot(oc,rd);
      float c=dot(oc,oc)-1.0;
      float disc=b2*b2-c;
      float mask=disc>0.0?1.0:0.0;
      gl_FragColor=vec4(vec3(mask),1.0);
    }`
});

// Final combine: BG * (1-voidMask) + particles
const finalCombineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null},tMask:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles,tMask;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec3 fg=texture2D(tParticles,vUv).rgb;
      float mask=texture2D(tMask,vUv).r;
      // Behind void: suppress background stars. Elsewhere: show bg + particles
      vec3 col=bg*(1.0-mask)+fg;
      gl_FragColor=vec4(col,1.0);
    }`
});

// Bloom threshold
const threshMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uThreshold:{value:0.28}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform float uThreshold;varying vec2 vUv;
    void main(){vec4 c=texture2D(tDiffuse,vUv);float b=dot(c.rgb,vec3(0.2126,0.7152,0.0722));
      gl_FragColor=b>uThreshold?c*smoothstep(uThreshold,uThreshold+0.4,b):vec4(0.0);}`
});
function mkBlur(h){return new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.5,window.innerHeight*0.5)},
    uDir:{value:h?new THREE.Vector2(1,0):new THREE.Vector2(0,1)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes,uDir;varying vec2 vUv;
    void main(){vec2 tx=uDir/uRes;vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv-tx*4.0)*0.0162;r+=texture2D(tDiffuse,vUv-tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv-tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv-tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv)*0.2270;r+=texture2D(tDiffuse,vUv+tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv+tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv+tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv+tx*4.0)*0.0162;gl_FragColor=r;}`});}
const blurH=mkBlur(true),blurV=mkBlur(false);

// Final output with bloom
const compositeMat=new THREE.ShaderMaterial({
  uniforms:{tScene:{value:null},tBloom:{value:null},uBloomStr:{value:1.5},uTime:{value:0}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tScene,tBloom;uniform float uBloomStr,uTime;varying vec2 vUv;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec3 sc=texture2D(tScene,vUv).rgb,bl=texture2D(tBloom,vUv).rgb;
      vec3 col=sc+bl*uBloomStr;
      float d=length(vUv-0.5),ca=d*d*0.004;
      col.r+=texture2D(tBloom,vUv+vec2(ca)).r*uBloomStr*0.18;
      col.b+=texture2D(tBloom,vUv-vec2(ca)).b*uBloomStr*0.18;
      col*=1.0-d*0.6;
      col+=(hash(vUv*800.0+fract(uTime))-0.5)*0.02;
      gl_FragColor=vec4(col,1.0);}`
});

// Fullscreen quad + scene for post-processing
const postScene=new THREE.Scene();
const postQuad=new THREE.Mesh(fsGeo.clone(),compositeMat);
postScene.add(postQuad);

let rtMask=makeRT(1);

// ============================================================
// CAMERA
// ============================================================
let isDragging=false,prevMouse={x:0,y:0};
let sph={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let tgt={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let pulse=0;

function pD(x,y){isDragging=true;prevMouse={x,y};}
function pM(x,y){if(!isDragging)return;
  tgt.theta-=(x-prevMouse.x)*0.004;
  tgt.phi=Math.max(0.2,Math.min(Math.PI-0.2,tgt.phi-(y-prevMouse.y)*0.004));
  prevMouse={x,y};}
function pU(){isDragging=false;}
document.addEventListener('mousedown',e=>pD(e.clientX,e.clientY));
document.addEventListener('mousemove',e=>pM(e.clientX,e.clientY));
document.addEventListener('mouseup',pU);
document.addEventListener('touchstart',e=>{e.preventDefault();pD(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchmove',e=>{e.preventDefault();pM(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchend',pU);
document.addEventListener('wheel',e=>{tgt.radius=Math.max(2.5,Math.min(25,tgt.radius+e.deltaY*0.008));},{passive:true});
document.addEventListener('keydown',e=>{if(e.code==='Space'){e.preventDefault();pulse=1.0;}});

// ============================================================
// ANIMATION
// ============================================================
const clock=new THREE.Clock();
const timeMats=[disk.mat,jetUp.mat,jetDown.mat,dustMat];

function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();

  sph.theta+=(tgt.theta-sph.theta)*0.05;
  sph.phi+=(tgt.phi-sph.phi)*0.05;
  sph.radius+=(tgt.radius-sph.radius)*0.05;
  if(!isDragging) tgt.theta+=0.0003;

  camera.position.set(
    sph.radius*Math.sin(sph.phi)*Math.sin(sph.theta),
    sph.radius*Math.cos(sph.phi),
    sph.radius*Math.sin(sph.phi)*Math.cos(sph.theta)
  );
  camera.lookAt(0,0,0);
  pulse*=0.94;

  timeMats.forEach(m=>{
    if(m.uniforms.uTime)m.uniforms.uTime.value=t;
    if(m.uniforms.uPulse)m.uniforms.uPulse.value=pulse;
  });

  // Update disk
  const pa=disk.posAttr,ca=disk.colAttr,bc=disk.baseColors;
  const camA=Math.atan2(camera.position.x,camera.position.z);
  for(let i=0;i<DISK_N;i++){
    disk.angles[i]+=disk.velocities[i]*0.004;
    const r=disk.radii[i],a=disk.angles[i];
    pa.array[i*3]=Math.cos(a)*r;
    pa.array[i*3+2]=Math.sin(a)*r;
    const dop=0.5+0.6*Math.cos(a-camA);
    const df=0.5+dop*0.55;
    ca.array[i*3]=bc[i*3]*df;ca.array[i*3+1]=bc[i*3+1]*df;ca.array[i*3+2]=bc[i*3+2]*df;
  }
  pa.needsUpdate=true;ca.needsUpdate=true;

  // Update BG shader camera
  bgMat.uniforms.uCamPos.value.copy(camera.position);
  bgMat.uniforms.uTime.value=t;

  // Update void mask camera
  voidMaskMat.uniforms.uCamPos.value.copy(camera.position);
  voidMaskMat.uniforms.uRes.value.set(window.innerWidth,window.innerHeight);

  // ---- RENDER PIPELINE ----

  // 1. Raymarched lensed starfield background
  renderer.setRenderTarget(rtBG);renderer.clear();
  renderer.render(bgScene,ortho);

  // 2. Void mask (which pixels are behind the event horizon)
  postQuad.material=voidMaskMat;
  renderer.setRenderTarget(rtMask);renderer.clear();
  renderer.render(postScene,ortho);

  // 3. Particle scene (black background)
  renderer.setRenderTarget(rtParticles);
  renderer.setClearColor(0x000000,1);renderer.clear();
  renderer.render(scene,camera);

  // 4. Combine: bg*(1-mask) + particles
  finalCombineMat.uniforms.tBG.value=rtBG.texture;
  finalCombineMat.uniforms.tParticles.value=rtParticles.texture;
  finalCombineMat.uniforms.tMask.value=rtMask.texture;
  postQuad.material=finalCombineMat;
  renderer.setRenderTarget(rtCombined);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Bloom: extract bright
  threshMat.uniforms.tDiffuse.value=rtCombined.texture;
  postQuad.material=threshMat;
  renderer.setRenderTarget(rtBright);renderer.clear();
  renderer.render(postScene,ortho);

  // Blur passes
  for(let p=0;p<3;p++){
    blurH.uniforms.tDiffuse.value=p===0?rtBright.texture:rtBlurB.texture;
    postQuad.material=blurH;
    renderer.setRenderTarget(rtBlurA);renderer.clear();
    renderer.render(postScene,ortho);
    blurV.uniforms.tDiffuse.value=rtBlurA.texture;
    postQuad.material=blurV;
    renderer.setRenderTarget(rtBlurB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 6. Final composite with bloom
  compositeMat.uniforms.tScene.value=rtCombined.texture;
  compositeMat.uniforms.tBloom.value=rtBlurB.texture;
  compositeMat.uniforms.uTime.value=t;
  compositeMat.uniforms.uBloomStr.value=1.4+pulse*1.2;
  postQuad.material=compositeMat;
  renderer.setRenderTarget(null);renderer.clear();
  renderer.render(postScene,ortho);
}
animate();

window.addEventListener('resize',()=>{
  const w=window.innerWidth,h=window.innerHeight;
  camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h);
  bgMat.uniforms.uRes.value.set(w,h);
  voidMaskMat.uniforms.uRes.value.set(w,h);
  const p=Math.min(window.devicePixelRatio,2);
  rtParticles.setSize(w*p,h*p);rtCombined.setSize(w*p,h*p);
  rtBG.setSize(w*p,h*p);rtMask.setSize(w*p,h*p);
  rtBright.setSize(w*p*0.5,h*p*0.5);
  [rtBlurA,rtBlurB].forEach(rt=>rt.setSize(w*p*0.5,h*p*0.5));
  [blurH,blurV].forEach(m=>m.uniforms.uRes.value.set(w*0.5,h*0.5));
});
</script>
</body>
</html>
