<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SINGULARITY</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Instrument+Sans:wght@400;500&display=swap');
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#000;overflow:hidden;cursor:grab;font-family:'Instrument Sans',sans-serif;}
body:active{cursor:grabbing;}
canvas{display:block;}
#overlay{position:fixed;inset:0;pointer-events:none;z-index:10;
  background:radial-gradient(ellipse at center,transparent 40%,rgba(0,0,0,0.5) 100%);}
#info{position:fixed;bottom:24px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.3);font-size:11px;letter-spacing:3px;
  text-align:center;pointer-events:none;z-index:20;}
#wavemode{position:fixed;top:28px;right:28px;z-index:20;display:flex;gap:6px;}
#wavemode button{background:rgba(255,255,255,0.08);border:1px solid rgba(255,255,255,0.15);
  color:rgba(255,255,255,0.4);font-family:'Instrument Sans',sans-serif;font-size:10px;
  letter-spacing:2px;padding:6px 12px;cursor:pointer;transition:all 0.4s;text-transform:uppercase;}
#wavemode button:hover{background:rgba(255,255,255,0.12);color:rgba(255,255,255,0.6);}
#wavemode button.active{border-color:rgba(255,255,255,0.5);color:rgba(255,255,255,0.8);}
#wavemode button.active.vis{background:rgba(255,180,80,0.2);border-color:rgba(255,180,80,0.5);}
#wavemode button.active.xray{background:rgba(80,160,255,0.2);border-color:rgba(80,160,255,0.5);}
#wavemode button.active.radio{background:rgba(255,80,80,0.2);border-color:rgba(255,80,80,0.5);}
#title{position:fixed;top:28px;left:50%;transform:translateX(-50%);
  color:rgba(255,255,255,0.45);font-size:13px;letter-spacing:12px;
  text-transform:uppercase;pointer-events:none;z-index:20;font-weight:500;}
</style>
</head>
<body>
<div id="overlay"></div>
<div id="title">SINGULARITY</div>
<div id="wavemode">
  <button class="vis active" onclick="setWaveMode(0)">Visible</button>
  <button class="xray" onclick="setWaveMode(1)">X-Ray</button>
  <button class="radio" onclick="setWaveMode(2)">Radio</button>
</div>
<div id="info">drag to orbit · scroll to zoom · space to pulse · 1/2/3 wavelength</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// SINGULARITY — HYBRID
// Raymarched gravitationally-lensed starfield background
// + Particle accretion disk, jets, void sphere
// + Full bloom pipeline
// ============================================================

// === Procedural sprite textures ===
function genSprite(size,falloff,softness){
  const c=document.createElement('canvas');c.width=c.height=size;
  const ctx=c.getContext('2d'),img=ctx.createImageData(size,size),h=size/2;
  for(let y=0;y<size;y++)for(let x=0;x<size;x++){
    const d=Math.sqrt(((x-h)/h)**2+((y-h)/h)**2);
    const a=Math.min(1,Math.exp(-d*d*falloff)+Math.exp(-d*d*softness)*0.3);
    const i=(y*size+x)*4;img.data[i]=img.data[i+1]=img.data[i+2]=255;img.data[i+3]=a*255|0;
  }
  ctx.putImageData(img,0,0);
  const tex=new THREE.CanvasTexture(c);tex.needsUpdate=true;return tex;
}
const diskTex=genSprite(64,4.0,1.2),jetTex=genSprite(32,3.0,0.8);

// === JS noise for particle placement ===
function hash2(x,y){let h=x*374761393+y*668265263;h=(h^(h>>13))*1274126177;return((h^(h>>16))&0x7fffffff)/0x7fffffff;}
function sNoise(x,y){const ix=Math.floor(x),iy=Math.floor(y),fx=x-ix,fy=y-iy;
  const sx=fx*fx*(3-2*fx),sy=fy*fy*(3-2*fy);
  return hash2(ix,iy)*(1-sx)*(1-sy)+hash2(ix+1,iy)*sx*(1-sy)+hash2(ix,iy+1)*(1-sx)*sy+hash2(ix+1,iy+1)*sx*sy;}
function fbm(x,y,o){let v=0,a=0.5,f=1;for(let i=0;i<o;i++){v+=sNoise(x*f,y*f)*a;a*=0.5;f*=2;}return v;}

// ============================================================
// RENDERER
// ============================================================
const renderer=new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.autoClear=false;
document.body.appendChild(renderer.domElement);

const pxr=Math.min(window.devicePixelRatio,2);
function makeRT(s){return new THREE.WebGLRenderTarget(window.innerWidth*pxr*s,window.innerHeight*pxr*s,
  {type:THREE.HalfFloatType,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter});}

// Render targets
let rtBG=makeRT(1);          // raymarched background (full res for alignment)
let rtStars=makeRT(1);       // raw star render
let rtStarsLensed=makeRT(1); // gravitationally lensed stars
let rtParticles=makeRT(1);   // particle scene
let rtCombined=makeRT(1);    // combined
let rtBright=makeRT(0.5);
let rtBlurA=makeRT(0.5),rtBlurB=makeRT(0.5);
let rtStreakA=makeRT(0.25),rtStreakB=makeRT(0.25); // lower res for wide streaks

const fsGeo=new THREE.PlaneGeometry(2,2);
const ortho=new THREE.OrthographicCamera(-1,1,1,-1,0,1);

// ============================================================
// PASS 1: RAYMARCHED LENSED STARFIELD
// Only traces stars through curved spacetime — no disk rendering
// ============================================================
const CAM_FOV=55.0;
const FOV_MULT=2.0*Math.tan(CAM_FOV*0.5*Math.PI/180.0); // ≈1.039

const bgMat=new THREE.ShaderMaterial({
  uniforms:{
    uRes:{value:new THREE.Vector2(window.innerWidth,window.innerHeight)},
    uCamPos:{value:new THREE.Vector3(0,3,8)},
    uTime:{value:0},
    uFov:{value:FOV_MULT},
    uMode:{value:0}
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    precision highp float;
    uniform vec2 uRes;
    uniform vec3 uCamPos;
    uniform float uTime,uFov,uMode;
    varying vec2 vUv;

    #define RS 1.0

    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}

    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));

      float b=length(cross(uCamPos,rd));
      float photonR=1.5*RS;
      float ringGlow=exp(-pow(b-photonR,2.0)*18.0)*0.15;
      float shadowEdge=exp(-pow(b-1.2*RS,2.0)*5.0)*0.06;

      // Mode-dependent glow color
      vec3 ringCol,edgeCol;
      if(uMode<0.5){
        ringCol=vec3(1.0,0.9,0.72); edgeCol=vec3(1.0,0.85,0.6);
      } else if(uMode<1.5){
        ringCol=vec3(0.6,0.8,1.0); edgeCol=vec3(0.4,0.6,1.0);
      } else {
        ringCol=vec3(1.0,0.5,0.2); edgeCol=vec3(1.0,0.4,0.1);
      }
      vec3 col=ringCol*ringGlow+edgeCol*shadowEdge;

      gl_FragColor=vec4(col,1.0);
    }
  `
});
const bgScene=new THREE.Scene();
bgScene.add(new THREE.Mesh(fsGeo.clone(),bgMat));

// ============================================================
// PASS 2: PARTICLE SCENE (from V7)
// ============================================================
const scene=new THREE.Scene();
const camera=new THREE.PerspectiveCamera(55,window.innerWidth/window.innerHeight,0.1,1000);

// Event horizon — opaque black void
scene.add(new THREE.Mesh(
  new THREE.SphereGeometry(1.0,96,96),
  new THREE.ShaderMaterial({
    vertexShader:`void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
    fragmentShader:`void main(){gl_FragColor=vec4(0.0,0.0,0.0,1.0);}`,
    depthWrite:true,depthTest:true,side:THREE.FrontSide
  })
));

// Particle starfield — in separate scene for gravitational lensing
const starTex=genSprite(32,8.0,2.0);
const starScene=new THREE.Scene();
const starsMat=(function(){
  const N=25000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=60+Math.random()*250,th=Math.random()*Math.PI*2,ph=Math.acos(2*Math.random()-1);
    pos[i*3]=r*Math.sin(ph)*Math.cos(th);pos[i*3+1]=r*Math.sin(ph)*Math.sin(th);pos[i*3+2]=r*Math.cos(ph);
    const t=Math.random(),c=t>0.85?[.7,.8,1]:(t>.5?[1,.97,.92]:(t>.2?[1,.88,.7]:[1,.65,.45]));
    col[i*3]=c[0];col[i*3+1]=c[1];col[i*3+2]=c[2];
    siz[i]=0.4+Math.pow(Math.random(),3)*5.0;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:starTex},uMode:{value:0}},
    vertexShader:`attribute float size;varying vec3 vC;varying float vS;uniform float uTime;
      void main(){vC=color;vS=size;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(200.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;varying float vS;uniform float uTime,uMode;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a;
        float tw=0.9+0.1*sin(uTime*0.4+vS*23.0);
        vec3 c=vC*tw*1.5;
        if(uMode>0.5&&uMode<1.5){
          float lum=dot(c,vec3(0.33));
          c=vec3(0.7,0.85,1.0)*lum;
        } else if(uMode>1.5){
          float lum=dot(c,vec3(0.33));
          c=vec3(lum*0.3,lum*0.15,lum*0.05);
        }
        gl_FragColor=vec4(c*a,a*tw);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  starScene.add(new THREE.Points(geo,mat));
  return mat;
})();

// Accretion disk — 90k noise-density particles
const DISK_N=90000;
const disk={radii:new Float32Array(DISK_N),angles:new Float32Array(DISK_N),
  velocities:new Float32Array(DISK_N),baseColors:null,posAttr:null,colAttr:null,mat:null};

(function(){
  const N=DISK_N;
  const pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  let placed=0;
  while(placed<N){
    const r=1.02+Math.pow(Math.random(),0.45)*6.2;
    const angle=Math.random()*Math.PI*2;
    const nx=Math.cos(angle)*r,nz=Math.sin(angle)*r;
    const density=0.42+fbm(nx*0.3,nz*0.3,3)*0.28+fbm(nx*0.8+100,nz*0.8+100,2)*0.18+fbm(nx*2+200,nz*2+200,2)*0.1;
    if(Math.random()>density) continue;
    const i=placed;
    const tNorm=(r-1.02)/6.2;
    const thickness=0.008+tNorm*0.065;
    pos[i*3]=nx;pos[i*3+1]=(Math.random()-0.5)*thickness;pos[i*3+2]=nz;
    disk.radii[i]=r;disk.angles[i]=angle;
    disk.velocities[i]=1.0/Math.pow(r,1.5);
    const cn=(Math.random()-0.5)*0.03;
    let cr,cg,cb;
    if(tNorm<0.03){cr=1.0+cn;cg=0.95+cn;cb=0.82;}
    else if(tNorm<0.08){const b=(tNorm-0.03)/0.05;cr=1.0+cn;cg=0.95-b*0.05+cn;cb=0.82-b*0.25;}
    else if(tNorm<0.18){const b=(tNorm-0.08)/0.1;cr=1.0+cn;cg=0.9-b*0.08+cn;cb=0.55-b*0.2;}
    else if(tNorm<0.35){const b=(tNorm-0.18)/0.17;cr=1.0+cn;cg=0.8-b*0.15+cn*0.5;cb=0.32-b*0.15;}
    else if(tNorm<0.55){const b=(tNorm-0.35)/0.2;cr=1.0-b*0.05+cn;cg=0.6-b*0.2+cn*0.3;cb=0.15-b*0.07;}
    else if(tNorm<0.78){const b=(tNorm-0.55)/0.23;cr=0.92-b*0.14+cn;cg=0.35-b*0.15+cn*0.2;cb=0.07-b*0.03;}
    else{const b=(tNorm-0.78)/0.22;cr=0.7-b*0.28+cn;cg=0.15-b*0.08;cb=0.03;}
    const bn=0.88+(fbm(nx*0.3,nz*0.3,3)-0.5)*0.16+(fbm(nx*0.8+100,nz*0.8+100,2)-0.5)*0.06;
    cr*=bn;cg*=bn;cb*=bn;
    col[i*3]=Math.max(0,Math.min(1,cr));col[i*3+1]=Math.max(0,Math.min(1,cg));col[i*3+2]=Math.max(0,Math.min(1,cb));
    siz[i]=(0.22+Math.random()*0.8)*(1.0-tNorm*0.2);
    placed++;
  }
  disk.baseColors=new Float32Array(col);
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  disk.mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:diskTex},uMode:{value:0}},
    vertexShader:`
      attribute float size;varying vec3 vC;varying float vR;
      uniform float uTime,uPulse;
      void main(){
        vC=color*(1.0+uPulse*0.35);
        vR=length(position.xz);
        vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(100.0/-mv.z)*(1.0+uPulse*0.2);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`
      varying vec3 vC;varying float vR;uniform sampler2D uTex;uniform float uMode;
      void main(){
        float a=texture2D(uTex,gl_PointCoord).a*0.7;
        if(a<0.01)discard;
        float ib=1.0+smoothstep(4.0,1.02,vR)*1.0;
        vec3 c=vC*ib;
        if(uMode>0.5&&uMode<1.5){
          // X-RAY: remap to blue-white-purple
          float lum=dot(c,vec3(0.3,0.5,0.2));
          float hot=smoothstep(0.0,1.5,lum);
          vec3 xc=mix(vec3(0.1,0.0,0.3),vec3(0.3,0.5,1.0),hot);
          xc=mix(xc,vec3(0.9,0.95,1.0),hot*hot);
          c=xc*lum*2.0;
        } else if(uMode>1.5){
          // RADIO: remap to red-yellow synchrotron
          float lum=dot(c,vec3(0.3,0.5,0.2));
          float hot=smoothstep(0.0,1.2,lum);
          vec3 rc=mix(vec3(0.3,0.0,0.0),vec3(1.0,0.3,0.0),hot);
          rc=mix(rc,vec3(1.0,1.0,0.2),hot*hot*0.6);
          c=rc*lum*1.5;
        }
        gl_FragColor=vec4(c,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  disk.posAttr=geo.attributes.position;
  disk.colAttr=geo.attributes.color;
  const points=new THREE.Points(geo,disk.mat);
  points.rotation.x=0.08;points.rotation.z=0.05;
  scene.add(points);
})();

// Jets
function createJet(dir){
  const N=5000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const t=Math.pow(Math.random(),0.6);
    const h=t*14*dir,spread=t*t*0.45;
    const a=Math.random()*Math.PI*2,r=Math.random()*spread;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=h;pos[i*3+2]=Math.sin(a)*r;
    const b=1.0-t*0.85;
    col[i*3]=(0.4+t*0.15)*b;col[i*3+1]=(0.55+t*0.05)*b;col[i*3+2]=1.0*b;
    siz[i]=(1.0-t*0.6)*1.2;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uPulse:{value:0},uTex:{value:jetTex},uMode:{value:0}},
    vertexShader:`attribute float size;varying vec3 vC;uniform float uTime,uPulse;
      void main(){vC=color*(1.0+uPulse*0.3);
        vec3 p=position;float h=abs(p.y);
        p.x+=sin(uTime*2.5+h*1.2)*0.03*h*0.07;
        p.z+=cos(uTime*2.5+h*1.2)*0.03*h*0.07;
        vec4 mv=modelViewMatrix*vec4(p,1.0);
        gl_PointSize=size*(65.0/-mv.z)*(1.0+uPulse*0.4);
        gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;uniform float uMode;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.35;
        if(a<0.01)discard;
        vec3 c=vC;
        if(uMode>0.5&&uMode<1.5){
          // X-RAY: jets are bright in X-ray — hot blue-white
          float lum=dot(c,vec3(0.3,0.4,0.3));
          c=vec3(0.5,0.7,1.0)*lum*3.0;
          a*=1.5;
        } else if(uMode>1.5){
          // RADIO: jets are VERY bright — synchrotron emission
          float lum=dot(c,vec3(0.3,0.4,0.3));
          c=vec3(1.0,0.6,0.1)*lum*4.0;
          a*=2.5;
        }
        gl_FragColor=vec4(c,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  return{points:new THREE.Points(geo,mat),mat};
}
const jetUp=createJet(1),jetDown=createJet(-1);
scene.add(jetUp.points);scene.add(jetDown.points);

// Dust halo
const dustMat=(function(){
  const N=4000,pos=new Float32Array(N*3),col=new Float32Array(N*3),siz=new Float32Array(N);
  for(let i=0;i<N;i++){
    const r=5+Math.random()*14,a=Math.random()*Math.PI*2,y=(Math.random()-0.5)*2;
    pos[i*3]=Math.cos(a)*r;pos[i*3+1]=y;pos[i*3+2]=Math.sin(a)*r;
    col[i*3]=0.3;col[i*3+1]=0.15;col[i*3+2]=0.05;
    siz[i]=0.3+Math.random()*0.7;
  }
  const geo=new THREE.BufferGeometry();
  geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
  geo.setAttribute('color',new THREE.BufferAttribute(col,3));
  geo.setAttribute('size',new THREE.BufferAttribute(siz,1));
  const mat=new THREE.ShaderMaterial({
    uniforms:{uTime:{value:0},uTex:{value:diskTex}},
    vertexShader:`attribute float size;varying vec3 vC;
      void main(){vC=color;vec4 mv=modelViewMatrix*vec4(position,1.0);
        gl_PointSize=size*(55.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
    fragmentShader:`varying vec3 vC;uniform sampler2D uTex;
      void main(){float a=texture2D(uTex,gl_PointCoord).a*0.1;
        if(a<0.01)discard;gl_FragColor=vec4(vC,a);}`,
    transparent:true,vertexColors:true,blending:THREE.AdditiveBlending,depthWrite:false
  });
  scene.add(new THREE.Points(geo,mat));return mat;
})();

// ============================================================
// MATTER INFALL — particles spiraling into the void with trails
// Each "clump" is a trail of points that spiral inward, accelerate,
// brighten, and vanish at the event horizon, then respawn
// ============================================================
const INFALL_CLUMPS = 12;
const TRAIL_LEN = 40;
const INFALL_N = INFALL_CLUMPS * TRAIL_LEN;
const infall = { clumps: [], posAttr: null, colAttr: null, sizAttr: null, mat: null };

(function(){
  const pos = new Float32Array(INFALL_N * 3);
  const col = new Float32Array(INFALL_N * 3);
  const siz = new Float32Array(INFALL_N);

  // Initialize clumps
  for (let c = 0; c < INFALL_CLUMPS; c++) {
    infall.clumps.push({
      r: 3.0 + Math.random() * 4.0,        // start radius
      angle: Math.random() * Math.PI * 2,    // current angle
      phase: Math.random() * Math.PI * 2,    // y-wobble phase
      speed: 0.15 + Math.random() * 0.1,     // angular speed multiplier
      drift: 0.003 + Math.random() * 0.004,  // inward drift rate
      brightness: 0.5 + Math.random() * 0.5,
      trail: []  // store past positions
    });
    // Pre-fill trail
    const clump = infall.clumps[c];
    for (let t = 0; t < TRAIL_LEN; t++) {
      clump.trail.push({ x: 0, y: 0, z: 0 });
    }
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(col, 3));
  geo.setAttribute('size', new THREE.BufferAttribute(siz, 1));

  const glowTex = genSprite(64, 3.0, 0.8);
  infall.mat = new THREE.ShaderMaterial({
    uniforms: { uTime: { value: 0 }, uPulse: { value: 0 }, uTex: { value: glowTex }, uMode: { value: 0 } },
    vertexShader: `
      attribute float size; varying vec3 vC; varying float vA;
      uniform float uPulse;
      void main() {
        vC = color;
        vA = color.r + color.g + color.b;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (90.0 / -mv.z) * (1.0 + uPulse * 0.3);
        gl_Position = projectionMatrix * mv;
      }`,
    fragmentShader: `
      varying vec3 vC; varying float vA; uniform sampler2D uTex; uniform float uMode;
      void main() {
        float a = texture2D(uTex, gl_PointCoord).a * 0.8;
        if(a < 0.01) discard;
        vec3 c = vC;
        if(uMode > 0.5 && uMode < 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(0.6,0.8,1.0) * lum * 2.5;
        } else if(uMode > 1.5){
          float lum = dot(c, vec3(0.3,0.5,0.2));
          c = vec3(1.0,0.5,0.1) * lum * 2.0;
        }
        gl_FragColor = vec4(c, a);
      }`,
    transparent: true, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false
  });

  infall.posAttr = geo.attributes.position;
  infall.colAttr = geo.attributes.color;
  infall.sizAttr = geo.attributes.size;

  const points = new THREE.Points(geo, infall.mat);
  points.rotation.x = 0.08; points.rotation.z = 0.05;
  scene.add(points);
})();

function updateInfall(time) {
  const pa = infall.posAttr, ca = infall.colAttr, sa = infall.sizAttr;

  for (let c = 0; c < INFALL_CLUMPS; c++) {
    const cl = infall.clumps[c];

    // Keplerian angular velocity + acceleration as it spirals in
    const omega = cl.speed / Math.pow(cl.r, 1.5);
    cl.angle += omega * 0.015;

    // Inward spiral — accelerates as it gets closer
    const driftAccel = 1.0 + Math.pow(3.0 / Math.max(cl.r, 1.1), 2.0) * 2.0;
    cl.r -= cl.drift * driftAccel * 0.015;

    // Small y wobble
    const y = Math.sin(cl.phase + time * 0.5) * 0.015 * cl.r * 0.3;

    // Current head position
    const hx = Math.cos(cl.angle) * cl.r;
    const hz = Math.sin(cl.angle) * cl.r;

    // Push new position to trail front, shift old ones back
    for (let t = TRAIL_LEN - 1; t > 0; t--) {
      cl.trail[t].x = cl.trail[t-1].x;
      cl.trail[t].y = cl.trail[t-1].y;
      cl.trail[t].z = cl.trail[t-1].z;
    }
    cl.trail[0].x = hx;
    cl.trail[0].y = y;
    cl.trail[0].z = hz;

    // Respawn when it reaches the void
    if (cl.r < 1.05) {
      cl.r = 4.0 + Math.random() * 3.5;
      cl.angle = Math.random() * Math.PI * 2;
      cl.drift = 0.003 + Math.random() * 0.004;
      cl.speed = 0.15 + Math.random() * 0.1;
      cl.brightness = 0.5 + Math.random() * 0.5;
      // Reset trail to new position to avoid streaks across screen
      const nx = Math.cos(cl.angle) * cl.r;
      const nz = Math.sin(cl.angle) * cl.r;
      for (let t = 0; t < TRAIL_LEN; t++) {
        cl.trail[t].x = nx; cl.trail[t].y = 0; cl.trail[t].z = nz;
      }
    }

    // Write trail to buffers
    for (let t = 0; t < TRAIL_LEN; t++) {
      const idx = c * TRAIL_LEN + t;
      const trailFade = 1.0 - t / TRAIL_LEN; // 1.0 at head, 0.0 at tail

      pa.array[idx*3]   = cl.trail[t].x;
      pa.array[idx*3+1] = cl.trail[t].y;
      pa.array[idx*3+2] = cl.trail[t].z;

      // Color: gets hotter (whiter) as radius decreases
      const rNorm = Math.max(0, Math.min(1, (cl.r - 1.0) / 6.0));
      const heat = 1.0 - rNorm; // 1.0 = at void, 0.0 = outer edge

      // Trail head: bright hot color. Tail: fades to disk color
      const headR = 1.0;
      const headG = 0.7 + heat * 0.25;
      const headB = 0.3 + heat * 0.6;

      const intensity = trailFade * trailFade * cl.brightness * (0.8 + heat * 1.5);
      ca.array[idx*3]   = headR * intensity;
      ca.array[idx*3+1] = headG * intensity;
      ca.array[idx*3+2] = headB * intensity;

      // Size: head is bigger, tail tapers
      sa.array[idx] = (0.3 + heat * 0.6) * trailFade * cl.brightness;
    }
  }

  pa.needsUpdate = true;
  ca.needsUpdate = true;
  sa.needsUpdate = true;
}

// ============================================================
// COMPOSITE + BLOOM SHADERS
// ============================================================

// Gravitational lensing distortion for starfield
const lensMat=new THREE.ShaderMaterial({
  uniforms:{
    tStars:{value:null},
    uBHScreen:{value:new THREE.Vector2(0.5,0.5)}, // BH center in screen UV
    uBHRadius:{value:0.1}, // apparent angular radius of shadow in screen units
    uStrength:{value:1.5}
  },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform sampler2D tStars;
    uniform vec2 uBHScreen;
    uniform float uBHRadius, uStrength;
    varying vec2 vUv;

    void main(){
      vec2 delta = vUv - uBHScreen;
      float dist = length(delta);
      vec2 dir = delta / max(dist, 0.0001);

      // Schwarzschild-inspired deflection: α ∝ 1/b (impact parameter)
      // Stronger bending close to the photon sphere (1.5x shadow radius)
      float photonR = uBHRadius * 1.5;

      // Einstein ring radius in screen space
      float einsteinR = uBHRadius * 1.73; // √3 × shadow for Schwarzschild

      if(dist < uBHRadius * 0.85){
        // Inside shadow — black, no stars visible
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        return;
      }

      // Deflection magnitude — inverse distance law with smooth falloff
      float deflection = uStrength * uBHRadius * uBHRadius / (dist * dist + uBHRadius * 0.1);

      // Near photon sphere: amplification (Einstein ring brightening)
      float photonProx = exp(-pow(dist - photonR, 2.0) / (uBHRadius * uBHRadius * 0.15));
      deflection += photonProx * uBHRadius * 0.3;

      // Deflection pushes the sampling point OUTWARD (light bends inward)
      vec2 lensedUV = vUv + dir * deflection;

      // Clamp to valid UV range
      lensedUV = clamp(lensedUV, 0.0, 1.0);

      vec3 col = texture2D(tStars, lensedUV).rgb;

      // Einstein ring amplification — stars near photon sphere appear brighter
      float amp = 1.0 + photonProx * 3.0;
      col *= amp;

      gl_FragColor = vec4(col, 1.0);
    }
  `
});

// Combine BG + particles
const combineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec4 fg=texture2D(tParticles,vUv);
      // Particles use additive blending on black, so just add them to background
      // But where the void sphere rendered black, suppress the background too
      // Detect void: if particle pass is pure black AND we expect the void there
      float fgBright=dot(fg.rgb,vec3(1.0));
      // Use a mask: areas that rendered to exactly 0 might be void or empty space
      // We differentiate by checking if depth would have been written (void sphere)
      // Simple approach: if fg is very dark, show bg; if fg has content, add it
      vec3 col=bg+fg.rgb;
      gl_FragColor=vec4(col,1.0);
    }`
});

// But we need the void sphere to BLOCK the background stars behind it.
// Problem: with additive particle blending, the void renders as black (adds nothing).
// Solution: render the void sphere separately to a mask, or use a different approach.

// Better approach: render void sphere to write a mask in alpha channel
// Actually, simplest: render the particle scene with the void sphere writing alpha=1 black,
// then composite properly.

// Let me use a two-step approach for the particle scene:
// The void sphere renders with depthWrite=true and outputs black.
// Particles render on top with additive blending.
// If we render particles to a texture, void areas = black, space areas = black, particle areas = bright.
// We can't distinguish void from empty space...

// SOLUTION: Render a void-only pass to get a silhouette mask.
const voidMaskMat=new THREE.ShaderMaterial({
  uniforms:{uCamPos:{value:new THREE.Vector3()},uRes:{value:new THREE.Vector2()},uFov:{value:FOV_MULT}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`
    uniform vec3 uCamPos;uniform vec2 uRes;uniform float uFov;varying vec2 vUv;
    mat3 camMat(vec3 eye,vec3 tgt){
      vec3 f=normalize(tgt-eye),r=normalize(cross(f,vec3(0,1,0))),u=cross(r,f);
      return mat3(r,u,f);}
    void main(){
      vec2 uv=vUv-0.5;
      uv.x*=uRes.x/uRes.y;
      mat3 cam=camMat(uCamPos,vec3(0.0));
      vec3 rd=normalize(cam*vec3(uv*uFov,1.0));
      // Ray-sphere intersection for void (r=1.0)
      vec3 oc=uCamPos;
      float b2=dot(oc,rd);
      float c=dot(oc,oc)-1.0;
      float disc=b2*b2-c;
      float mask=disc>0.0?1.0:0.0;
      gl_FragColor=vec4(vec3(mask),1.0);
    }`
});

// Final combine: (lensedStars + BG glow) * (1-voidMask) + particles
const finalCombineMat=new THREE.ShaderMaterial({
  uniforms:{tBG:{value:null},tParticles:{value:null},tMask:{value:null},tStarsLensed:{value:null}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tBG,tParticles,tMask,tStarsLensed;varying vec2 vUv;
    void main(){
      vec3 bg=texture2D(tBG,vUv).rgb;
      vec3 stars=texture2D(tStarsLensed,vUv).rgb;
      vec3 fg=texture2D(tParticles,vUv).rgb;
      float mask=texture2D(tMask,vUv).r;
      // Behind void: suppress background and stars. Elsewhere: show everything
      vec3 col=(stars+bg)*(1.0-mask)+fg;
      gl_FragColor=vec4(col,1.0);
    }`
});

// Bloom threshold
const threshMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uThreshold:{value:0.28}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform float uThreshold;varying vec2 vUv;
    void main(){vec4 c=texture2D(tDiffuse,vUv);float b=dot(c.rgb,vec3(0.2126,0.7152,0.0722));
      gl_FragColor=b>uThreshold?c*smoothstep(uThreshold,uThreshold+0.4,b):vec4(0.0);}`
});
function mkBlur(h){return new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.5,window.innerHeight*0.5)},
    uDir:{value:h?new THREE.Vector2(1,0):new THREE.Vector2(0,1)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes,uDir;varying vec2 vUv;
    void main(){vec2 tx=uDir/uRes;vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv-tx*4.0)*0.0162;r+=texture2D(tDiffuse,vUv-tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv-tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv-tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv)*0.2270;r+=texture2D(tDiffuse,vUv+tx*1.0)*0.1945;
      r+=texture2D(tDiffuse,vUv+tx*2.0)*0.1216;r+=texture2D(tDiffuse,vUv+tx*3.0)*0.0540;
      r+=texture2D(tDiffuse,vUv+tx*4.0)*0.0162;gl_FragColor=r;}`});}
const blurH=mkBlur(true),blurV=mkBlur(false);

// Anamorphic streak — ultra-wide horizontal blur (13-tap, very spread)
const streakBlurMat=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:null},uRes:{value:new THREE.Vector2(window.innerWidth*0.25,window.innerHeight*0.25)}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform vec2 uRes;varying vec2 vUv;
    void main(){
      float tx=1.0/uRes.x*3.0; // 3x spread for very wide streaks
      vec4 r=vec4(0.0);
      r+=texture2D(tDiffuse,vUv+vec2(-6.0*tx,0))*0.012;
      r+=texture2D(tDiffuse,vUv+vec2(-5.0*tx,0))*0.025;
      r+=texture2D(tDiffuse,vUv+vec2(-4.0*tx,0))*0.045;
      r+=texture2D(tDiffuse,vUv+vec2(-3.0*tx,0))*0.075;
      r+=texture2D(tDiffuse,vUv+vec2(-2.0*tx,0))*0.105;
      r+=texture2D(tDiffuse,vUv+vec2(-1.0*tx,0))*0.135;
      r+=texture2D(tDiffuse,vUv)*0.155;
      r+=texture2D(tDiffuse,vUv+vec2(1.0*tx,0))*0.135;
      r+=texture2D(tDiffuse,vUv+vec2(2.0*tx,0))*0.105;
      r+=texture2D(tDiffuse,vUv+vec2(3.0*tx,0))*0.075;
      r+=texture2D(tDiffuse,vUv+vec2(4.0*tx,0))*0.045;
      r+=texture2D(tDiffuse,vUv+vec2(5.0*tx,0))*0.025;
      r+=texture2D(tDiffuse,vUv+vec2(6.0*tx,0))*0.012;
      // Slightly warm tint for cinematic look
      r.rgb*=vec3(1.0,0.95,0.85);
      gl_FragColor=r;
    }`
});

// Final output with bloom
const compositeMat=new THREE.ShaderMaterial({
  uniforms:{tScene:{value:null},tBloom:{value:null},tStreak:{value:null},uBloomStr:{value:1.5},uTime:{value:0},uMode:{value:0}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tScene,tBloom,tStreak;uniform float uBloomStr,uTime,uMode;varying vec2 vUv;
    float hash(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    void main(){
      vec3 sc=texture2D(tScene,vUv).rgb,bl=texture2D(tBloom,vUv).rgb;
      vec3 streak=texture2D(tStreak,vUv).rgb;
      vec3 col=sc+bl*uBloomStr+streak*0.6;
      float d=length(vUv-0.5),ca=d*d*0.004;
      col.r+=texture2D(tBloom,vUv+vec2(ca)).r*uBloomStr*0.18;
      col.b+=texture2D(tBloom,vUv-vec2(ca)).b*uBloomStr*0.18;
      // Mode-dependent overall tint
      if(uMode>0.5&&uMode<1.5){
        // X-RAY: cool blue tint, higher contrast
        col=col*vec3(0.7,0.85,1.2);
        col=pow(col,vec3(1.1)); // slightly more contrast
      } else if(uMode>1.5){
        // RADIO: warm tint, false color feel
        col=col*vec3(1.1,0.9,0.7);
      }
      col*=1.0-d*0.6;
      col+=(hash(vUv*800.0+fract(uTime))-0.5)*0.02;
      gl_FragColor=vec4(col,1.0);}`
});

// Fullscreen quad + scene for post-processing
const postScene=new THREE.Scene();
const postQuad=new THREE.Mesh(fsGeo.clone(),compositeMat);
postScene.add(postQuad);

let rtMask=makeRT(1);

// ============================================================
// CAMERA
// ============================================================
let isDragging=false,prevMouse={x:0,y:0};
let sph={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let tgt={theta:0.3,phi:Math.PI/2.6,radius:7.5};
let pulse=0;

function pD(x,y){isDragging=true;prevMouse={x,y};}
function pM(x,y){if(!isDragging)return;
  tgt.theta-=(x-prevMouse.x)*0.004;
  tgt.phi=Math.max(0.2,Math.min(Math.PI-0.2,tgt.phi-(y-prevMouse.y)*0.004));
  prevMouse={x,y};}
function pU(){isDragging=false;}
document.addEventListener('mousedown',e=>pD(e.clientX,e.clientY));
document.addEventListener('mousemove',e=>pM(e.clientX,e.clientY));
document.addEventListener('mouseup',pU);
document.addEventListener('touchstart',e=>{e.preventDefault();pD(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchmove',e=>{e.preventDefault();pM(e.touches[0].clientX,e.touches[0].clientY);},{passive:false});
document.addEventListener('touchend',pU);
document.addEventListener('wheel',e=>{tgt.radius=Math.max(2.5,Math.min(25,tgt.radius+e.deltaY*0.008));},{passive:true});
document.addEventListener('keydown',e=>{
  if(e.code==='Space'){e.preventDefault();pulse=1.0;triggerPulseSound();}
  if(e.key==='1') setWaveMode(0);
  if(e.key==='2') setWaveMode(1);
  if(e.key==='3') setWaveMode(2);
});

let waveMode=0;
function setWaveMode(m){
  waveMode=m;
  document.querySelectorAll('#wavemode button').forEach((btn,i)=>{
    btn.classList.toggle('active',i===m);
  });
  [disk.mat,jetUp.mat,jetDown.mat,infall.mat].forEach(mat=>{
    if(mat.uniforms.uMode) mat.uniforms.uMode.value=m;
  });
  compositeMat.uniforms.uMode.value=m;
  bgMat.uniforms.uMode.value=m;
  starsMat.uniforms.uMode.value=m;
}

// ============================================================
// SOUND DESIGN — Web Audio API
// Deep space ambient drone, proximity rumble, pulse FX
// Initialized on first user interaction (autoplay policy)
// ============================================================
let audioCtx=null, audioInitialized=false;
let droneGain,rumbleGain,masterGain;
let droneOscs=[],rumbleOsc,rumbleLFO;

function initAudio(){
  if(audioInitialized) return;
  audioInitialized=true;

  audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  const now=audioCtx.currentTime;

  masterGain=audioCtx.createGain();
  masterGain.gain.value=0;
  masterGain.connect(audioCtx.destination);
  // Fade in over 3 seconds
  masterGain.gain.linearRampToValueAtTime(0.6, now+3);

  // === AMBIENT DRONE ===
  // Multiple detuned oscillators for rich, evolving texture
  droneGain=audioCtx.createGain();
  droneGain.gain.value=0.12;
  droneGain.connect(masterGain);

  // Low foundation — deep Bb
  const droneFreqs=[29.14, 29.14*1.002, 29.14*0.998]; // Bb0 with slight detune
  droneFreqs.forEach((freq,i)=>{
    const osc=audioCtx.createOscillator();
    osc.type='sine';
    osc.frequency.value=freq;
    const g=audioCtx.createGain();
    g.gain.value=0.35;
    osc.connect(g);
    g.connect(droneGain);
    osc.start();
    droneOscs.push({osc,gain:g});
  });

  // Mid harmonic layer — fifth above, filtered
  const midFreqs=[43.65, 43.65*1.003]; // F1
  midFreqs.forEach(freq=>{
    const osc=audioCtx.createOscillator();
    osc.type='triangle';
    osc.frequency.value=freq;
    const filter=audioCtx.createBiquadFilter();
    filter.type='lowpass';
    filter.frequency.value=120;
    filter.Q.value=2;
    const g=audioCtx.createGain();
    g.gain.value=0.2;
    osc.connect(filter);
    filter.connect(g);
    g.connect(droneGain);
    osc.start();
    droneOscs.push({osc,gain:g,filter});
  });

  // High ethereal whisper — very quiet, evolving
  const highOsc=audioCtx.createOscillator();
  highOsc.type='sine';
  highOsc.frequency.value=174.6; // F3
  const highFilter=audioCtx.createBiquadFilter();
  highFilter.type='bandpass';
  highFilter.frequency.value=175;
  highFilter.Q.value=15;
  const highGain=audioCtx.createGain();
  highGain.gain.value=0.03;
  highOsc.connect(highFilter);
  highFilter.connect(highGain);
  highGain.connect(droneGain);
  highOsc.start();
  droneOscs.push({osc:highOsc,gain:highGain,filter:highFilter});

  // LFO to modulate drone volume — slow breathing
  const droneLFO=audioCtx.createOscillator();
  droneLFO.type='sine';
  droneLFO.frequency.value=0.06; // ~16 second cycle
  const lfoGain=audioCtx.createGain();
  lfoGain.gain.value=0.03;
  droneLFO.connect(lfoGain);
  lfoGain.connect(droneGain.gain);
  droneLFO.start();

  // === PROXIMITY RUMBLE ===
  // Low freq noise that intensifies as camera approaches
  rumbleGain=audioCtx.createGain();
  rumbleGain.gain.value=0;
  rumbleGain.connect(masterGain);

  rumbleOsc=audioCtx.createOscillator();
  rumbleOsc.type='sawtooth';
  rumbleOsc.frequency.value=22;
  const rumbleFilter=audioCtx.createBiquadFilter();
  rumbleFilter.type='lowpass';
  rumbleFilter.frequency.value=60;
  rumbleFilter.Q.value=3;
  rumbleOsc.connect(rumbleFilter);
  rumbleFilter.connect(rumbleGain);
  rumbleOsc.start();

  // Rumble LFO — menacing throb
  rumbleLFO=audioCtx.createOscillator();
  rumbleLFO.type='sine';
  rumbleLFO.frequency.value=0.3;
  const rumbleLFOGain=audioCtx.createGain();
  rumbleLFOGain.gain.value=0.05;
  rumbleLFO.connect(rumbleLFOGain);
  rumbleLFOGain.connect(rumbleGain.gain);
  rumbleLFO.start();

  // === NOISE LAYER ===
  // Filtered white noise for texture — like radiation hiss
  const bufferSize=audioCtx.sampleRate*2;
  const noiseBuffer=audioCtx.createBuffer(1,bufferSize,audioCtx.sampleRate);
  const data=noiseBuffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i]=(Math.random()*2-1);
  const noiseNode=audioCtx.createBufferSource();
  noiseNode.buffer=noiseBuffer;
  noiseNode.loop=true;
  const noiseFilter=audioCtx.createBiquadFilter();
  noiseFilter.type='bandpass';
  noiseFilter.frequency.value=80;
  noiseFilter.Q.value=0.5;
  const noiseGain=audioCtx.createGain();
  noiseGain.gain.value=0.015;
  noiseNode.connect(noiseFilter);
  noiseFilter.connect(noiseGain);
  noiseGain.connect(masterGain);
  noiseNode.start();

  // Store refs for proximity updates
  window._audioRefs={rumbleGain,rumbleFilter:rumbleFilter,noiseFilter,noiseGain,droneGain,masterGain,highGain};
}

function triggerPulseSound(){
  if(!audioCtx) return;
  const now=audioCtx.currentTime;

  // Deep impact — sub bass hit
  const impact=audioCtx.createOscillator();
  impact.type='sine';
  impact.frequency.setValueAtTime(80,now);
  impact.frequency.exponentialRampToValueAtTime(20,now+1.5);
  const impactGain=audioCtx.createGain();
  impactGain.gain.setValueAtTime(0.4,now);
  impactGain.gain.exponentialRampToValueAtTime(0.001,now+2);
  impact.connect(impactGain);
  impactGain.connect(masterGain);
  impact.start(now);
  impact.stop(now+2);

  // High shimmer — metallic ring
  const shimmer=audioCtx.createOscillator();
  shimmer.type='sine';
  shimmer.frequency.value=1200;
  const shimFilter=audioCtx.createBiquadFilter();
  shimFilter.type='bandpass';
  shimFilter.frequency.value=1200;
  shimFilter.Q.value=20;
  const shimGain=audioCtx.createGain();
  shimGain.gain.setValueAtTime(0.06,now);
  shimGain.gain.exponentialRampToValueAtTime(0.001,now+3);
  shimmer.connect(shimFilter);
  shimFilter.connect(shimGain);
  shimGain.connect(masterGain);
  shimmer.start(now);
  shimmer.stop(now+3);

  // Noise burst — whoosh
  const burstSize=audioCtx.sampleRate;
  const burstBuf=audioCtx.createBuffer(1,burstSize,audioCtx.sampleRate);
  const bd=burstBuf.getChannelData(0);
  for(let i=0;i<burstSize;i++) bd[i]=(Math.random()*2-1);
  const burst=audioCtx.createBufferSource();
  burst.buffer=burstBuf;
  const burstFilter=audioCtx.createBiquadFilter();
  burstFilter.type='lowpass';
  burstFilter.frequency.setValueAtTime(3000,now);
  burstFilter.frequency.exponentialRampToValueAtTime(100,now+1.5);
  const burstGain=audioCtx.createGain();
  burstGain.gain.setValueAtTime(0.15,now);
  burstGain.gain.exponentialRampToValueAtTime(0.001,now+1.5);
  burst.connect(burstFilter);
  burstFilter.connect(burstGain);
  burstGain.connect(masterGain);
  burst.start(now);

  // Momentary drone swell
  if(window._audioRefs){
    window._audioRefs.droneGain.gain.setValueAtTime(0.25,now);
    window._audioRefs.droneGain.gain.linearRampToValueAtTime(0.12,now+2);
  }
}

function updateAudio(){
  if(!window._audioRefs) return;
  const refs=window._audioRefs;
  const dist=sph.radius;

  // Proximity rumble: louder as camera gets closer
  // Range: radius 2.5 (max rumble) to 15 (silent)
  const proximity=Math.max(0,1.0-(dist-2.5)/12.5);
  const rumbleVol=proximity*proximity*0.15;
  refs.rumbleGain.gain.linearRampToValueAtTime(rumbleVol,audioCtx.currentTime+0.1);

  // Noise filter opens up when closer
  refs.noiseFilter.frequency.linearRampToValueAtTime(60+proximity*200,audioCtx.currentTime+0.1);
  refs.noiseGain.gain.linearRampToValueAtTime(0.01+proximity*0.03,audioCtx.currentTime+0.1);

  // High harmonic gets louder at medium distance (sweet spot)
  const midProx=Math.exp(-Math.pow(dist-6,2)*0.05);
  refs.highGain.gain.linearRampToValueAtTime(0.02+midProx*0.04,audioCtx.currentTime+0.1);
}

// Init audio on first interaction
['mousedown','touchstart','keydown'].forEach(evt=>{
  document.addEventListener(evt,initAudio,{once:false});
});

// ============================================================
// ANIMATION
// ============================================================
const clock=new THREE.Clock();
const timeMats=[disk.mat,jetUp.mat,jetDown.mat,dustMat,infall.mat,starsMat];

function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();

  sph.theta+=(tgt.theta-sph.theta)*0.05;
  sph.phi+=(tgt.phi-sph.phi)*0.05;
  sph.radius+=(tgt.radius-sph.radius)*0.05;
  if(!isDragging) tgt.theta+=0.0003;

  camera.position.set(
    sph.radius*Math.sin(sph.phi)*Math.sin(sph.theta),
    sph.radius*Math.cos(sph.phi),
    sph.radius*Math.sin(sph.phi)*Math.cos(sph.theta)
  );
  camera.lookAt(0,0,0);
  pulse*=0.94;
  updateAudio();

  timeMats.forEach(m=>{
    if(m.uniforms.uTime)m.uniforms.uTime.value=t;
    if(m.uniforms.uPulse)m.uniforms.uPulse.value=pulse;
  });

  // Update disk
  const pa=disk.posAttr,ca=disk.colAttr,bc=disk.baseColors;
  const camA=Math.atan2(camera.position.x,camera.position.z);
  for(let i=0;i<DISK_N;i++){
    disk.angles[i]+=disk.velocities[i]*0.004;
    const r=disk.radii[i],a=disk.angles[i];
    pa.array[i*3]=Math.cos(a)*r;
    pa.array[i*3+2]=Math.sin(a)*r;
    const dop=0.5+0.6*Math.cos(a-camA);
    const df=0.5+dop*0.55;
    ca.array[i*3]=bc[i*3]*df;ca.array[i*3+1]=bc[i*3+1]*df;ca.array[i*3+2]=bc[i*3+2]*df;
  }
  pa.needsUpdate=true;ca.needsUpdate=true;

  // Update infall particles
  updateInfall(t);

  // Update BG shader camera
  bgMat.uniforms.uCamPos.value.copy(camera.position);
  bgMat.uniforms.uTime.value=t;

  // Update void mask camera
  voidMaskMat.uniforms.uCamPos.value.copy(camera.position);
  voidMaskMat.uniforms.uRes.value.set(window.innerWidth,window.innerHeight);

  // ---- RENDER PIPELINE ----

  // 0. Compute BH screen position for lens shader
  const bhPos3=new THREE.Vector3(0,0,0);
  bhPos3.project(camera);
  const bhScreenX=(bhPos3.x*0.5+0.5);
  const bhScreenY=(bhPos3.y*0.5+0.5);
  // Apparent angular radius: project a point on the event horizon
  const edgePos=new THREE.Vector3(1,0,0);
  edgePos.project(camera);
  const edgeScreenX=(edgePos.x*0.5+0.5);
  const bhScreenR=Math.abs(edgeScreenX-bhScreenX)*1.1;

  lensMat.uniforms.uBHScreen.value.set(bhScreenX,bhScreenY);
  lensMat.uniforms.uBHRadius.value=Math.max(0.01,bhScreenR);

  // 1. Render stars to texture
  renderer.setRenderTarget(rtStars);
  renderer.setClearColor(0x000000,1);renderer.clear();
  renderer.render(starScene,camera);

  // 2. Apply gravitational lensing distortion
  lensMat.uniforms.tStars.value=rtStars.texture;
  postQuad.material=lensMat;
  renderer.setRenderTarget(rtStarsLensed);renderer.clear();
  renderer.render(postScene,ortho);

  // 3. Raymarched BG glow (Einstein ring)
  renderer.setRenderTarget(rtBG);renderer.clear();
  renderer.render(bgScene,ortho);

  // 4. Void mask
  postQuad.material=voidMaskMat;
  renderer.setRenderTarget(rtMask);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Particle scene (disk, jets, void, dust, infall — no stars)
  renderer.setRenderTarget(rtParticles);
  renderer.setClearColor(0x000000,1);renderer.clear();
  renderer.render(scene,camera);

  // 6. Combine: (lensedStars + bg) * (1-mask) + particles
  finalCombineMat.uniforms.tBG.value=rtBG.texture;
  finalCombineMat.uniforms.tStarsLensed.value=rtStarsLensed.texture;
  finalCombineMat.uniforms.tParticles.value=rtParticles.texture;
  finalCombineMat.uniforms.tMask.value=rtMask.texture;
  postQuad.material=finalCombineMat;
  renderer.setRenderTarget(rtCombined);renderer.clear();
  renderer.render(postScene,ortho);

  // 5. Bloom: extract bright
  threshMat.uniforms.tDiffuse.value=rtCombined.texture;
  postQuad.material=threshMat;
  renderer.setRenderTarget(rtBright);renderer.clear();
  renderer.render(postScene,ortho);

  // Blur passes (bloom)
  for(let p=0;p<3;p++){
    blurH.uniforms.tDiffuse.value=p===0?rtBright.texture:rtBlurB.texture;
    postQuad.material=blurH;
    renderer.setRenderTarget(rtBlurA);renderer.clear();
    renderer.render(postScene,ortho);
    blurV.uniforms.tDiffuse.value=rtBlurA.texture;
    postQuad.material=blurV;
    renderer.setRenderTarget(rtBlurB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 5b. Anamorphic streak passes — ultra-wide horizontal blur
  // Start from bright extract, run 4 wide horizontal passes for massive spread
  for(let s=0;s<4;s++){
    streakBlurMat.uniforms.tDiffuse.value=s===0?rtBright.texture:rtStreakB.texture;
    postQuad.material=streakBlurMat;
    renderer.setRenderTarget(rtStreakA);renderer.clear();
    renderer.render(postScene,ortho);
    // Ping-pong
    streakBlurMat.uniforms.tDiffuse.value=rtStreakA.texture;
    renderer.setRenderTarget(rtStreakB);renderer.clear();
    renderer.render(postScene,ortho);
  }

  // 6. Final composite with bloom + streaks
  compositeMat.uniforms.tScene.value=rtCombined.texture;
  compositeMat.uniforms.tBloom.value=rtBlurB.texture;
  compositeMat.uniforms.tStreak.value=rtStreakB.texture;
  compositeMat.uniforms.uTime.value=t;
  compositeMat.uniforms.uBloomStr.value=1.4+pulse*1.2;
  postQuad.material=compositeMat;
  renderer.setRenderTarget(null);renderer.clear();
  renderer.render(postScene,ortho);
}
animate();

window.addEventListener('resize',()=>{
  const w=window.innerWidth,h=window.innerHeight;
  camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h);
  bgMat.uniforms.uRes.value.set(w,h);
  voidMaskMat.uniforms.uRes.value.set(w,h);
  const p=Math.min(window.devicePixelRatio,2);
  rtParticles.setSize(w*p,h*p);rtCombined.setSize(w*p,h*p);
  rtBG.setSize(w*p,h*p);rtMask.setSize(w*p,h*p);
  rtStars.setSize(w*p,h*p);rtStarsLensed.setSize(w*p,h*p);
  rtBright.setSize(w*p*0.5,h*p*0.5);
  [rtBlurA,rtBlurB].forEach(rt=>rt.setSize(w*p*0.5,h*p*0.5));
  [rtStreakA,rtStreakB].forEach(rt=>rt.setSize(w*p*0.25,h*p*0.25));
  [blurH,blurV].forEach(m=>m.uniforms.uRes.value.set(w*0.5,h*0.5));
  streakBlurMat.uniforms.uRes.value.set(w*0.25,h*0.25);
});
</script>
</body>
</html>
